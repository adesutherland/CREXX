/* 
 * rexx SUBSTR bif in rxas. Uses length.rxas
 * rudimentary error checking
 */

    .globals=0
length()  .expose=global.length          
substr()  .locals=18 .expose=global.substr
    /* string    = arg1    */
    /* n (start) = arg2    */
    load  r7," " /* the default pad character */
    load  r6,0   /* the length field initialized to 0 */
    ilt   r1,a0,2 /* less than 2 arguments */
    brt   wrongargs,r1
    igt   r1,a0,4 /* more than 4 arguments */
    brt   wrongargs,r1
    ieq   r1,a0,2
    brt   substr,r1 /* we have two arguments */
    /* we have 3 or 4 arguments */
    copy  r6,a3 /* save length field in r6*/
    ieq   r1,a0,4
    brf   substr,r1 /* we do not have 4 arguments, no pad */
    copy  r7,a4  /* we have a pad, replace the default one */
    br    substr
wrongargs:
    /* we are here if there are not enough, or too many arguments */
    say "substr needs at least two and at most 4 arguments"
    exit
substr:
    /* we want to know the length of the string argument */
    load  r3,1 /* there is one argument for the call to length() */
    copy  r4,a1 /* and it is the string in a1 */
    call  r10,length(),r3 /* what is the length of the string arg */
    copy  r12,r10 /* the preliminary loop counter is the strlength */
    dec   a2
    /* if r6 is nonzero, we have a length argument, a2:=r8+1 */
    igt   r1,r6,0
    brf   skip,r1
    iadd  r12,r10,a2
    isub  r10,r10,a2 /* loop r10 from original string length */
    isub  r12,r6,r10
    copy  r10,r6 /* final conc loop length */
    br    loop
skip:
    load  r12,0 /* with no length, never need to pad */
    /* now loop characters from a1 from start pos in a2 to (length) r1 */
loop:
    concchar r14,r4,a2
    bct   loop,r10,a2 /* loop inc a2 and dec r10 */
    /* check if we need to pad */
    igte  r1,r12,1
    brt   pad,r1
    br    end
pad:
    concat r14,r7,r14
    say "we are padding with"
    say r7
    say "for times"
    itos r12
    say r12
    say  r14
    bct   pad,r12
end:
    ret   r15
    exit
                
    
