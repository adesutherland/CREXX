Options parser >> Input 'TK_OPTIONS' in state 0
Options parser >> Shift 'TK_OPTIONS', go to state 1
Options parser >> Return. Stack=[TK_OPTIONS]
Options parser >> Input 'TK_LEVELB' in state 1
Options parser >> Shift 'TK_LEVELB', go to state 16
Options parser >> Return. Stack=[TK_OPTIONS TK_LEVELB]
Options parser >> Input 'TK_EOC' in state 16
Options parser >> Reduce 4 [option ::= TK_LEVELB], pop back to state 1.
Options parser >> ... then shift 'option', go to state 4
Options parser >> Reduce 18 [option_list ::= option] without external action, pop back to state 1.
Options parser >> ... then shift 'option_list', go to state 2
Options parser >> Shift 'TK_EOC', go to state 23
Options parser >> Return. Stack=[TK_OPTIONS option_list TK_EOC]
Options parser >> Input 'TK_SYMBOL' in state 23
Options parser >> WILDCARD TK_SYMBOL => ANYTHING
Options parser >> Reduce 2 [rexx_options ::= TK_OPTIONS option_list TK_EOC], pop back to state 0.
Options parser >> ... then shift 'rexx_options', go to state 3
Options parser >> WILDCARD TK_SYMBOL => ANYTHING
Options parser >> Shift 'TK_SYMBOL', go to state 20
Options parser >> Return. Stack=[rexx_options TK_SYMBOL]
Options parser >> Popping TK_SYMBOL
Options parser >> Popping rexx_options
Parser(B) >> Input 'TK_OPTIONS' in state 0
Parser(B) >> Shift 'TK_OPTIONS', go to state 81
Parser(B) >> Return. Stack=[TK_OPTIONS]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 81
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 297
Parser(B) >> Return. Stack=[TK_OPTIONS TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EOC' in state 297
Parser(B) >> Reduce 18 [option ::= TK_VAR_SYMBOL], pop back to state 81.
Parser(B) >> ... then shift 'option', go to state 296
Parser(B) >> Reduce 16 [option_list ::= option], pop back to state 81.
Parser(B) >> ... then shift 'option_list', go to state 89
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 129
Parser(B) >> Shift 'TK_EOC', go to state 194
Parser(B) >> Return. Stack=[TK_OPTIONS option_list junk TK_EOC]
Parser(B) >> Input 'TK_NAMESPACE' in state 194
Parser(B) >> Reduce 15 [rexx_options ::= TK_OPTIONS option_list junk TK_EOC], pop back to state 0.
Parser(B) >> ... then shift 'rexx_options', go to state 1
Parser(B) >> Shift 'TK_NAMESPACE', go to state 114
Parser(B) >> Return. Stack=[rexx_options TK_NAMESPACE]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 114
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 96
Parser(B) >> Return. Stack=[rexx_options TK_NAMESPACE TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EOC' in state 96
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 387
Parser(B) >> Shift 'TK_EOC', go to state 203
Parser(B) >> Return. Stack=[rexx_options TK_NAMESPACE TK_VAR_SYMBOL junk TK_EOC]
Parser(B) >> Input 'TK_LABEL' in state 203
Parser(B) >> Reduce 22 [namespace_instruction ::= TK_NAMESPACE TK_VAR_SYMBOL junk TK_EOC], pop back to state 1.
Parser(B) >> ... then shift 'namespace_instruction', go to state 196
Parser(B) >> Reduce 19 [namespace_list ::= namespace_instruction], pop back to state 1.
Parser(B) >> ... then shift 'namespace_list', go to state 2
Parser(B) >> Shift 'TK_LABEL', go to state 172
Parser(B) >> Return. Stack=[rexx_options namespace_list TK_LABEL]
Parser(B) >> Input 'TK_PROCEDURE' in state 172
Parser(B) >> Shift 'TK_PROCEDURE', go to state 315
Parser(B) >> Return. Stack=[rexx_options namespace_list TK_LABEL TK_PROCEDURE]
Parser(B) >> Input 'TK_EQUAL' in state 315
Parser(B) >> Shift 'TK_EQUAL', go to state 131
Parser(B) >> Return. Stack=[rexx_options namespace_list TK_LABEL TK_PROCEDURE TK_EQUAL]
Parser(B) >> Input 'TK_CLASS' in state 131
Parser(B) >> Shift 'TK_CLASS', go to state 314
Parser(B) >> Return. Stack=[rexx_options namespace_list TK_LABEL TK_PROCEDURE TK_EQUAL TK_CLASS]
Parser(B) >> Input 'TK_EOC' in state 314
Parser(B) >> Reduce 116 [class ::= TK_CLASS], pop back to state 131.
Parser(B) >> ... then shift 'class', go to state 375
Parser(B) >> Reduce 112 [procedure ::= TK_LABEL TK_PROCEDURE TK_EQUAL class], pop back to state 2.
Parser(B) >> ... then shift 'procedure', go to state 363
Parser(B) >> Reduce 54 [keyword_instruction ::= procedure], pop back to state 2.
Parser(B) >> ... then shift 'keyword_instruction', go to state 371
Parser(B) >> Reduce 43 [single_instruction ::= keyword_instruction], pop back to state 2.
Parser(B) >> ... then shift 'single_instruction', go to state 102
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 404
Parser(B) >> Shift 'TK_EOC', go to state 191
Parser(B) >> Return. Stack=[rexx_options namespace_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_ARG' in state 191
Parser(B) >> Reduce 32 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 2.
Parser(B) >> ... then shift 'labeled_instruction', go to state 183
Parser(B) >> Reduce 29 [instruction_list ::= labeled_instruction], pop back to state 2.
Parser(B) >> ... then shift 'instruction_list', go to state 11
Parser(B) >> Shift 'TK_ARG', go to state 82
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_ARG]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 82
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 293
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_ARG TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 293
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 82.
Parser(B) >> ... then shift 'var_symbol', go to state 398
Parser(B) >> Shift 'TK_EQUAL', go to state 19
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_ARG var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_CLASS' in state 19
Parser(B) >> Shift 'TK_CLASS', go to state 314
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_ARG var_symbol TK_EQUAL TK_CLASS]
Parser(B) >> Input 'TK_EOC' in state 314
Parser(B) >> Reduce 116 [class ::= TK_CLASS], pop back to state 19.
Parser(B) >> ... then shift 'class', go to state 309
Parser(B) >> Reduce 121 [argument ::= var_symbol TK_EQUAL class], pop back to state 82.
Parser(B) >> ... then shift 'argument', go to state 307
Parser(B) >> Reduce 118 [arg_list ::= argument], pop back to state 82.
Parser(B) >> ... then shift 'arg_list', go to state 313
Parser(B) >> Reduce 115 [arg ::= TK_ARG arg_list], pop back to state 11.
Parser(B) >> ... then shift 'arg', go to state 368
Parser(B) >> Reduce 49 [keyword_instruction ::= arg], pop back to state 11.
Parser(B) >> ... then shift 'keyword_instruction', go to state 371
Parser(B) >> Reduce 43 [single_instruction ::= keyword_instruction], pop back to state 11.
Parser(B) >> ... then shift 'single_instruction', go to state 102
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 404
Parser(B) >> Shift 'TK_EOC', go to state 191
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_RETURN' in state 191
Parser(B) >> Reduce 32 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 11.
Parser(B) >> ... then shift 'labeled_instruction', go to state 193
Parser(B) >> Reduce 30 [instruction_list ::= instruction_list labeled_instruction], pop back to state 2.
Parser(B) >> ... then shift 'instruction_list', go to state 11
Parser(B) >> Shift 'TK_RETURN', go to state 23
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_RETURN]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 23
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 110
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_RETURN TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_MULT' in state 110
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 23.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 172 [term ::= var_symbol], pop back to state 23.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 176 [bracket ::= term], pop back to state 23.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 178 [prefix_expression ::= bracket], pop back to state 23.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 182 [power_expression ::= prefix_expression], pop back to state 23.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 184 [multiplication ::= power_expression], pop back to state 23.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Shift 'TK_MULT', go to state 70
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_RETURN multiplication TK_MULT]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 70
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 110
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_RETURN multiplication TK_MULT TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EOC' in state 110
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 70.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 172 [term ::= var_symbol], pop back to state 70.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 176 [bracket ::= term], pop back to state 70.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 178 [prefix_expression ::= bracket], pop back to state 70.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 182 [power_expression ::= prefix_expression], pop back to state 70.
Parser(B) >> ... then shift 'power_expression', go to state 220
Parser(B) >> Reduce 185 [multiplication ::= multiplication TK_MULT power_expression], pop back to state 23.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 189 [addition ::= multiplication], pop back to state 23.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 204 [concatenation ::= addition], pop back to state 23.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 207 [comparison ::= concatenation], pop back to state 23.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 220 [or_expression ::= comparison], pop back to state 23.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 222 [and_expression ::= or_expression], pop back to state 23.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 245 [expression ::= and_expression], pop back to state 23.
Parser(B) >> ... then shift 'expression', go to state 328
Parser(B) >> Reduce 154 [return ::= TK_RETURN expression], pop back to state 11.
Parser(B) >> ... then shift 'return', go to state 362
Parser(B) >> Reduce 55 [keyword_instruction ::= return], pop back to state 11.
Parser(B) >> ... then shift 'keyword_instruction', go to state 371
Parser(B) >> Reduce 43 [single_instruction ::= keyword_instruction], pop back to state 11.
Parser(B) >> ... then shift 'single_instruction', go to state 102
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 404
Parser(B) >> Shift 'TK_EOC', go to state 191
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_EOS' in state 191
Parser(B) >> Reduce 32 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 11.
Parser(B) >> ... then shift 'labeled_instruction', go to state 193
Parser(B) >> Reduce 30 [instruction_list ::= instruction_list labeled_instruction], pop back to state 2.
Parser(B) >> ... then shift 'instruction_list', go to state 11
Parser(B) >> Shift 'TK_EOS', go to state 406
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_EOS]
Parser(B) >> Input '$' in state 406
Parser(B) >> Reduce 0 [program ::= rexx_options namespace_list instruction_list TK_EOS], pop back to state 0.
Parser(B) >> ... then shift 'program', pending reduce -2
Parser(B) >> Accept!
