Options parser >> Input 'TK_OPTIONS' in state 0
Options parser >> Shift 'TK_OPTIONS', go to state 1
Options parser >> Return. Stack=[TK_OPTIONS]
Options parser >> Input 'TK_LEVELB' in state 1
Options parser >> Shift 'TK_LEVELB', go to state 16
Options parser >> Return. Stack=[TK_OPTIONS TK_LEVELB]
Options parser >> Input 'TK_EOC' in state 16
Options parser >> Reduce 4 [option ::= TK_LEVELB], pop back to state 1.
Options parser >> ... then shift 'option', go to state 4
Options parser >> Reduce 18 [option_list ::= option] without external action, pop back to state 1.
Options parser >> ... then shift 'option_list', go to state 2
Options parser >> Shift 'TK_EOC', go to state 23
Options parser >> Return. Stack=[TK_OPTIONS option_list TK_EOC]
Options parser >> Input 'TK_SYMBOL' in state 23
Options parser >> WILDCARD TK_SYMBOL => ANYTHING
Options parser >> Reduce 2 [rexx_options ::= TK_OPTIONS option_list TK_EOC], pop back to state 0.
Options parser >> ... then shift 'rexx_options', go to state 3
Options parser >> WILDCARD TK_SYMBOL => ANYTHING
Options parser >> Shift 'TK_SYMBOL', go to state 20
Options parser >> Return. Stack=[rexx_options TK_SYMBOL]
Options parser >> Popping TK_SYMBOL
Options parser >> Popping rexx_options
Parser(B) >> Input 'TK_OPTIONS' in state 0
Parser(B) >> Shift 'TK_OPTIONS', go to state 84
Parser(B) >> Return. Stack=[TK_OPTIONS]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 84
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 325
Parser(B) >> Return. Stack=[TK_OPTIONS TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EOC' in state 325
Parser(B) >> Reduce 31 [option ::= TK_VAR_SYMBOL], pop back to state 84.
Parser(B) >> ... then shift 'option', go to state 324
Parser(B) >> Reduce 29 [option_list ::= option], pop back to state 84.
Parser(B) >> ... then shift 'option_list', go to state 101
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 151
Parser(B) >> Shift 'TK_EOC', go to state 213
Parser(B) >> Return. Stack=[TK_OPTIONS option_list junk TK_EOC]
Parser(B) >> Input 'TK_NAMESPACE' in state 213
Parser(B) >> Reduce 28 [rexx_options ::= TK_OPTIONS option_list junk TK_EOC], pop back to state 0.
Parser(B) >> ... then shift 'rexx_options', go to state 1
Parser(B) >> Shift 'TK_NAMESPACE', go to state 111
Parser(B) >> Return. Stack=[rexx_options TK_NAMESPACE]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 111
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 323
Parser(B) >> Return. Stack=[rexx_options TK_NAMESPACE TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EOC' in state 323
Parser(B) >> Reduce 32 [literal ::= TK_VAR_SYMBOL], pop back to state 111.
Parser(B) >> ... then shift 'literal', go to state 88
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 417
Parser(B) >> Shift 'TK_EOC', go to state 222
Parser(B) >> Return. Stack=[rexx_options TK_NAMESPACE literal junk TK_EOC]
Parser(B) >> Input 'TK_IMPORT' in state 222
Parser(B) >> Reduce 35 [namespace_instruction ::= TK_NAMESPACE literal junk TK_EOC], pop back to state 1.
Parser(B) >> ... then shift 'namespace_instruction', go to state 215
Parser(B) >> Reduce 33 [namespace_list ::= namespace_instruction], pop back to state 1.
Parser(B) >> ... then shift 'namespace_list', go to state 2
Parser(B) >> Shift 'TK_IMPORT', go to state 109
Parser(B) >> Return. Stack=[rexx_options namespace_list TK_IMPORT]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 109
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 323
Parser(B) >> Return. Stack=[rexx_options namespace_list TK_IMPORT TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EOC' in state 323
Parser(B) >> Reduce 32 [literal ::= TK_VAR_SYMBOL], pop back to state 109.
Parser(B) >> ... then shift 'literal', go to state 108
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 415
Parser(B) >> Shift 'TK_EOC', go to state 218
Parser(B) >> Return. Stack=[rexx_options namespace_list TK_IMPORT literal junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 218
Parser(B) >> Reduce 37 [namespace_instruction ::= TK_IMPORT literal junk TK_EOC], pop back to state 2.
Parser(B) >> ... then shift 'namespace_instruction', go to state 223
Parser(B) >> Reduce 34 [namespace_list ::= namespace_list namespace_instruction], pop back to state 1.
Parser(B) >> ... then shift 'namespace_list', go to state 2
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 91
Parser(B) >> Return. Stack=[rexx_options namespace_list TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 91
Parser(B) >> Reduce 13 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 2.
Parser(B) >> ... then shift 'var_symbol', go to state 277
Parser(B) >> Shift 'TK_EQUAL', go to state 34
Parser(B) >> Return. Stack=[rexx_options namespace_list var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_INTEGER' in state 34
Parser(B) >> Shift 'TK_INTEGER', go to state 256
Parser(B) >> Return. Stack=[rexx_options namespace_list var_symbol TK_EQUAL TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 256
Parser(B) >> Reduce 200 [term ::= TK_INTEGER], pop back to state 34.
Parser(B) >> ... then shift 'term', go to state 255
Parser(B) >> Reduce 202 [bracket ::= term], pop back to state 34.
Parser(B) >> ... then shift 'bracket', go to state 253
Parser(B) >> Reduce 204 [prefix_expression ::= bracket], pop back to state 34.
Parser(B) >> ... then shift 'prefix_expression', go to state 249
Parser(B) >> Reduce 208 [power_expression ::= prefix_expression], pop back to state 34.
Parser(B) >> ... then shift 'power_expression', go to state 248
Parser(B) >> Reduce 210 [multiplication ::= power_expression], pop back to state 34.
Parser(B) >> ... then shift 'multiplication', go to state 268
Parser(B) >> Reduce 215 [addition ::= multiplication], pop back to state 34.
Parser(B) >> ... then shift 'addition', go to state 271
Parser(B) >> Reduce 230 [concatenation ::= addition], pop back to state 34.
Parser(B) >> ... then shift 'concatenation', go to state 62
Parser(B) >> Reduce 233 [comparison ::= concatenation], pop back to state 34.
Parser(B) >> ... then shift 'comparison', go to state 279
Parser(B) >> Reduce 246 [or_expression ::= comparison], pop back to state 34.
Parser(B) >> ... then shift 'or_expression', go to state 281
Parser(B) >> Reduce 248 [and_expression ::= or_expression], pop back to state 34.
Parser(B) >> ... then shift 'and_expression', go to state 303
Parser(B) >> Reduce 271 [expression ::= and_expression], pop back to state 34.
Parser(B) >> ... then shift 'expression', go to state 310
Parser(B) >> Reduce 60 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 2.
Parser(B) >> ... then shift 'assignment', go to state 401
Parser(B) >> Reduce 57 [single_instruction ::= assignment], pop back to state 2.
Parser(B) >> ... then shift 'single_instruction', go to state 116
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 433
Parser(B) >> Shift 'TK_EOC', go to state 210
Parser(B) >> Return. Stack=[rexx_options namespace_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 210
Parser(B) >> Reduce 48 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 2.
Parser(B) >> ... then shift 'labeled_instruction', go to state 202
Parser(B) >> Reduce 45 [instruction_list ::= labeled_instruction], pop back to state 2.
Parser(B) >> ... then shift 'instruction_list', go to state 11
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 91
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 91
Parser(B) >> Reduce 13 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 11.
Parser(B) >> ... then shift 'var_symbol', go to state 277
Parser(B) >> Shift 'TK_EQUAL', go to state 34
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_CLASS' in state 34
Parser(B) >> Shift 'TK_CLASS', go to state 231
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list var_symbol TK_EQUAL TK_CLASS]
Parser(B) >> Input 'TK_OPEN_SBRACKET' in state 231
Parser(B) >> Reduce 12 [class ::= TK_CLASS], pop back to state 34.
Parser(B) >> ... then shift 'class', go to state 126
Parser(B) >> Shift 'TK_OPEN_SBRACKET', go to state 20
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list var_symbol TK_EQUAL class TK_OPEN_SBRACKET]
Parser(B) >> Input 'TK_CLOSE_SBRACKET' in state 20
Parser(B) >> Reduce 191 [expression_list ::=].
Parser(B) >> ... then shift 'expression_list', go to state 409
Parser(B) >> Shift 'TK_CLOSE_SBRACKET', go to state 232
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list var_symbol TK_EQUAL class TK_OPEN_SBRACKET expression_list TK_CLOSE_SBRACKET]
Parser(B) >> Input 'TK_EOC' in state 232
Parser(B) >> Reduce 19 [array_parameters ::= TK_OPEN_SBRACKET expression_list TK_CLOSE_SBRACKET], pop back to state 126.
Parser(B) >> ... then shift 'array_parameters', go to state 261
Parser(B) >> Reduce 16 [var_symbol ::= class array_parameters], pop back to state 34.
Parser(B) >> ... then shift 'var_symbol', go to state 258
Parser(B) >> Reduce 198 [term ::= var_symbol], pop back to state 34.
Parser(B) >> ... then shift 'term', go to state 255
Parser(B) >> Reduce 202 [bracket ::= term], pop back to state 34.
Parser(B) >> ... then shift 'bracket', go to state 253
Parser(B) >> Reduce 204 [prefix_expression ::= bracket], pop back to state 34.
Parser(B) >> ... then shift 'prefix_expression', go to state 249
Parser(B) >> Reduce 208 [power_expression ::= prefix_expression], pop back to state 34.
Parser(B) >> ... then shift 'power_expression', go to state 248
Parser(B) >> Reduce 210 [multiplication ::= power_expression], pop back to state 34.
Parser(B) >> ... then shift 'multiplication', go to state 268
Parser(B) >> Reduce 215 [addition ::= multiplication], pop back to state 34.
Parser(B) >> ... then shift 'addition', go to state 271
Parser(B) >> Reduce 230 [concatenation ::= addition], pop back to state 34.
Parser(B) >> ... then shift 'concatenation', go to state 62
Parser(B) >> Reduce 233 [comparison ::= concatenation], pop back to state 34.
Parser(B) >> ... then shift 'comparison', go to state 279
Parser(B) >> Reduce 246 [or_expression ::= comparison], pop back to state 34.
Parser(B) >> ... then shift 'or_expression', go to state 281
Parser(B) >> Reduce 248 [and_expression ::= or_expression], pop back to state 34.
Parser(B) >> ... then shift 'and_expression', go to state 303
Parser(B) >> Reduce 271 [expression ::= and_expression], pop back to state 34.
Parser(B) >> ... then shift 'expression', go to state 310
Parser(B) >> Reduce 60 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 11.
Parser(B) >> ... then shift 'assignment', go to state 401
Parser(B) >> Reduce 57 [single_instruction ::= assignment], pop back to state 11.
Parser(B) >> ... then shift 'single_instruction', go to state 116
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 433
Parser(B) >> Shift 'TK_EOC', go to state 210
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_SAY' in state 210
Parser(B) >> Reduce 48 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 11.
Parser(B) >> ... then shift 'labeled_instruction', go to state 212
Parser(B) >> Reduce 46 [instruction_list ::= instruction_list labeled_instruction], pop back to state 2.
Parser(B) >> ... then shift 'instruction_list', go to state 11
Parser(B) >> Shift 'TK_SAY', go to state 22
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_SAY]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 22
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 91
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_SAY TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_OPEN_SBRACKET' in state 91
Parser(B) >> Shift 'TK_OPEN_SBRACKET', go to state 20
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_SAY TK_VAR_SYMBOL TK_OPEN_SBRACKET]
Parser(B) >> Input 'TK_INTEGER' in state 20
Parser(B) >> Shift 'TK_INTEGER', go to state 256
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_SAY TK_VAR_SYMBOL TK_OPEN_SBRACKET TK_INTEGER]
Parser(B) >> Input 'TK_CLOSE_SBRACKET' in state 256
Parser(B) >> Reduce 200 [term ::= TK_INTEGER], pop back to state 20.
Parser(B) >> ... then shift 'term', go to state 255
Parser(B) >> Reduce 202 [bracket ::= term], pop back to state 20.
Parser(B) >> ... then shift 'bracket', go to state 253
Parser(B) >> Reduce 204 [prefix_expression ::= bracket], pop back to state 20.
Parser(B) >> ... then shift 'prefix_expression', go to state 249
Parser(B) >> Reduce 208 [power_expression ::= prefix_expression], pop back to state 20.
Parser(B) >> ... then shift 'power_expression', go to state 248
Parser(B) >> Reduce 210 [multiplication ::= power_expression], pop back to state 20.
Parser(B) >> ... then shift 'multiplication', go to state 268
Parser(B) >> Reduce 215 [addition ::= multiplication], pop back to state 20.
Parser(B) >> ... then shift 'addition', go to state 271
Parser(B) >> Reduce 230 [concatenation ::= addition], pop back to state 20.
Parser(B) >> ... then shift 'concatenation', go to state 62
Parser(B) >> Reduce 233 [comparison ::= concatenation], pop back to state 20.
Parser(B) >> ... then shift 'comparison', go to state 279
Parser(B) >> Reduce 246 [or_expression ::= comparison], pop back to state 20.
Parser(B) >> ... then shift 'or_expression', go to state 281
Parser(B) >> Reduce 248 [and_expression ::= or_expression], pop back to state 20.
Parser(B) >> ... then shift 'and_expression', go to state 316
Parser(B) >> Reduce 274 [expression_in_list ::= and_expression], pop back to state 20.
Parser(B) >> ... then shift 'expression_in_list', go to state 319
Parser(B) >> Reduce 192 [expression_list ::= expression_in_list], pop back to state 20.
Parser(B) >> ... then shift 'expression_list', go to state 409
Parser(B) >> Shift 'TK_CLOSE_SBRACKET', go to state 232
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_SAY TK_VAR_SYMBOL TK_OPEN_SBRACKET expression_list TK_CLOSE_SBRACKET]
Parser(B) >> Input 'TK_EOC' in state 232
Parser(B) >> Reduce 19 [array_parameters ::= TK_OPEN_SBRACKET expression_list TK_CLOSE_SBRACKET], pop back to state 91.
Parser(B) >> ... then shift 'array_parameters', go to state 262
Parser(B) >> Reduce 15 [var_symbol ::= TK_VAR_SYMBOL array_parameters], pop back to state 22.
Parser(B) >> ... then shift 'var_symbol', go to state 258
Parser(B) >> Reduce 198 [term ::= var_symbol], pop back to state 22.
Parser(B) >> ... then shift 'term', go to state 255
Parser(B) >> Reduce 202 [bracket ::= term], pop back to state 22.
Parser(B) >> ... then shift 'bracket', go to state 253
Parser(B) >> Reduce 204 [prefix_expression ::= bracket], pop back to state 22.
Parser(B) >> ... then shift 'prefix_expression', go to state 249
Parser(B) >> Reduce 208 [power_expression ::= prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 248
Parser(B) >> Reduce 210 [multiplication ::= power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 268
Parser(B) >> Reduce 215 [addition ::= multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 271
Parser(B) >> Reduce 230 [concatenation ::= addition], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 62
Parser(B) >> Reduce 233 [comparison ::= concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 279
Parser(B) >> Reduce 246 [or_expression ::= comparison], pop back to state 22.
Parser(B) >> ... then shift 'or_expression', go to state 281
Parser(B) >> Reduce 248 [and_expression ::= or_expression], pop back to state 22.
Parser(B) >> ... then shift 'and_expression', go to state 303
Parser(B) >> Reduce 271 [expression ::= and_expression], pop back to state 22.
Parser(B) >> ... then shift 'expression', go to state 355
Parser(B) >> Reduce 184 [say ::= TK_SAY expression], pop back to state 11.
Parser(B) >> ... then shift 'say', go to state 389
Parser(B) >> Reduce 72 [keyword_instruction ::= say], pop back to state 11.
Parser(B) >> ... then shift 'keyword_instruction', go to state 399
Parser(B) >> Reduce 59 [single_instruction ::= keyword_instruction], pop back to state 11.
Parser(B) >> ... then shift 'single_instruction', go to state 116
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 433
Parser(B) >> Shift 'TK_EOC', go to state 210
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 210
Parser(B) >> Reduce 48 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 11.
Parser(B) >> ... then shift 'labeled_instruction', go to state 212
Parser(B) >> Reduce 46 [instruction_list ::= instruction_list labeled_instruction], pop back to state 2.
Parser(B) >> ... then shift 'instruction_list', go to state 11
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 91
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 91
Parser(B) >> Reduce 13 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 11.
Parser(B) >> ... then shift 'var_symbol', go to state 277
Parser(B) >> Shift 'TK_EQUAL', go to state 34
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 34
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 91
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list var_symbol TK_EQUAL TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EOC' in state 91
Parser(B) >> Reduce 13 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 34.
Parser(B) >> ... then shift 'var_symbol', go to state 258
Parser(B) >> Reduce 198 [term ::= var_symbol], pop back to state 34.
Parser(B) >> ... then shift 'term', go to state 255
Parser(B) >> Reduce 202 [bracket ::= term], pop back to state 34.
Parser(B) >> ... then shift 'bracket', go to state 253
Parser(B) >> Reduce 204 [prefix_expression ::= bracket], pop back to state 34.
Parser(B) >> ... then shift 'prefix_expression', go to state 249
Parser(B) >> Reduce 208 [power_expression ::= prefix_expression], pop back to state 34.
Parser(B) >> ... then shift 'power_expression', go to state 248
Parser(B) >> Reduce 210 [multiplication ::= power_expression], pop back to state 34.
Parser(B) >> ... then shift 'multiplication', go to state 268
Parser(B) >> Reduce 215 [addition ::= multiplication], pop back to state 34.
Parser(B) >> ... then shift 'addition', go to state 271
Parser(B) >> Reduce 230 [concatenation ::= addition], pop back to state 34.
Parser(B) >> ... then shift 'concatenation', go to state 62
Parser(B) >> Reduce 233 [comparison ::= concatenation], pop back to state 34.
Parser(B) >> ... then shift 'comparison', go to state 279
Parser(B) >> Reduce 246 [or_expression ::= comparison], pop back to state 34.
Parser(B) >> ... then shift 'or_expression', go to state 281
Parser(B) >> Reduce 248 [and_expression ::= or_expression], pop back to state 34.
Parser(B) >> ... then shift 'and_expression', go to state 303
Parser(B) >> Reduce 271 [expression ::= and_expression], pop back to state 34.
Parser(B) >> ... then shift 'expression', go to state 310
Parser(B) >> Reduce 60 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 11.
Parser(B) >> ... then shift 'assignment', go to state 401
Parser(B) >> Reduce 57 [single_instruction ::= assignment], pop back to state 11.
Parser(B) >> ... then shift 'single_instruction', go to state 116
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 433
Parser(B) >> Shift 'TK_EOC', go to state 210
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 210
Parser(B) >> Reduce 48 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 11.
Parser(B) >> ... then shift 'labeled_instruction', go to state 212
Parser(B) >> Reduce 46 [instruction_list ::= instruction_list labeled_instruction], pop back to state 2.
Parser(B) >> ... then shift 'instruction_list', go to state 11
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 91
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 91
Parser(B) >> Reduce 13 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 11.
Parser(B) >> ... then shift 'var_symbol', go to state 277
Parser(B) >> Shift 'TK_EQUAL', go to state 34
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 34
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 91
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list var_symbol TK_EQUAL TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_OPEN_SBRACKET' in state 91
Parser(B) >> Shift 'TK_OPEN_SBRACKET', go to state 20
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list var_symbol TK_EQUAL TK_VAR_SYMBOL TK_OPEN_SBRACKET]
Parser(B) >> Input 'TK_INTEGER' in state 20
Parser(B) >> Shift 'TK_INTEGER', go to state 256
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list var_symbol TK_EQUAL TK_VAR_SYMBOL TK_OPEN_SBRACKET TK_INTEGER]
Parser(B) >> Input 'TK_CLOSE_SBRACKET' in state 256
Parser(B) >> Reduce 200 [term ::= TK_INTEGER], pop back to state 20.
Parser(B) >> ... then shift 'term', go to state 255
Parser(B) >> Reduce 202 [bracket ::= term], pop back to state 20.
Parser(B) >> ... then shift 'bracket', go to state 253
Parser(B) >> Reduce 204 [prefix_expression ::= bracket], pop back to state 20.
Parser(B) >> ... then shift 'prefix_expression', go to state 249
Parser(B) >> Reduce 208 [power_expression ::= prefix_expression], pop back to state 20.
Parser(B) >> ... then shift 'power_expression', go to state 248
Parser(B) >> Reduce 210 [multiplication ::= power_expression], pop back to state 20.
Parser(B) >> ... then shift 'multiplication', go to state 268
Parser(B) >> Reduce 215 [addition ::= multiplication], pop back to state 20.
Parser(B) >> ... then shift 'addition', go to state 271
Parser(B) >> Reduce 230 [concatenation ::= addition], pop back to state 20.
Parser(B) >> ... then shift 'concatenation', go to state 62
Parser(B) >> Reduce 233 [comparison ::= concatenation], pop back to state 20.
Parser(B) >> ... then shift 'comparison', go to state 279
Parser(B) >> Reduce 246 [or_expression ::= comparison], pop back to state 20.
Parser(B) >> ... then shift 'or_expression', go to state 281
Parser(B) >> Reduce 248 [and_expression ::= or_expression], pop back to state 20.
Parser(B) >> ... then shift 'and_expression', go to state 316
Parser(B) >> Reduce 274 [expression_in_list ::= and_expression], pop back to state 20.
Parser(B) >> ... then shift 'expression_in_list', go to state 319
Parser(B) >> Reduce 192 [expression_list ::= expression_in_list], pop back to state 20.
Parser(B) >> ... then shift 'expression_list', go to state 409
Parser(B) >> Shift 'TK_CLOSE_SBRACKET', go to state 232
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list var_symbol TK_EQUAL TK_VAR_SYMBOL TK_OPEN_SBRACKET expression_list TK_CLOSE_SBRACKET]
Parser(B) >> Input 'TK_EOC' in state 232
Parser(B) >> Reduce 19 [array_parameters ::= TK_OPEN_SBRACKET expression_list TK_CLOSE_SBRACKET], pop back to state 91.
Parser(B) >> ... then shift 'array_parameters', go to state 262
Parser(B) >> Reduce 15 [var_symbol ::= TK_VAR_SYMBOL array_parameters], pop back to state 34.
Parser(B) >> ... then shift 'var_symbol', go to state 258
Parser(B) >> Reduce 198 [term ::= var_symbol], pop back to state 34.
Parser(B) >> ... then shift 'term', go to state 255
Parser(B) >> Reduce 202 [bracket ::= term], pop back to state 34.
Parser(B) >> ... then shift 'bracket', go to state 253
Parser(B) >> Reduce 204 [prefix_expression ::= bracket], pop back to state 34.
Parser(B) >> ... then shift 'prefix_expression', go to state 249
Parser(B) >> Reduce 208 [power_expression ::= prefix_expression], pop back to state 34.
Parser(B) >> ... then shift 'power_expression', go to state 248
Parser(B) >> Reduce 210 [multiplication ::= power_expression], pop back to state 34.
Parser(B) >> ... then shift 'multiplication', go to state 268
Parser(B) >> Reduce 215 [addition ::= multiplication], pop back to state 34.
Parser(B) >> ... then shift 'addition', go to state 271
Parser(B) >> Reduce 230 [concatenation ::= addition], pop back to state 34.
Parser(B) >> ... then shift 'concatenation', go to state 62
Parser(B) >> Reduce 233 [comparison ::= concatenation], pop back to state 34.
Parser(B) >> ... then shift 'comparison', go to state 279
Parser(B) >> Reduce 246 [or_expression ::= comparison], pop back to state 34.
Parser(B) >> ... then shift 'or_expression', go to state 281
Parser(B) >> Reduce 248 [and_expression ::= or_expression], pop back to state 34.
Parser(B) >> ... then shift 'and_expression', go to state 303
Parser(B) >> Reduce 271 [expression ::= and_expression], pop back to state 34.
Parser(B) >> ... then shift 'expression', go to state 310
Parser(B) >> Reduce 60 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 11.
Parser(B) >> ... then shift 'assignment', go to state 401
Parser(B) >> Reduce 57 [single_instruction ::= assignment], pop back to state 11.
Parser(B) >> ... then shift 'single_instruction', go to state 116
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 433
Parser(B) >> Shift 'TK_EOC', go to state 210
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 210
Parser(B) >> Reduce 48 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 11.
Parser(B) >> ... then shift 'labeled_instruction', go to state 212
Parser(B) >> Reduce 46 [instruction_list ::= instruction_list labeled_instruction], pop back to state 2.
Parser(B) >> ... then shift 'instruction_list', go to state 11
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 91
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 91
Parser(B) >> Reduce 13 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 11.
Parser(B) >> ... then shift 'var_symbol', go to state 277
Parser(B) >> Shift 'TK_EQUAL', go to state 34
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 34
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 91
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list var_symbol TK_EQUAL TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_OPEN_SBRACKET' in state 91
Parser(B) >> Shift 'TK_OPEN_SBRACKET', go to state 20
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list var_symbol TK_EQUAL TK_VAR_SYMBOL TK_OPEN_SBRACKET]
Parser(B) >> Input 'TK_CLOSE_SBRACKET' in state 20
Parser(B) >> Reduce 191 [expression_list ::=].
Parser(B) >> ... then shift 'expression_list', go to state 409
Parser(B) >> Shift 'TK_CLOSE_SBRACKET', go to state 232
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list var_symbol TK_EQUAL TK_VAR_SYMBOL TK_OPEN_SBRACKET expression_list TK_CLOSE_SBRACKET]
Parser(B) >> Input 'TK_EOC' in state 232
Parser(B) >> Reduce 19 [array_parameters ::= TK_OPEN_SBRACKET expression_list TK_CLOSE_SBRACKET], pop back to state 91.
Parser(B) >> ... then shift 'array_parameters', go to state 262
Parser(B) >> Reduce 15 [var_symbol ::= TK_VAR_SYMBOL array_parameters], pop back to state 34.
Parser(B) >> ... then shift 'var_symbol', go to state 258
Parser(B) >> Reduce 198 [term ::= var_symbol], pop back to state 34.
Parser(B) >> ... then shift 'term', go to state 255
Parser(B) >> Reduce 202 [bracket ::= term], pop back to state 34.
Parser(B) >> ... then shift 'bracket', go to state 253
Parser(B) >> Reduce 204 [prefix_expression ::= bracket], pop back to state 34.
Parser(B) >> ... then shift 'prefix_expression', go to state 249
Parser(B) >> Reduce 208 [power_expression ::= prefix_expression], pop back to state 34.
Parser(B) >> ... then shift 'power_expression', go to state 248
Parser(B) >> Reduce 210 [multiplication ::= power_expression], pop back to state 34.
Parser(B) >> ... then shift 'multiplication', go to state 268
Parser(B) >> Reduce 215 [addition ::= multiplication], pop back to state 34.
Parser(B) >> ... then shift 'addition', go to state 271
Parser(B) >> Reduce 230 [concatenation ::= addition], pop back to state 34.
Parser(B) >> ... then shift 'concatenation', go to state 62
Parser(B) >> Reduce 233 [comparison ::= concatenation], pop back to state 34.
Parser(B) >> ... then shift 'comparison', go to state 279
Parser(B) >> Reduce 246 [or_expression ::= comparison], pop back to state 34.
Parser(B) >> ... then shift 'or_expression', go to state 281
Parser(B) >> Reduce 248 [and_expression ::= or_expression], pop back to state 34.
Parser(B) >> ... then shift 'and_expression', go to state 303
Parser(B) >> Reduce 271 [expression ::= and_expression], pop back to state 34.
Parser(B) >> ... then shift 'expression', go to state 310
Parser(B) >> Reduce 60 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 11.
Parser(B) >> ... then shift 'assignment', go to state 401
Parser(B) >> Reduce 57 [single_instruction ::= assignment], pop back to state 11.
Parser(B) >> ... then shift 'single_instruction', go to state 116
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 433
Parser(B) >> Shift 'TK_EOC', go to state 210
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 210
Parser(B) >> Reduce 48 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 11.
Parser(B) >> ... then shift 'labeled_instruction', go to state 212
Parser(B) >> Reduce 46 [instruction_list ::= instruction_list labeled_instruction], pop back to state 2.
Parser(B) >> ... then shift 'instruction_list', go to state 11
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 91
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_OPEN_SBRACKET' in state 91
Parser(B) >> Shift 'TK_OPEN_SBRACKET', go to state 20
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_VAR_SYMBOL TK_OPEN_SBRACKET]
Parser(B) >> Input 'TK_INTEGER' in state 20
Parser(B) >> Shift 'TK_INTEGER', go to state 256
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_VAR_SYMBOL TK_OPEN_SBRACKET TK_INTEGER]
Parser(B) >> Input 'TK_CLOSE_SBRACKET' in state 256
Parser(B) >> Reduce 200 [term ::= TK_INTEGER], pop back to state 20.
Parser(B) >> ... then shift 'term', go to state 255
Parser(B) >> Reduce 202 [bracket ::= term], pop back to state 20.
Parser(B) >> ... then shift 'bracket', go to state 253
Parser(B) >> Reduce 204 [prefix_expression ::= bracket], pop back to state 20.
Parser(B) >> ... then shift 'prefix_expression', go to state 249
Parser(B) >> Reduce 208 [power_expression ::= prefix_expression], pop back to state 20.
Parser(B) >> ... then shift 'power_expression', go to state 248
Parser(B) >> Reduce 210 [multiplication ::= power_expression], pop back to state 20.
Parser(B) >> ... then shift 'multiplication', go to state 268
Parser(B) >> Reduce 215 [addition ::= multiplication], pop back to state 20.
Parser(B) >> ... then shift 'addition', go to state 271
Parser(B) >> Reduce 230 [concatenation ::= addition], pop back to state 20.
Parser(B) >> ... then shift 'concatenation', go to state 62
Parser(B) >> Reduce 233 [comparison ::= concatenation], pop back to state 20.
Parser(B) >> ... then shift 'comparison', go to state 279
Parser(B) >> Reduce 246 [or_expression ::= comparison], pop back to state 20.
Parser(B) >> ... then shift 'or_expression', go to state 281
Parser(B) >> Reduce 248 [and_expression ::= or_expression], pop back to state 20.
Parser(B) >> ... then shift 'and_expression', go to state 316
Parser(B) >> Reduce 274 [expression_in_list ::= and_expression], pop back to state 20.
Parser(B) >> ... then shift 'expression_in_list', go to state 319
Parser(B) >> Reduce 192 [expression_list ::= expression_in_list], pop back to state 20.
Parser(B) >> ... then shift 'expression_list', go to state 409
Parser(B) >> Shift 'TK_CLOSE_SBRACKET', go to state 232
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_VAR_SYMBOL TK_OPEN_SBRACKET expression_list TK_CLOSE_SBRACKET]
Parser(B) >> Input 'TK_EQUAL' in state 232
Parser(B) >> Reduce 19 [array_parameters ::= TK_OPEN_SBRACKET expression_list TK_CLOSE_SBRACKET], pop back to state 91.
Parser(B) >> ... then shift 'array_parameters', go to state 262
Parser(B) >> Reduce 15 [var_symbol ::= TK_VAR_SYMBOL array_parameters], pop back to state 11.
Parser(B) >> ... then shift 'var_symbol', go to state 277
Parser(B) >> Shift 'TK_EQUAL', go to state 34
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 34
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 91
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list var_symbol TK_EQUAL TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EOC' in state 91
Parser(B) >> Reduce 13 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 34.
Parser(B) >> ... then shift 'var_symbol', go to state 258
Parser(B) >> Reduce 198 [term ::= var_symbol], pop back to state 34.
Parser(B) >> ... then shift 'term', go to state 255
Parser(B) >> Reduce 202 [bracket ::= term], pop back to state 34.
Parser(B) >> ... then shift 'bracket', go to state 253
Parser(B) >> Reduce 204 [prefix_expression ::= bracket], pop back to state 34.
Parser(B) >> ... then shift 'prefix_expression', go to state 249
Parser(B) >> Reduce 208 [power_expression ::= prefix_expression], pop back to state 34.
Parser(B) >> ... then shift 'power_expression', go to state 248
Parser(B) >> Reduce 210 [multiplication ::= power_expression], pop back to state 34.
Parser(B) >> ... then shift 'multiplication', go to state 268
Parser(B) >> Reduce 215 [addition ::= multiplication], pop back to state 34.
Parser(B) >> ... then shift 'addition', go to state 271
Parser(B) >> Reduce 230 [concatenation ::= addition], pop back to state 34.
Parser(B) >> ... then shift 'concatenation', go to state 62
Parser(B) >> Reduce 233 [comparison ::= concatenation], pop back to state 34.
Parser(B) >> ... then shift 'comparison', go to state 279
Parser(B) >> Reduce 246 [or_expression ::= comparison], pop back to state 34.
Parser(B) >> ... then shift 'or_expression', go to state 281
Parser(B) >> Reduce 248 [and_expression ::= or_expression], pop back to state 34.
Parser(B) >> ... then shift 'and_expression', go to state 303
Parser(B) >> Reduce 271 [expression ::= and_expression], pop back to state 34.
Parser(B) >> ... then shift 'expression', go to state 310
Parser(B) >> Reduce 60 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 11.
Parser(B) >> ... then shift 'assignment', go to state 401
Parser(B) >> Reduce 57 [single_instruction ::= assignment], pop back to state 11.
Parser(B) >> ... then shift 'single_instruction', go to state 116
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 433
Parser(B) >> Shift 'TK_EOC', go to state 210
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_EOS' in state 210
Parser(B) >> Reduce 48 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 11.
Parser(B) >> ... then shift 'labeled_instruction', go to state 212
Parser(B) >> Reduce 46 [instruction_list ::= instruction_list labeled_instruction], pop back to state 2.
Parser(B) >> ... then shift 'instruction_list', go to state 11
Parser(B) >> Shift 'TK_EOS', go to state 435
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_EOS]
Parser(B) >> Input '$' in state 435
Parser(B) >> Reduce 0 [program ::= rexx_options namespace_list instruction_list TK_EOS], pop back to state 0.
Parser(B) >> ... then shift 'program', pending reduce -2
Parser(B) >> Accept!
