Options parser >> Input 'TK_OPTIONS' in state 0
Options parser >> Shift 'TK_OPTIONS', go to state 1
Options parser >> Return. Stack=[TK_OPTIONS]
Options parser >> Input 'TK_LEVELB' in state 1
Options parser >> Shift 'TK_LEVELB', go to state 16
Options parser >> Return. Stack=[TK_OPTIONS TK_LEVELB]
Options parser >> Input 'TK_EOC' in state 16
Options parser >> Reduce 4 [option ::= TK_LEVELB], pop back to state 1.
Options parser >> ... then shift 'option', go to state 4
Options parser >> Reduce 18 [option_list ::= option] without external action, pop back to state 1.
Options parser >> ... then shift 'option_list', go to state 2
Options parser >> Shift 'TK_EOC', go to state 23
Options parser >> Return. Stack=[TK_OPTIONS option_list TK_EOC]
Options parser >> Input 'TK_SYMBOL' in state 23
Options parser >> WILDCARD TK_SYMBOL => ANYTHING
Options parser >> Reduce 2 [rexx_options ::= TK_OPTIONS option_list TK_EOC], pop back to state 0.
Options parser >> ... then shift 'rexx_options', go to state 3
Options parser >> WILDCARD TK_SYMBOL => ANYTHING
Options parser >> Shift 'TK_SYMBOL', go to state 20
Options parser >> Return. Stack=[rexx_options TK_SYMBOL]
Options parser >> Popping TK_SYMBOL
Options parser >> Popping rexx_options
Parser(B) >> Input 'TK_OPTIONS' in state 0
Parser(B) >> Shift 'TK_OPTIONS', go to state 81
Parser(B) >> Return. Stack=[TK_OPTIONS]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 81
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 301
Parser(B) >> Return. Stack=[TK_OPTIONS TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EOC' in state 301
Parser(B) >> Reduce 18 [option ::= TK_VAR_SYMBOL], pop back to state 81.
Parser(B) >> ... then shift 'option', go to state 300
Parser(B) >> Reduce 16 [option_list ::= option], pop back to state 81.
Parser(B) >> ... then shift 'option_list', go to state 90
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 130
Parser(B) >> Shift 'TK_EOC', go to state 195
Parser(B) >> Return. Stack=[TK_OPTIONS option_list junk TK_EOC]
Parser(B) >> Input 'TK_NAMESPACE' in state 195
Parser(B) >> Reduce 15 [rexx_options ::= TK_OPTIONS option_list junk TK_EOC], pop back to state 0.
Parser(B) >> ... then shift 'rexx_options', go to state 1
Parser(B) >> Shift 'TK_NAMESPACE', go to state 92
Parser(B) >> Return. Stack=[rexx_options TK_NAMESPACE]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 92
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 290
Parser(B) >> Return. Stack=[rexx_options TK_NAMESPACE TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EXPOSE' in state 290
Parser(B) >> Reduce 20 [literal ::= TK_VAR_SYMBOL], pop back to state 92.
Parser(B) >> ... then shift 'literal', go to state 83
Parser(B) >> Shift 'TK_EXPOSE', go to state 104
Parser(B) >> Return. Stack=[rexx_options TK_NAMESPACE literal TK_EXPOSE]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 104
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 290
Parser(B) >> Return. Stack=[rexx_options TK_NAMESPACE literal TK_EXPOSE TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 290
Parser(B) >> Reduce 20 [literal ::= TK_VAR_SYMBOL], pop back to state 104.
Parser(B) >> ... then shift 'literal', go to state 293
Parser(B) >> Reduce 31 [expose_list ::= literal], pop back to state 104.
Parser(B) >> ... then shift 'expose_list', go to state 115
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 290
Parser(B) >> Return. Stack=[rexx_options TK_NAMESPACE literal TK_EXPOSE expose_list TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 290
Parser(B) >> Reduce 20 [literal ::= TK_VAR_SYMBOL], pop back to state 115.
Parser(B) >> ... then shift 'literal', go to state 294
Parser(B) >> Reduce 32 [expose_list ::= expose_list literal], pop back to state 104.
Parser(B) >> ... then shift 'expose_list', go to state 115
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 290
Parser(B) >> Return. Stack=[rexx_options TK_NAMESPACE literal TK_EXPOSE expose_list TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EOC' in state 290
Parser(B) >> Reduce 20 [literal ::= TK_VAR_SYMBOL], pop back to state 115.
Parser(B) >> ... then shift 'literal', go to state 294
Parser(B) >> Reduce 32 [expose_list ::= expose_list literal], pop back to state 104.
Parser(B) >> ... then shift 'expose_list', go to state 115
Parser(B) >> Reduce 30 [expose ::= TK_EXPOSE expose_list], pop back to state 83.
Parser(B) >> ... then shift 'expose', go to state 98
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 390
Parser(B) >> Shift 'TK_EOC', go to state 203
Parser(B) >> Return. Stack=[rexx_options TK_NAMESPACE literal expose junk TK_EOC]
Parser(B) >> Input 'TK_IMPORT' in state 203
Parser(B) >> Reduce 24 [namespace_instruction ::= TK_NAMESPACE literal expose junk TK_EOC], pop back to state 1.
Parser(B) >> ... then shift 'namespace_instruction', go to state 197
Parser(B) >> Reduce 21 [namespace_list ::= namespace_instruction], pop back to state 1.
Parser(B) >> ... then shift 'namespace_list', go to state 2
Parser(B) >> Shift 'TK_IMPORT', go to state 91
Parser(B) >> Return. Stack=[rexx_options namespace_list TK_IMPORT]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 91
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 290
Parser(B) >> Return. Stack=[rexx_options namespace_list TK_IMPORT TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EOC' in state 290
Parser(B) >> Reduce 20 [literal ::= TK_VAR_SYMBOL], pop back to state 91.
Parser(B) >> ... then shift 'literal', go to state 97
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 389
Parser(B) >> Shift 'TK_EOC', go to state 200
Parser(B) >> Return. Stack=[rexx_options namespace_list TK_IMPORT literal junk TK_EOC]
Parser(B) >> Input 'TK_SAY' in state 200
Parser(B) >> Reduce 25 [namespace_instruction ::= TK_IMPORT literal junk TK_EOC], pop back to state 2.
Parser(B) >> ... then shift 'namespace_instruction', go to state 205
Parser(B) >> Reduce 22 [namespace_list ::= namespace_list namespace_instruction], pop back to state 1.
Parser(B) >> ... then shift 'namespace_list', go to state 2
Parser(B) >> Shift 'TK_SAY', go to state 22
Parser(B) >> Return. Stack=[rexx_options namespace_list TK_SAY]
Parser(B) >> Input 'TK_STRING' in state 22
Parser(B) >> Shift 'TK_STRING', go to state 111
Parser(B) >> Return. Stack=[rexx_options namespace_list TK_SAY TK_STRING]
Parser(B) >> Input 'TK_EOC' in state 111
Parser(B) >> Reduce 179 [term ::= TK_STRING], pop back to state 22.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 22.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 22.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 22.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 22.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 22.
Parser(B) >> ... then shift 'expression', go to state 331
Parser(B) >> Reduce 160 [say ::= TK_SAY expression], pop back to state 2.
Parser(B) >> ... then shift 'say', go to state 365
Parser(B) >> Reduce 60 [keyword_instruction ::= say], pop back to state 2.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 2.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options namespace_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 2.
Parser(B) >> ... then shift 'labeled_instruction', go to state 184
Parser(B) >> Reduce 33 [instruction_list ::= labeled_instruction], pop back to state 2.
Parser(B) >> ... then shift 'instruction_list', go to state 11
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 11.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_INTEGER' in state 33
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list var_symbol TK_EQUAL TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 11.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 11.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 11.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 2.
Parser(B) >> ... then shift 'instruction_list', go to state 11
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 11.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 33
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list var_symbol TK_EQUAL TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_PLUS' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 33.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Shift 'TK_PLUS', go to state 64
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list var_symbol TK_EQUAL addition TK_PLUS]
Parser(B) >> Input 'TK_INTEGER' in state 64
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list var_symbol TK_EQUAL addition TK_PLUS TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 64.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 64.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 64.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 64.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 64.
Parser(B) >> ... then shift 'multiplication', go to state 240
Parser(B) >> Reduce 194 [addition ::= addition TK_PLUS multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 11.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 11.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_SAY' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 11.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 2.
Parser(B) >> ... then shift 'instruction_list', go to state 11
Parser(B) >> Shift 'TK_SAY', go to state 22
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_SAY]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 22
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_SAY TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EOC' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 22.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 22.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 22.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 22.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 22.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 22.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 22.
Parser(B) >> ... then shift 'expression', go to state 331
Parser(B) >> Reduce 160 [say ::= TK_SAY expression], pop back to state 11.
Parser(B) >> ... then shift 'say', go to state 365
Parser(B) >> Reduce 60 [keyword_instruction ::= say], pop back to state 11.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 11.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_SAY' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 11.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 2.
Parser(B) >> ... then shift 'instruction_list', go to state 11
Parser(B) >> Shift 'TK_SAY', go to state 22
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_SAY]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 22
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_SAY TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_OPEN_BRACKET' in state 112
Parser(B) >> Shift 'TK_OPEN_BRACKET', go to state 21
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_SAY TK_VAR_SYMBOL TK_OPEN_BRACKET]
Parser(B) >> Input 'TK_STRING' in state 21
Parser(B) >> Shift 'TK_STRING', go to state 111
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_SAY TK_VAR_SYMBOL TK_OPEN_BRACKET TK_STRING]
Parser(B) >> Input 'TK_COMMA' in state 111
Parser(B) >> Reduce 179 [term ::= TK_STRING], pop back to state 21.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 21.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 21.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 21.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 21.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 21.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 21.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 21.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 21.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 21.
Parser(B) >> ... then shift 'and_expression', go to state 292
Parser(B) >> Reduce 252 [expression_in_list ::= and_expression], pop back to state 21.
Parser(B) >> ... then shift 'expression_in_list', go to state 299
Parser(B) >> Reduce 169 [expression_list ::= expression_in_list], pop back to state 21.
Parser(B) >> ... then shift 'expression_list', go to state 383
Parser(B) >> Shift 'TK_COMMA', go to state 24
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_SAY TK_VAR_SYMBOL TK_OPEN_BRACKET expression_list TK_COMMA]
Parser(B) >> Input 'TK_INTEGER' in state 24
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_SAY TK_VAR_SYMBOL TK_OPEN_BRACKET expression_list TK_COMMA TK_INTEGER]
Parser(B) >> Input 'TK_CLOSE_BRACKET' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 24.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 24.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 24.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 24.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 24.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 24.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 24.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 24.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 24.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 24.
Parser(B) >> ... then shift 'and_expression', go to state 292
Parser(B) >> Reduce 252 [expression_in_list ::= and_expression], pop back to state 24.
Parser(B) >> ... then shift 'expression_in_list', go to state 298
Parser(B) >> Reduce 170 [expression_list ::= expression_list TK_COMMA expression_in_list], pop back to state 21.
Parser(B) >> ... then shift 'expression_list', go to state 383
Parser(B) >> Shift 'TK_CLOSE_BRACKET', go to state 207
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_SAY TK_VAR_SYMBOL TK_OPEN_BRACKET expression_list TK_CLOSE_BRACKET]
Parser(B) >> Input 'TK_EOC' in state 207
Parser(B) >> Reduce 175 [function_parameters ::= TK_OPEN_BRACKET expression_list TK_CLOSE_BRACKET], pop back to state 112.
Parser(B) >> ... then shift 'function_parameters', go to state 235
Parser(B) >> Reduce 172 [term ::= TK_VAR_SYMBOL function_parameters], pop back to state 22.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 22.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 22.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 22.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 22.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 22.
Parser(B) >> ... then shift 'expression', go to state 331
Parser(B) >> Reduce 160 [say ::= TK_SAY expression], pop back to state 11.
Parser(B) >> ... then shift 'say', go to state 365
Parser(B) >> Reduce 60 [keyword_instruction ::= say], pop back to state 11.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 11.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_SAY' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 11.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 2.
Parser(B) >> ... then shift 'instruction_list', go to state 11
Parser(B) >> Shift 'TK_SAY', go to state 22
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_SAY]
Parser(B) >> Input 'TK_STRING' in state 22
Parser(B) >> Shift 'TK_STRING', go to state 111
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_SAY TK_STRING]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 111
Parser(B) >> Reduce 179 [term ::= TK_STRING], pop back to state 22.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 22.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 22.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_SAY concatenation TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EOC' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 61.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 61.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 61.
Parser(B) >> ... then shift 'bracket', go to state 216
Parser(B) >> Reduce 196 [prefix_expression_c ::= bracket], pop back to state 61.
Parser(B) >> ... then shift 'prefix_expression_c', go to state 214
Parser(B) >> Reduce 198 [power_expression_c ::= prefix_expression_c], pop back to state 61.
Parser(B) >> ... then shift 'power_expression_c', go to state 213
Parser(B) >> Reduce 200 [multiplication_c ::= power_expression_c], pop back to state 61.
Parser(B) >> ... then shift 'multiplication_c', go to state 238
Parser(B) >> Reduce 205 [addition_c ::= multiplication_c], pop back to state 61.
Parser(B) >> ... then shift 'addition_c', go to state 244
Parser(B) >> Reduce 210 [concatenation ::= concatenation addition_c], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 22.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 22.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 22.
Parser(B) >> ... then shift 'expression', go to state 331
Parser(B) >> Reduce 160 [say ::= TK_SAY expression], pop back to state 11.
Parser(B) >> ... then shift 'say', go to state 365
Parser(B) >> Reduce 60 [keyword_instruction ::= say], pop back to state 11.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 11.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_CALL' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 11.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 2.
Parser(B) >> ... then shift 'instruction_list', go to state 11
Parser(B) >> Shift 'TK_CALL', go to state 116
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_CALL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 116
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 248
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_CALL TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EOC' in state 248
Parser(B) >> Reduce 163 [function_name ::= TK_VAR_SYMBOL], pop back to state 116.
Parser(B) >> ... then shift 'function_name', go to state 18
Parser(B) >> Reduce 168 [expression_list ::=].
Parser(B) >> ... then shift 'expression_list', go to state 304
Parser(B) >> Reduce 166 [call ::= TK_CALL function_name expression_list], pop back to state 11.
Parser(B) >> ... then shift 'call', go to state 371
Parser(B) >> Reduce 54 [keyword_instruction ::= call], pop back to state 11.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 11.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_SAY' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 11.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 2.
Parser(B) >> ... then shift 'instruction_list', go to state 11
Parser(B) >> Shift 'TK_SAY', go to state 22
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_SAY]
Parser(B) >> Input 'TK_STRING' in state 22
Parser(B) >> Shift 'TK_STRING', go to state 111
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_SAY TK_STRING]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 111
Parser(B) >> Reduce 179 [term ::= TK_STRING], pop back to state 22.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 22.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 22.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_SAY concatenation TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EOC' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 61.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 61.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 61.
Parser(B) >> ... then shift 'bracket', go to state 216
Parser(B) >> Reduce 196 [prefix_expression_c ::= bracket], pop back to state 61.
Parser(B) >> ... then shift 'prefix_expression_c', go to state 214
Parser(B) >> Reduce 198 [power_expression_c ::= prefix_expression_c], pop back to state 61.
Parser(B) >> ... then shift 'power_expression_c', go to state 213
Parser(B) >> Reduce 200 [multiplication_c ::= power_expression_c], pop back to state 61.
Parser(B) >> ... then shift 'multiplication_c', go to state 238
Parser(B) >> Reduce 205 [addition_c ::= multiplication_c], pop back to state 61.
Parser(B) >> ... then shift 'addition_c', go to state 244
Parser(B) >> Reduce 210 [concatenation ::= concatenation addition_c], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 22.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 22.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 22.
Parser(B) >> ... then shift 'expression', go to state 331
Parser(B) >> Reduce 160 [say ::= TK_SAY expression], pop back to state 11.
Parser(B) >> ... then shift 'say', go to state 365
Parser(B) >> Reduce 60 [keyword_instruction ::= say], pop back to state 11.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 11.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_LABEL' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 11.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 2.
Parser(B) >> ... then shift 'instruction_list', go to state 11
Parser(B) >> Shift 'TK_LABEL', go to state 173
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_LABEL]
Parser(B) >> Input 'TK_PROCEDURE' in state 173
Parser(B) >> Shift 'TK_PROCEDURE', go to state 319
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_LABEL TK_PROCEDURE]
Parser(B) >> Input 'TK_EOC' in state 319
Parser(B) >> Reduce 118 [procedure ::= TK_LABEL TK_PROCEDURE], pop back to state 11.
Parser(B) >> ... then shift 'procedure', go to state 367
Parser(B) >> Reduce 58 [keyword_instruction ::= procedure], pop back to state 11.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 11.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 11.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 2.
Parser(B) >> ... then shift 'instruction_list', go to state 11
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 11.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_INTEGER' in state 33
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list var_symbol TK_EQUAL TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 11.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 11.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_SAY' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 11.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 2.
Parser(B) >> ... then shift 'instruction_list', go to state 11
Parser(B) >> Shift 'TK_SAY', go to state 22
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_SAY]
Parser(B) >> Input 'TK_STRING' in state 22
Parser(B) >> Shift 'TK_STRING', go to state 111
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_SAY TK_STRING]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 111
Parser(B) >> Reduce 179 [term ::= TK_STRING], pop back to state 22.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 22.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 22.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_SAY concatenation TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EOC' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 61.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 61.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 61.
Parser(B) >> ... then shift 'bracket', go to state 216
Parser(B) >> Reduce 196 [prefix_expression_c ::= bracket], pop back to state 61.
Parser(B) >> ... then shift 'prefix_expression_c', go to state 214
Parser(B) >> Reduce 198 [power_expression_c ::= prefix_expression_c], pop back to state 61.
Parser(B) >> ... then shift 'power_expression_c', go to state 213
Parser(B) >> Reduce 200 [multiplication_c ::= power_expression_c], pop back to state 61.
Parser(B) >> ... then shift 'multiplication_c', go to state 238
Parser(B) >> Reduce 205 [addition_c ::= multiplication_c], pop back to state 61.
Parser(B) >> ... then shift 'addition_c', go to state 244
Parser(B) >> Reduce 210 [concatenation ::= concatenation addition_c], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 22.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 22.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 22.
Parser(B) >> ... then shift 'expression', go to state 331
Parser(B) >> Reduce 160 [say ::= TK_SAY expression], pop back to state 11.
Parser(B) >> ... then shift 'say', go to state 365
Parser(B) >> Reduce 60 [keyword_instruction ::= say], pop back to state 11.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 11.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_SAY' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 11.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 2.
Parser(B) >> ... then shift 'instruction_list', go to state 11
Parser(B) >> Shift 'TK_SAY', go to state 22
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_SAY]
Parser(B) >> Input 'TK_STRING' in state 22
Parser(B) >> Shift 'TK_STRING', go to state 111
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_SAY TK_STRING]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 111
Parser(B) >> Reduce 179 [term ::= TK_STRING], pop back to state 22.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 22.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 22.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_SAY concatenation TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EOC' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 61.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 61.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 61.
Parser(B) >> ... then shift 'bracket', go to state 216
Parser(B) >> Reduce 196 [prefix_expression_c ::= bracket], pop back to state 61.
Parser(B) >> ... then shift 'prefix_expression_c', go to state 214
Parser(B) >> Reduce 198 [power_expression_c ::= prefix_expression_c], pop back to state 61.
Parser(B) >> ... then shift 'power_expression_c', go to state 213
Parser(B) >> Reduce 200 [multiplication_c ::= power_expression_c], pop back to state 61.
Parser(B) >> ... then shift 'multiplication_c', go to state 238
Parser(B) >> Reduce 205 [addition_c ::= multiplication_c], pop back to state 61.
Parser(B) >> ... then shift 'addition_c', go to state 244
Parser(B) >> Reduce 210 [concatenation ::= concatenation addition_c], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 22.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 22.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 22.
Parser(B) >> ... then shift 'expression', go to state 331
Parser(B) >> Reduce 160 [say ::= TK_SAY expression], pop back to state 11.
Parser(B) >> ... then shift 'say', go to state 365
Parser(B) >> Reduce 60 [keyword_instruction ::= say], pop back to state 11.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 11.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_RETURN' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 11.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 2.
Parser(B) >> ... then shift 'instruction_list', go to state 11
Parser(B) >> Shift 'TK_RETURN', go to state 23
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_RETURN]
Parser(B) >> Input 'TK_EOC' in state 23
Parser(B) >> Reduce 159 [return ::= TK_RETURN], pop back to state 11.
Parser(B) >> ... then shift 'return', go to state 366
Parser(B) >> Reduce 59 [keyword_instruction ::= return], pop back to state 11.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 11.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_EOS' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 11.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 2.
Parser(B) >> ... then shift 'instruction_list', go to state 11
Parser(B) >> Shift 'TK_EOS', go to state 409
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_EOS]
Parser(B) >> Input '$' in state 409
Parser(B) >> Reduce 0 [program ::= rexx_options namespace_list instruction_list TK_EOS], pop back to state 0.
Parser(B) >> ... then shift 'program', pending reduce -2
Parser(B) >> Accept!
Options parser >> Input 'TK_OPTIONS' in state 0
Options parser >> Shift 'TK_OPTIONS', go to state 1
Options parser >> Return. Stack=[TK_OPTIONS]
Options parser >> Input 'TK_LEVELB' in state 1
Options parser >> Shift 'TK_LEVELB', go to state 16
Options parser >> Return. Stack=[TK_OPTIONS TK_LEVELB]
Options parser >> Input 'TK_EOC' in state 16
Options parser >> Reduce 4 [option ::= TK_LEVELB], pop back to state 1.
Options parser >> ... then shift 'option', go to state 4
Options parser >> Reduce 18 [option_list ::= option] without external action, pop back to state 1.
Options parser >> ... then shift 'option_list', go to state 2
Options parser >> Shift 'TK_EOC', go to state 23
Options parser >> Return. Stack=[TK_OPTIONS option_list TK_EOC]
Options parser >> Input 'TK_SYMBOL' in state 23
Options parser >> WILDCARD TK_SYMBOL => ANYTHING
Options parser >> Reduce 2 [rexx_options ::= TK_OPTIONS option_list TK_EOC], pop back to state 0.
Options parser >> ... then shift 'rexx_options', go to state 3
Options parser >> WILDCARD TK_SYMBOL => ANYTHING
Options parser >> Shift 'TK_SYMBOL', go to state 20
Options parser >> Return. Stack=[rexx_options TK_SYMBOL]
Options parser >> Popping TK_SYMBOL
Options parser >> Popping rexx_options
Parser(B) >> Stack grows from 0 to 100 entries.
Parser(B) >> Input 'TK_OPTIONS' in state 0
Parser(B) >> Shift 'TK_OPTIONS', go to state 81
Parser(B) >> Return. Stack=[TK_OPTIONS]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 81
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 301
Parser(B) >> Return. Stack=[TK_OPTIONS TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EOC' in state 301
Parser(B) >> Reduce 18 [option ::= TK_VAR_SYMBOL], pop back to state 81.
Parser(B) >> ... then shift 'option', go to state 300
Parser(B) >> Reduce 16 [option_list ::= option], pop back to state 81.
Parser(B) >> ... then shift 'option_list', go to state 90
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 130
Parser(B) >> Shift 'TK_EOC', go to state 195
Parser(B) >> Return. Stack=[TK_OPTIONS option_list junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 195
Parser(B) >> Reduce 15 [rexx_options ::= TK_OPTIONS option_list junk TK_EOC], pop back to state 0.
Parser(B) >> ... then shift 'rexx_options', go to state 1
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 1.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_INTEGER' in state 33
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options var_symbol TK_EQUAL TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 1.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 1.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 1.
Parser(B) >> ... then shift 'labeled_instruction', go to state 184
Parser(B) >> Reduce 33 [instruction_list ::= labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 8.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_INTEGER' in state 33
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 8.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_DO' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_DO', go to state 113
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_DO]
Parser(B) >> Input 'TK_INTEGER' in state 113
Parser(B) >> Reduce 80 [tk_doloop ::= TK_DO], pop back to state 8.
Parser(B) >> ... then shift 'tk_doloop', go to state 17
Parser(B) >> Shift 'TK_INTEGER', go to state 249
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 249
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 17.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 17.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 17.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 17.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 17.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 17.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 17.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 17.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 17.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 17.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 17.
Parser(B) >> ... then shift 'expression', go to state 303
Parser(B) >> Reduce 96 [dorep ::= expression], pop back to state 17.
Parser(B) >> ... then shift 'dorep', go to state 96
Parser(B) >> Shift 'TK_EOC', go to state 3
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 3
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_EOC TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 3.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_EOC var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 33
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_EOC var_symbol TK_EQUAL TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_PLUS' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 33.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Shift 'TK_PLUS', go to state 64
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_EOC var_symbol TK_EQUAL addition TK_PLUS]
Parser(B) >> Input 'TK_INTEGER' in state 64
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_EOC var_symbol TK_EQUAL addition TK_PLUS TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 64.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 64.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 64.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 64.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 64.
Parser(B) >> ... then shift 'multiplication', go to state 240
Parser(B) >> Reduce 194 [addition ::= addition TK_PLUS multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 3.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 3.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_EOC single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_END' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 3.
Parser(B) >> ... then shift 'labeled_instruction', go to state 184
Parser(B) >> Reduce 33 [instruction_list ::= labeled_instruction], pop back to state 3.
Parser(B) >> ... then shift 'instruction_list', go to state 9
Parser(B) >> Shift 'TK_END', go to state 128
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_EOC instruction_list TK_END]
Parser(B) >> Input 'TK_EOC' in state 128
Parser(B) >> Reduce 82 [do ::= tk_doloop dorep TK_EOC instruction_list TK_END], pop back to state 8.
Parser(B) >> ... then shift 'do', go to state 101
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 405
Parser(B) >> Shift 'TK_EOC', go to state 186
Parser(B) >> Return. Stack=[rexx_options instruction_list do junk TK_EOC]
Parser(B) >> Input 'TK_IF' in state 186
Parser(B) >> Reduce 71 [group ::= do junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'group', go to state 193
Parser(B) >> Reduce 35 [labeled_instruction ::= group], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_IF', go to state 30
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 30
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_NEQ' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 30.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 30.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 30.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 30.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 30.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 30.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 30.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 30.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Shift 'TK_NEQ', go to state 47
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ]
Parser(B) >> Input 'TK_INTEGER' in state 47
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 47.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 47.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 47.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 47.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 47.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 47.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 47.
Parser(B) >> ... then shift 'concatenation', go to state 59
Parser(B) >> Reduce 213 [comparison ::= comparison TK_NEQ concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 30.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 30.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 30.
Parser(B) >> ... then shift 'expression', go to state 127
Parser(B) >> Shift 'TK_EOC', go to state 206
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression TK_EOC]
Parser(B) >> Input 'TK_THEN' in state 206
Parser(B) >> Reduce 253 [ncl0 ::= TK_EOC] without external action, pop back to state 127.
Parser(B) >> ... then shift 'ncl0', go to state 131
Parser(B) >> Shift 'TK_THEN', go to state 109
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN]
Parser(B) >> Input 'TK_DO' in state 109
Parser(B) >> Reduce 254 [ncl0 ::=] without external action.
Parser(B) >> ... then shift 'ncl0', go to state 15
Parser(B) >> Shift 'TK_DO', go to state 113
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO]
Parser(B) >> Input 'TK_EOC' in state 113
Parser(B) >> Shift 'TK_EOC', go to state 7
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 7
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 7.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 33
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_PLUS' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 33.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Shift 'TK_PLUS', go to state 64
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL addition TK_PLUS]
Parser(B) >> Input 'TK_INTEGER' in state 64
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL addition TK_PLUS TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 64.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 64.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 64.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 64.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 64.
Parser(B) >> ... then shift 'multiplication', go to state 240
Parser(B) >> Reduce 194 [addition ::= addition TK_PLUS multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 7.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 7.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_SAY' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 7.
Parser(B) >> ... then shift 'labeled_instruction', go to state 184
Parser(B) >> Reduce 33 [instruction_list ::= labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_SAY', go to state 22
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_SAY]
Parser(B) >> Input 'TK_STRING' in state 22
Parser(B) >> Shift 'TK_STRING', go to state 111
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_SAY TK_STRING]
Parser(B) >> Input 'TK_EOC' in state 111
Parser(B) >> Reduce 179 [term ::= TK_STRING], pop back to state 22.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 22.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 22.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 22.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 22.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 22.
Parser(B) >> ... then shift 'expression', go to state 331
Parser(B) >> Reduce 160 [say ::= TK_SAY expression], pop back to state 10.
Parser(B) >> ... then shift 'say', go to state 365
Parser(B) >> Reduce 60 [keyword_instruction ::= say], pop back to state 10.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 10.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_END' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 10.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_END', go to state 129
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_END]
Parser(B) >> Input 'TK_EOC' in state 129
Parser(B) >> Reduce 73 [simple_do ::= TK_DO TK_EOC instruction_list TK_END], pop back to state 15.
Parser(B) >> ... then shift 'simple_do', go to state 102
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 406
Parser(B) >> Shift 'TK_EOC', go to state 187
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 simple_do junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 187
Parser(B) >> Reduce 70 [group ::= simple_do junk TK_EOC], pop back to state 15.
Parser(B) >> ... then shift 'group', go to state 182
Parser(B) >> Reduce 41 [instruction ::= group], pop back to state 15.
Parser(B) >> ... then shift 'instruction', go to state 175
Parser(B) >> Reduce 110 [then ::= TK_THEN ncl0 instruction], pop back to state 131.
Parser(B) >> ... then shift 'then', go to state 108
Parser(B) >> Reduce 108 [if ::= TK_IF expression ncl0 then], pop back to state 8.
Parser(B) >> ... then shift 'if', go to state 185
Parser(B) >> Reduce 72 [group ::= if], pop back to state 8.
Parser(B) >> ... then shift 'group', go to state 193
Parser(B) >> Reduce 35 [labeled_instruction ::= group], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 8.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_INTEGER' in state 33
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 8.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_DO' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_DO', go to state 113
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_DO]
Parser(B) >> Input 'TK_FOREVER' in state 113
Parser(B) >> Reduce 80 [tk_doloop ::= TK_DO], pop back to state 8.
Parser(B) >> ... then shift 'tk_doloop', go to state 17
Parser(B) >> Shift 'TK_FOREVER', go to state 393
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop TK_FOREVER]
Parser(B) >> Input 'TK_EOC' in state 393
Parser(B) >> Reduce 104 [doforever ::= TK_FOREVER], pop back to state 17.
Parser(B) >> ... then shift 'doforever', go to state 394
Parser(B) >> Shift 'TK_EOC', go to state 4
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop doforever TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 4
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop doforever TK_EOC TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 4.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop doforever TK_EOC var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 33
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop doforever TK_EOC var_symbol TK_EQUAL TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_PLUS' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 33.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Shift 'TK_PLUS', go to state 64
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop doforever TK_EOC var_symbol TK_EQUAL addition TK_PLUS]
Parser(B) >> Input 'TK_INTEGER' in state 64
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop doforever TK_EOC var_symbol TK_EQUAL addition TK_PLUS TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 64.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 64.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 64.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 64.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 64.
Parser(B) >> ... then shift 'multiplication', go to state 240
Parser(B) >> Reduce 194 [addition ::= addition TK_PLUS multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 4.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 4.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop doforever TK_EOC single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 4.
Parser(B) >> ... then shift 'labeled_instruction', go to state 184
Parser(B) >> Reduce 33 [instruction_list ::= labeled_instruction], pop back to state 4.
Parser(B) >> ... then shift 'instruction_list', go to state 12
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop doforever TK_EOC instruction_list TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 12.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop doforever TK_EOC instruction_list var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 33
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop doforever TK_EOC instruction_list var_symbol TK_EQUAL TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_PLUS' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 33.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Shift 'TK_PLUS', go to state 64
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop doforever TK_EOC instruction_list var_symbol TK_EQUAL addition TK_PLUS]
Parser(B) >> Input 'TK_INTEGER' in state 64
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop doforever TK_EOC instruction_list var_symbol TK_EQUAL addition TK_PLUS TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 64.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 64.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 64.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 64.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 64.
Parser(B) >> ... then shift 'multiplication', go to state 240
Parser(B) >> Reduce 194 [addition ::= addition TK_PLUS multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 12.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 12.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop doforever TK_EOC instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_IF' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 12.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 4.
Parser(B) >> ... then shift 'instruction_list', go to state 12
Parser(B) >> Shift 'TK_IF', go to state 30
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop doforever TK_EOC instruction_list TK_IF]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 30
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop doforever TK_EOC instruction_list TK_IF TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 30.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 30.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 30.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 30.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 30.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 30.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 30.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 30.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Shift 'TK_EQUAL', go to state 48
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop doforever TK_EOC instruction_list TK_IF comparison TK_EQUAL]
Parser(B) >> Input 'TK_INTEGER' in state 48
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop doforever TK_EOC instruction_list TK_IF comparison TK_EQUAL TK_INTEGER]
Parser(B) >> Input 'TK_THEN' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 48.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 48.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 48.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 48.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 48.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 48.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 48.
Parser(B) >> ... then shift 'concatenation', go to state 60
Parser(B) >> Reduce 212 [comparison ::= comparison TK_EQUAL concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 30.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 30.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 30.
Parser(B) >> ... then shift 'expression', go to state 127
Parser(B) >> Reduce 254 [ncl0 ::=] without external action.
Parser(B) >> ... then shift 'ncl0', go to state 131
Parser(B) >> Shift 'TK_THEN', go to state 109
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop doforever TK_EOC instruction_list TK_IF expression ncl0 TK_THEN]
Parser(B) >> Input 'TK_LEAVE' in state 109
Parser(B) >> Reduce 254 [ncl0 ::=] without external action.
Parser(B) >> ... then shift 'ncl0', go to state 15
Parser(B) >> Shift 'TK_LEAVE', go to state 117
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop doforever TK_EOC instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_LEAVE]
Parser(B) >> Input 'TK_EOC' in state 117
Parser(B) >> Reduce 157 [leave ::= TK_LEAVE], pop back to state 15.
Parser(B) >> ... then shift 'leave', go to state 369
Parser(B) >> Reduce 56 [keyword_instruction ::= leave], pop back to state 15.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 15.
Parser(B) >> ... then shift 'single_instruction', go to state 100
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 404
Parser(B) >> Shift 'TK_EOC', go to state 181
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop doforever TK_EOC instruction_list TK_IF expression ncl0 TK_THEN ncl0 single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_END' in state 181
Parser(B) >> Reduce 42 [instruction ::= single_instruction junk TK_EOC], pop back to state 15.
Parser(B) >> ... then shift 'instruction', go to state 175
Parser(B) >> Reduce 110 [then ::= TK_THEN ncl0 instruction], pop back to state 131.
Parser(B) >> ... then shift 'then', go to state 108
Parser(B) >> Reduce 108 [if ::= TK_IF expression ncl0 then], pop back to state 12.
Parser(B) >> ... then shift 'if', go to state 185
Parser(B) >> Reduce 72 [group ::= if], pop back to state 12.
Parser(B) >> ... then shift 'group', go to state 193
Parser(B) >> Reduce 35 [labeled_instruction ::= group], pop back to state 12.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 4.
Parser(B) >> ... then shift 'instruction_list', go to state 12
Parser(B) >> Shift 'TK_END', go to state 121
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop doforever TK_EOC instruction_list TK_END]
Parser(B) >> Input 'TK_EOC' in state 121
Parser(B) >> Reduce 88 [do ::= tk_doloop doforever TK_EOC instruction_list TK_END], pop back to state 8.
Parser(B) >> ... then shift 'do', go to state 101
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 405
Parser(B) >> Shift 'TK_EOC', go to state 186
Parser(B) >> Return. Stack=[rexx_options instruction_list do junk TK_EOC]
Parser(B) >> Input 'TK_IF' in state 186
Parser(B) >> Reduce 71 [group ::= do junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'group', go to state 193
Parser(B) >> Reduce 35 [labeled_instruction ::= group], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_IF', go to state 30
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 30
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_NEQ' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 30.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 30.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 30.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 30.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 30.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 30.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 30.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 30.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Shift 'TK_NEQ', go to state 47
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ]
Parser(B) >> Input 'TK_INTEGER' in state 47
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 47.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 47.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 47.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 47.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 47.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 47.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 47.
Parser(B) >> ... then shift 'concatenation', go to state 59
Parser(B) >> Reduce 213 [comparison ::= comparison TK_NEQ concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 30.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 30.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 30.
Parser(B) >> ... then shift 'expression', go to state 127
Parser(B) >> Shift 'TK_EOC', go to state 206
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression TK_EOC]
Parser(B) >> Input 'TK_THEN' in state 206
Parser(B) >> Reduce 253 [ncl0 ::= TK_EOC] without external action, pop back to state 127.
Parser(B) >> ... then shift 'ncl0', go to state 131
Parser(B) >> Shift 'TK_THEN', go to state 109
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN]
Parser(B) >> Input 'TK_DO' in state 109
Parser(B) >> Reduce 254 [ncl0 ::=] without external action.
Parser(B) >> ... then shift 'ncl0', go to state 15
Parser(B) >> Shift 'TK_DO', go to state 113
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO]
Parser(B) >> Input 'TK_EOC' in state 113
Parser(B) >> Shift 'TK_EOC', go to state 7
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 7
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 7.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 33
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_PLUS' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 33.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Shift 'TK_PLUS', go to state 64
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL addition TK_PLUS]
Parser(B) >> Input 'TK_INTEGER' in state 64
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL addition TK_PLUS TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 64.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 64.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 64.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 64.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 64.
Parser(B) >> ... then shift 'multiplication', go to state 240
Parser(B) >> Reduce 194 [addition ::= addition TK_PLUS multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 7.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 7.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_SAY' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 7.
Parser(B) >> ... then shift 'labeled_instruction', go to state 184
Parser(B) >> Reduce 33 [instruction_list ::= labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_SAY', go to state 22
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_SAY]
Parser(B) >> Input 'TK_STRING' in state 22
Parser(B) >> Shift 'TK_STRING', go to state 111
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_SAY TK_STRING]
Parser(B) >> Input 'TK_EOC' in state 111
Parser(B) >> Reduce 179 [term ::= TK_STRING], pop back to state 22.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 22.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 22.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 22.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 22.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 22.
Parser(B) >> ... then shift 'expression', go to state 331
Parser(B) >> Reduce 160 [say ::= TK_SAY expression], pop back to state 10.
Parser(B) >> ... then shift 'say', go to state 365
Parser(B) >> Reduce 60 [keyword_instruction ::= say], pop back to state 10.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 10.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_END' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 10.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_END', go to state 129
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_END]
Parser(B) >> Input 'TK_EOC' in state 129
Parser(B) >> Reduce 73 [simple_do ::= TK_DO TK_EOC instruction_list TK_END], pop back to state 15.
Parser(B) >> ... then shift 'simple_do', go to state 102
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 406
Parser(B) >> Shift 'TK_EOC', go to state 187
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 simple_do junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 187
Parser(B) >> Reduce 70 [group ::= simple_do junk TK_EOC], pop back to state 15.
Parser(B) >> ... then shift 'group', go to state 182
Parser(B) >> Reduce 41 [instruction ::= group], pop back to state 15.
Parser(B) >> ... then shift 'instruction', go to state 175
Parser(B) >> Reduce 110 [then ::= TK_THEN ncl0 instruction], pop back to state 131.
Parser(B) >> ... then shift 'then', go to state 108
Parser(B) >> Reduce 108 [if ::= TK_IF expression ncl0 then], pop back to state 8.
Parser(B) >> ... then shift 'if', go to state 185
Parser(B) >> Reduce 72 [group ::= if], pop back to state 8.
Parser(B) >> ... then shift 'group', go to state 193
Parser(B) >> Reduce 35 [labeled_instruction ::= group], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 8.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_INTEGER' in state 33
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 8.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 8.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_INTEGER' in state 33
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 8.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_DO' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_DO', go to state 113
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_DO]
Parser(B) >> Input 'TK_UNTIL' in state 113
Parser(B) >> Reduce 80 [tk_doloop ::= TK_DO], pop back to state 8.
Parser(B) >> ... then shift 'tk_doloop', go to state 17
Parser(B) >> Shift 'TK_UNTIL', go to state 28
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop TK_UNTIL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 28
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop TK_UNTIL TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 28.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 28.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 28.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 28.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 28.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 28.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 28.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 28.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 28.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Shift 'TK_EQUAL', go to state 48
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop TK_UNTIL comparison TK_EQUAL]
Parser(B) >> Input 'TK_INTEGER' in state 48
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop TK_UNTIL comparison TK_EQUAL TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 48.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 48.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 48.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 48.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 48.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 48.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 48.
Parser(B) >> ... then shift 'concatenation', go to state 60
Parser(B) >> Reduce 212 [comparison ::= comparison TK_EQUAL concatenation], pop back to state 28.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 28.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 28.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 28.
Parser(B) >> ... then shift 'expression', go to state 396
Parser(B) >> Reduce 106 [docond ::= TK_UNTIL expression], pop back to state 17.
Parser(B) >> ... then shift 'docond', go to state 395
Parser(B) >> Shift 'TK_EOC', go to state 5
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop docond TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 5
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop docond TK_EOC TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 5.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop docond TK_EOC var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 33
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop docond TK_EOC var_symbol TK_EQUAL TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_PLUS' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 33.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Shift 'TK_PLUS', go to state 64
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop docond TK_EOC var_symbol TK_EQUAL addition TK_PLUS]
Parser(B) >> Input 'TK_INTEGER' in state 64
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop docond TK_EOC var_symbol TK_EQUAL addition TK_PLUS TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 64.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 64.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 64.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 64.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 64.
Parser(B) >> ... then shift 'multiplication', go to state 240
Parser(B) >> Reduce 194 [addition ::= addition TK_PLUS multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 5.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 5.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop docond TK_EOC single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 5.
Parser(B) >> ... then shift 'labeled_instruction', go to state 184
Parser(B) >> Reduce 33 [instruction_list ::= labeled_instruction], pop back to state 5.
Parser(B) >> ... then shift 'instruction_list', go to state 13
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop docond TK_EOC instruction_list TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 13.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop docond TK_EOC instruction_list var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 33
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop docond TK_EOC instruction_list var_symbol TK_EQUAL TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_PLUS' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 33.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Shift 'TK_PLUS', go to state 64
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop docond TK_EOC instruction_list var_symbol TK_EQUAL addition TK_PLUS]
Parser(B) >> Input 'TK_INTEGER' in state 64
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop docond TK_EOC instruction_list var_symbol TK_EQUAL addition TK_PLUS TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 64.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 64.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 64.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 64.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 64.
Parser(B) >> ... then shift 'multiplication', go to state 240
Parser(B) >> Reduce 194 [addition ::= addition TK_PLUS multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 13.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 13.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop docond TK_EOC instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_END' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 13.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 5.
Parser(B) >> ... then shift 'instruction_list', go to state 13
Parser(B) >> Shift 'TK_END', go to state 123
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop docond TK_EOC instruction_list TK_END]
Parser(B) >> Input 'TK_EOC' in state 123
Parser(B) >> Reduce 86 [do ::= tk_doloop docond TK_EOC instruction_list TK_END], pop back to state 8.
Parser(B) >> ... then shift 'do', go to state 101
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 405
Parser(B) >> Shift 'TK_EOC', go to state 186
Parser(B) >> Return. Stack=[rexx_options instruction_list do junk TK_EOC]
Parser(B) >> Input 'TK_IF' in state 186
Parser(B) >> Reduce 71 [group ::= do junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'group', go to state 193
Parser(B) >> Reduce 35 [labeled_instruction ::= group], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_IF', go to state 30
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 30
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_NEQ' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 30.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 30.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 30.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 30.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 30.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 30.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 30.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 30.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Shift 'TK_NEQ', go to state 47
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ]
Parser(B) >> Input 'TK_INTEGER' in state 47
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 47.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 47.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 47.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 47.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 47.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 47.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 47.
Parser(B) >> ... then shift 'concatenation', go to state 59
Parser(B) >> Reduce 213 [comparison ::= comparison TK_NEQ concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 30.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 30.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 30.
Parser(B) >> ... then shift 'expression', go to state 127
Parser(B) >> Shift 'TK_EOC', go to state 206
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression TK_EOC]
Parser(B) >> Input 'TK_THEN' in state 206
Parser(B) >> Reduce 253 [ncl0 ::= TK_EOC] without external action, pop back to state 127.
Parser(B) >> ... then shift 'ncl0', go to state 131
Parser(B) >> Shift 'TK_THEN', go to state 109
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN]
Parser(B) >> Input 'TK_DO' in state 109
Parser(B) >> Reduce 254 [ncl0 ::=] without external action.
Parser(B) >> ... then shift 'ncl0', go to state 15
Parser(B) >> Shift 'TK_DO', go to state 113
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO]
Parser(B) >> Input 'TK_EOC' in state 113
Parser(B) >> Shift 'TK_EOC', go to state 7
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 7
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 7.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 33
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_PLUS' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 33.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Shift 'TK_PLUS', go to state 64
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL addition TK_PLUS]
Parser(B) >> Input 'TK_INTEGER' in state 64
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL addition TK_PLUS TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 64.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 64.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 64.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 64.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 64.
Parser(B) >> ... then shift 'multiplication', go to state 240
Parser(B) >> Reduce 194 [addition ::= addition TK_PLUS multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 7.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 7.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_SAY' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 7.
Parser(B) >> ... then shift 'labeled_instruction', go to state 184
Parser(B) >> Reduce 33 [instruction_list ::= labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_SAY', go to state 22
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_SAY]
Parser(B) >> Input 'TK_STRING' in state 22
Parser(B) >> Shift 'TK_STRING', go to state 111
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_SAY TK_STRING]
Parser(B) >> Input 'TK_EOC' in state 111
Parser(B) >> Reduce 179 [term ::= TK_STRING], pop back to state 22.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 22.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 22.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 22.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 22.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 22.
Parser(B) >> ... then shift 'expression', go to state 331
Parser(B) >> Reduce 160 [say ::= TK_SAY expression], pop back to state 10.
Parser(B) >> ... then shift 'say', go to state 365
Parser(B) >> Reduce 60 [keyword_instruction ::= say], pop back to state 10.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 10.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_END' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 10.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_END', go to state 129
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_END]
Parser(B) >> Input 'TK_EOC' in state 129
Parser(B) >> Reduce 73 [simple_do ::= TK_DO TK_EOC instruction_list TK_END], pop back to state 15.
Parser(B) >> ... then shift 'simple_do', go to state 102
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 406
Parser(B) >> Shift 'TK_EOC', go to state 187
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 simple_do junk TK_EOC]
Parser(B) >> Input 'TK_IF' in state 187
Parser(B) >> Reduce 70 [group ::= simple_do junk TK_EOC], pop back to state 15.
Parser(B) >> ... then shift 'group', go to state 182
Parser(B) >> Reduce 41 [instruction ::= group], pop back to state 15.
Parser(B) >> ... then shift 'instruction', go to state 175
Parser(B) >> Reduce 110 [then ::= TK_THEN ncl0 instruction], pop back to state 131.
Parser(B) >> ... then shift 'then', go to state 108
Parser(B) >> Reduce 108 [if ::= TK_IF expression ncl0 then], pop back to state 8.
Parser(B) >> ... then shift 'if', go to state 185
Parser(B) >> Reduce 72 [group ::= if], pop back to state 8.
Parser(B) >> ... then shift 'group', go to state 193
Parser(B) >> Reduce 35 [labeled_instruction ::= group], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_IF', go to state 30
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 30
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_NEQ' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 30.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 30.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 30.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 30.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 30.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 30.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 30.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 30.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Shift 'TK_NEQ', go to state 47
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ]
Parser(B) >> Input 'TK_INTEGER' in state 47
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 47.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 47.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 47.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 47.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 47.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 47.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 47.
Parser(B) >> ... then shift 'concatenation', go to state 59
Parser(B) >> Reduce 213 [comparison ::= comparison TK_NEQ concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 30.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 30.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 30.
Parser(B) >> ... then shift 'expression', go to state 127
Parser(B) >> Shift 'TK_EOC', go to state 206
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression TK_EOC]
Parser(B) >> Input 'TK_THEN' in state 206
Parser(B) >> Reduce 253 [ncl0 ::= TK_EOC] without external action, pop back to state 127.
Parser(B) >> ... then shift 'ncl0', go to state 131
Parser(B) >> Shift 'TK_THEN', go to state 109
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN]
Parser(B) >> Input 'TK_DO' in state 109
Parser(B) >> Reduce 254 [ncl0 ::=] without external action.
Parser(B) >> ... then shift 'ncl0', go to state 15
Parser(B) >> Shift 'TK_DO', go to state 113
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO]
Parser(B) >> Input 'TK_EOC' in state 113
Parser(B) >> Shift 'TK_EOC', go to state 7
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 7
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 7.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 33
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_PLUS' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 33.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Shift 'TK_PLUS', go to state 64
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL addition TK_PLUS]
Parser(B) >> Input 'TK_INTEGER' in state 64
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL addition TK_PLUS TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 64.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 64.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 64.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 64.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 64.
Parser(B) >> ... then shift 'multiplication', go to state 240
Parser(B) >> Reduce 194 [addition ::= addition TK_PLUS multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 7.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 7.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_SAY' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 7.
Parser(B) >> ... then shift 'labeled_instruction', go to state 184
Parser(B) >> Reduce 33 [instruction_list ::= labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_SAY', go to state 22
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_SAY]
Parser(B) >> Input 'TK_STRING' in state 22
Parser(B) >> Shift 'TK_STRING', go to state 111
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_SAY TK_STRING]
Parser(B) >> Input 'TK_EOC' in state 111
Parser(B) >> Reduce 179 [term ::= TK_STRING], pop back to state 22.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 22.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 22.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 22.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 22.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 22.
Parser(B) >> ... then shift 'expression', go to state 331
Parser(B) >> Reduce 160 [say ::= TK_SAY expression], pop back to state 10.
Parser(B) >> ... then shift 'say', go to state 365
Parser(B) >> Reduce 60 [keyword_instruction ::= say], pop back to state 10.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 10.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_END' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 10.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_END', go to state 129
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_END]
Parser(B) >> Input 'TK_EOC' in state 129
Parser(B) >> Reduce 73 [simple_do ::= TK_DO TK_EOC instruction_list TK_END], pop back to state 15.
Parser(B) >> ... then shift 'simple_do', go to state 102
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 406
Parser(B) >> Shift 'TK_EOC', go to state 187
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 simple_do junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 187
Parser(B) >> Reduce 70 [group ::= simple_do junk TK_EOC], pop back to state 15.
Parser(B) >> ... then shift 'group', go to state 182
Parser(B) >> Reduce 41 [instruction ::= group], pop back to state 15.
Parser(B) >> ... then shift 'instruction', go to state 175
Parser(B) >> Reduce 110 [then ::= TK_THEN ncl0 instruction], pop back to state 131.
Parser(B) >> ... then shift 'then', go to state 108
Parser(B) >> Reduce 108 [if ::= TK_IF expression ncl0 then], pop back to state 8.
Parser(B) >> ... then shift 'if', go to state 185
Parser(B) >> Reduce 72 [group ::= if], pop back to state 8.
Parser(B) >> ... then shift 'group', go to state 193
Parser(B) >> Reduce 35 [labeled_instruction ::= group], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 8.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_INTEGER' in state 33
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 8.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 8.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_INTEGER' in state 33
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 8.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_DO' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_DO', go to state 113
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_DO]
Parser(B) >> Input 'TK_WHILE' in state 113
Parser(B) >> Reduce 80 [tk_doloop ::= TK_DO], pop back to state 8.
Parser(B) >> ... then shift 'tk_doloop', go to state 17
Parser(B) >> Shift 'TK_WHILE', go to state 29
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop TK_WHILE]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 29
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop TK_WHILE TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_LT' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 29.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 29.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 29.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 29.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 29.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 29.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 29.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 29.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 29.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Shift 'TK_LT', go to state 45
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop TK_WHILE comparison TK_LT]
Parser(B) >> Input 'TK_INTEGER' in state 45
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop TK_WHILE comparison TK_LT TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 45.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 45.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 45.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 45.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 45.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 45.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 45.
Parser(B) >> ... then shift 'concatenation', go to state 57
Parser(B) >> Reduce 215 [comparison ::= comparison TK_LT concatenation], pop back to state 29.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 29.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 29.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 29.
Parser(B) >> ... then shift 'expression', go to state 397
Parser(B) >> Reduce 105 [docond ::= TK_WHILE expression], pop back to state 17.
Parser(B) >> ... then shift 'docond', go to state 395
Parser(B) >> Shift 'TK_EOC', go to state 5
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop docond TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 5
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop docond TK_EOC TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 5.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop docond TK_EOC var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 33
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop docond TK_EOC var_symbol TK_EQUAL TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_PLUS' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 33.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Shift 'TK_PLUS', go to state 64
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop docond TK_EOC var_symbol TK_EQUAL addition TK_PLUS]
Parser(B) >> Input 'TK_INTEGER' in state 64
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop docond TK_EOC var_symbol TK_EQUAL addition TK_PLUS TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 64.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 64.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 64.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 64.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 64.
Parser(B) >> ... then shift 'multiplication', go to state 240
Parser(B) >> Reduce 194 [addition ::= addition TK_PLUS multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 5.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 5.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop docond TK_EOC single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 5.
Parser(B) >> ... then shift 'labeled_instruction', go to state 184
Parser(B) >> Reduce 33 [instruction_list ::= labeled_instruction], pop back to state 5.
Parser(B) >> ... then shift 'instruction_list', go to state 13
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop docond TK_EOC instruction_list TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 13.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop docond TK_EOC instruction_list var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 33
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop docond TK_EOC instruction_list var_symbol TK_EQUAL TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_PLUS' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 33.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Shift 'TK_PLUS', go to state 64
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop docond TK_EOC instruction_list var_symbol TK_EQUAL addition TK_PLUS]
Parser(B) >> Input 'TK_INTEGER' in state 64
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop docond TK_EOC instruction_list var_symbol TK_EQUAL addition TK_PLUS TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 64.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 64.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 64.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 64.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 64.
Parser(B) >> ... then shift 'multiplication', go to state 240
Parser(B) >> Reduce 194 [addition ::= addition TK_PLUS multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 13.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 13.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop docond TK_EOC instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_END' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 13.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 5.
Parser(B) >> ... then shift 'instruction_list', go to state 13
Parser(B) >> Shift 'TK_END', go to state 123
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop docond TK_EOC instruction_list TK_END]
Parser(B) >> Input 'TK_EOC' in state 123
Parser(B) >> Reduce 86 [do ::= tk_doloop docond TK_EOC instruction_list TK_END], pop back to state 8.
Parser(B) >> ... then shift 'do', go to state 101
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 405
Parser(B) >> Shift 'TK_EOC', go to state 186
Parser(B) >> Return. Stack=[rexx_options instruction_list do junk TK_EOC]
Parser(B) >> Input 'TK_IF' in state 186
Parser(B) >> Reduce 71 [group ::= do junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'group', go to state 193
Parser(B) >> Reduce 35 [labeled_instruction ::= group], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_IF', go to state 30
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 30
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_NEQ' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 30.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 30.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 30.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 30.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 30.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 30.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 30.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 30.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Shift 'TK_NEQ', go to state 47
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ]
Parser(B) >> Input 'TK_INTEGER' in state 47
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 47.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 47.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 47.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 47.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 47.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 47.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 47.
Parser(B) >> ... then shift 'concatenation', go to state 59
Parser(B) >> Reduce 213 [comparison ::= comparison TK_NEQ concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 30.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 30.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 30.
Parser(B) >> ... then shift 'expression', go to state 127
Parser(B) >> Shift 'TK_EOC', go to state 206
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression TK_EOC]
Parser(B) >> Input 'TK_THEN' in state 206
Parser(B) >> Reduce 253 [ncl0 ::= TK_EOC] without external action, pop back to state 127.
Parser(B) >> ... then shift 'ncl0', go to state 131
Parser(B) >> Shift 'TK_THEN', go to state 109
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN]
Parser(B) >> Input 'TK_DO' in state 109
Parser(B) >> Reduce 254 [ncl0 ::=] without external action.
Parser(B) >> ... then shift 'ncl0', go to state 15
Parser(B) >> Shift 'TK_DO', go to state 113
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO]
Parser(B) >> Input 'TK_EOC' in state 113
Parser(B) >> Shift 'TK_EOC', go to state 7
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 7
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 7.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 33
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_PLUS' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 33.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Shift 'TK_PLUS', go to state 64
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL addition TK_PLUS]
Parser(B) >> Input 'TK_INTEGER' in state 64
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL addition TK_PLUS TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 64.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 64.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 64.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 64.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 64.
Parser(B) >> ... then shift 'multiplication', go to state 240
Parser(B) >> Reduce 194 [addition ::= addition TK_PLUS multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 7.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 7.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_SAY' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 7.
Parser(B) >> ... then shift 'labeled_instruction', go to state 184
Parser(B) >> Reduce 33 [instruction_list ::= labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_SAY', go to state 22
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_SAY]
Parser(B) >> Input 'TK_STRING' in state 22
Parser(B) >> Shift 'TK_STRING', go to state 111
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_SAY TK_STRING]
Parser(B) >> Input 'TK_EOC' in state 111
Parser(B) >> Reduce 179 [term ::= TK_STRING], pop back to state 22.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 22.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 22.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 22.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 22.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 22.
Parser(B) >> ... then shift 'expression', go to state 331
Parser(B) >> Reduce 160 [say ::= TK_SAY expression], pop back to state 10.
Parser(B) >> ... then shift 'say', go to state 365
Parser(B) >> Reduce 60 [keyword_instruction ::= say], pop back to state 10.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 10.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_END' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 10.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_END', go to state 129
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_END]
Parser(B) >> Input 'TK_EOC' in state 129
Parser(B) >> Reduce 73 [simple_do ::= TK_DO TK_EOC instruction_list TK_END], pop back to state 15.
Parser(B) >> ... then shift 'simple_do', go to state 102
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 406
Parser(B) >> Shift 'TK_EOC', go to state 187
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 simple_do junk TK_EOC]
Parser(B) >> Input 'TK_IF' in state 187
Parser(B) >> Reduce 70 [group ::= simple_do junk TK_EOC], pop back to state 15.
Parser(B) >> ... then shift 'group', go to state 182
Parser(B) >> Reduce 41 [instruction ::= group], pop back to state 15.
Parser(B) >> ... then shift 'instruction', go to state 175
Parser(B) >> Reduce 110 [then ::= TK_THEN ncl0 instruction], pop back to state 131.
Parser(B) >> ... then shift 'then', go to state 108
Parser(B) >> Reduce 108 [if ::= TK_IF expression ncl0 then], pop back to state 8.
Parser(B) >> ... then shift 'if', go to state 185
Parser(B) >> Reduce 72 [group ::= if], pop back to state 8.
Parser(B) >> ... then shift 'group', go to state 193
Parser(B) >> Reduce 35 [labeled_instruction ::= group], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_IF', go to state 30
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 30
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_NEQ' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 30.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 30.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 30.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 30.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 30.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 30.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 30.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 30.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Shift 'TK_NEQ', go to state 47
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ]
Parser(B) >> Input 'TK_INTEGER' in state 47
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 47.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 47.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 47.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 47.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 47.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 47.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 47.
Parser(B) >> ... then shift 'concatenation', go to state 59
Parser(B) >> Reduce 213 [comparison ::= comparison TK_NEQ concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 30.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 30.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 30.
Parser(B) >> ... then shift 'expression', go to state 127
Parser(B) >> Shift 'TK_EOC', go to state 206
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression TK_EOC]
Parser(B) >> Input 'TK_THEN' in state 206
Parser(B) >> Reduce 253 [ncl0 ::= TK_EOC] without external action, pop back to state 127.
Parser(B) >> ... then shift 'ncl0', go to state 131
Parser(B) >> Shift 'TK_THEN', go to state 109
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN]
Parser(B) >> Input 'TK_DO' in state 109
Parser(B) >> Reduce 254 [ncl0 ::=] without external action.
Parser(B) >> ... then shift 'ncl0', go to state 15
Parser(B) >> Shift 'TK_DO', go to state 113
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO]
Parser(B) >> Input 'TK_EOC' in state 113
Parser(B) >> Shift 'TK_EOC', go to state 7
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 7
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 7.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 33
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_PLUS' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 33.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Shift 'TK_PLUS', go to state 64
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL addition TK_PLUS]
Parser(B) >> Input 'TK_INTEGER' in state 64
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL addition TK_PLUS TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 64.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 64.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 64.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 64.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 64.
Parser(B) >> ... then shift 'multiplication', go to state 240
Parser(B) >> Reduce 194 [addition ::= addition TK_PLUS multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 7.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 7.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_SAY' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 7.
Parser(B) >> ... then shift 'labeled_instruction', go to state 184
Parser(B) >> Reduce 33 [instruction_list ::= labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_SAY', go to state 22
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_SAY]
Parser(B) >> Input 'TK_STRING' in state 22
Parser(B) >> Shift 'TK_STRING', go to state 111
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_SAY TK_STRING]
Parser(B) >> Input 'TK_EOC' in state 111
Parser(B) >> Reduce 179 [term ::= TK_STRING], pop back to state 22.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 22.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 22.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 22.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 22.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 22.
Parser(B) >> ... then shift 'expression', go to state 331
Parser(B) >> Reduce 160 [say ::= TK_SAY expression], pop back to state 10.
Parser(B) >> ... then shift 'say', go to state 365
Parser(B) >> Reduce 60 [keyword_instruction ::= say], pop back to state 10.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 10.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_END' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 10.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_END', go to state 129
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_END]
Parser(B) >> Input 'TK_EOC' in state 129
Parser(B) >> Reduce 73 [simple_do ::= TK_DO TK_EOC instruction_list TK_END], pop back to state 15.
Parser(B) >> ... then shift 'simple_do', go to state 102
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 406
Parser(B) >> Shift 'TK_EOC', go to state 187
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 simple_do junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 187
Parser(B) >> Reduce 70 [group ::= simple_do junk TK_EOC], pop back to state 15.
Parser(B) >> ... then shift 'group', go to state 182
Parser(B) >> Reduce 41 [instruction ::= group], pop back to state 15.
Parser(B) >> ... then shift 'instruction', go to state 175
Parser(B) >> Reduce 110 [then ::= TK_THEN ncl0 instruction], pop back to state 131.
Parser(B) >> ... then shift 'then', go to state 108
Parser(B) >> Reduce 108 [if ::= TK_IF expression ncl0 then], pop back to state 8.
Parser(B) >> ... then shift 'if', go to state 185
Parser(B) >> Reduce 72 [group ::= if], pop back to state 8.
Parser(B) >> ... then shift 'group', go to state 193
Parser(B) >> Reduce 35 [labeled_instruction ::= group], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 8.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_INTEGER' in state 33
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 8.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 8.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_INTEGER' in state 33
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 8.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_DO' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_DO', go to state 113
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_DO]
Parser(B) >> Input 'TK_WHILE' in state 113
Parser(B) >> Reduce 80 [tk_doloop ::= TK_DO], pop back to state 8.
Parser(B) >> ... then shift 'tk_doloop', go to state 17
Parser(B) >> Shift 'TK_WHILE', go to state 29
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop TK_WHILE]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 29
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop TK_WHILE TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_LT' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 29.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 29.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 29.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 29.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 29.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 29.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 29.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 29.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 29.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Shift 'TK_LT', go to state 45
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop TK_WHILE comparison TK_LT]
Parser(B) >> Input 'TK_INTEGER' in state 45
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop TK_WHILE comparison TK_LT TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 45.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 45.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 45.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 45.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 45.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 45.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 45.
Parser(B) >> ... then shift 'concatenation', go to state 57
Parser(B) >> Reduce 215 [comparison ::= comparison TK_LT concatenation], pop back to state 29.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 29.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 29.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 29.
Parser(B) >> ... then shift 'expression', go to state 397
Parser(B) >> Reduce 105 [docond ::= TK_WHILE expression], pop back to state 17.
Parser(B) >> ... then shift 'docond', go to state 395
Parser(B) >> Shift 'TK_EOC', go to state 5
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop docond TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 5
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop docond TK_EOC TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 5.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop docond TK_EOC var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 33
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop docond TK_EOC var_symbol TK_EQUAL TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_PLUS' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 33.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Shift 'TK_PLUS', go to state 64
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop docond TK_EOC var_symbol TK_EQUAL addition TK_PLUS]
Parser(B) >> Input 'TK_INTEGER' in state 64
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop docond TK_EOC var_symbol TK_EQUAL addition TK_PLUS TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 64.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 64.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 64.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 64.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 64.
Parser(B) >> ... then shift 'multiplication', go to state 240
Parser(B) >> Reduce 194 [addition ::= addition TK_PLUS multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 5.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 5.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop docond TK_EOC single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_IF' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 5.
Parser(B) >> ... then shift 'labeled_instruction', go to state 184
Parser(B) >> Reduce 33 [instruction_list ::= labeled_instruction], pop back to state 5.
Parser(B) >> ... then shift 'instruction_list', go to state 13
Parser(B) >> Shift 'TK_IF', go to state 30
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop docond TK_EOC instruction_list TK_IF]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 30
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop docond TK_EOC instruction_list TK_IF TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 30.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 30.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 30.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 30.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 30.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 30.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 30.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 30.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Shift 'TK_EQUAL', go to state 48
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop docond TK_EOC instruction_list TK_IF comparison TK_EQUAL]
Parser(B) >> Input 'TK_INTEGER' in state 48
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop docond TK_EOC instruction_list TK_IF comparison TK_EQUAL TK_INTEGER]
Parser(B) >> Input 'TK_THEN' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 48.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 48.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 48.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 48.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 48.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 48.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 48.
Parser(B) >> ... then shift 'concatenation', go to state 60
Parser(B) >> Reduce 212 [comparison ::= comparison TK_EQUAL concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 30.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 30.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 30.
Parser(B) >> ... then shift 'expression', go to state 127
Parser(B) >> Reduce 254 [ncl0 ::=] without external action.
Parser(B) >> ... then shift 'ncl0', go to state 131
Parser(B) >> Shift 'TK_THEN', go to state 109
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop docond TK_EOC instruction_list TK_IF expression ncl0 TK_THEN]
Parser(B) >> Input 'TK_LEAVE' in state 109
Parser(B) >> Reduce 254 [ncl0 ::=] without external action.
Parser(B) >> ... then shift 'ncl0', go to state 15
Parser(B) >> Shift 'TK_LEAVE', go to state 117
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop docond TK_EOC instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_LEAVE]
Parser(B) >> Input 'TK_EOC' in state 117
Parser(B) >> Reduce 157 [leave ::= TK_LEAVE], pop back to state 15.
Parser(B) >> ... then shift 'leave', go to state 369
Parser(B) >> Reduce 56 [keyword_instruction ::= leave], pop back to state 15.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 15.
Parser(B) >> ... then shift 'single_instruction', go to state 100
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 404
Parser(B) >> Shift 'TK_EOC', go to state 181
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop docond TK_EOC instruction_list TK_IF expression ncl0 TK_THEN ncl0 single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 181
Parser(B) >> Reduce 42 [instruction ::= single_instruction junk TK_EOC], pop back to state 15.
Parser(B) >> ... then shift 'instruction', go to state 175
Parser(B) >> Reduce 110 [then ::= TK_THEN ncl0 instruction], pop back to state 131.
Parser(B) >> ... then shift 'then', go to state 108
Parser(B) >> Reduce 108 [if ::= TK_IF expression ncl0 then], pop back to state 13.
Parser(B) >> ... then shift 'if', go to state 185
Parser(B) >> Reduce 72 [group ::= if], pop back to state 13.
Parser(B) >> ... then shift 'group', go to state 193
Parser(B) >> Reduce 35 [labeled_instruction ::= group], pop back to state 13.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 5.
Parser(B) >> ... then shift 'instruction_list', go to state 13
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop docond TK_EOC instruction_list TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 13.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop docond TK_EOC instruction_list var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 33
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop docond TK_EOC instruction_list var_symbol TK_EQUAL TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_PLUS' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 33.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Shift 'TK_PLUS', go to state 64
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop docond TK_EOC instruction_list var_symbol TK_EQUAL addition TK_PLUS]
Parser(B) >> Input 'TK_INTEGER' in state 64
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop docond TK_EOC instruction_list var_symbol TK_EQUAL addition TK_PLUS TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 64.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 64.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 64.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 64.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 64.
Parser(B) >> ... then shift 'multiplication', go to state 240
Parser(B) >> Reduce 194 [addition ::= addition TK_PLUS multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 13.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 13.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop docond TK_EOC instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_END' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 13.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 5.
Parser(B) >> ... then shift 'instruction_list', go to state 13
Parser(B) >> Shift 'TK_END', go to state 123
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop docond TK_EOC instruction_list TK_END]
Parser(B) >> Input 'TK_EOC' in state 123
Parser(B) >> Reduce 86 [do ::= tk_doloop docond TK_EOC instruction_list TK_END], pop back to state 8.
Parser(B) >> ... then shift 'do', go to state 101
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 405
Parser(B) >> Shift 'TK_EOC', go to state 186
Parser(B) >> Return. Stack=[rexx_options instruction_list do junk TK_EOC]
Parser(B) >> Input 'TK_IF' in state 186
Parser(B) >> Reduce 71 [group ::= do junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'group', go to state 193
Parser(B) >> Reduce 35 [labeled_instruction ::= group], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_IF', go to state 30
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 30
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_NEQ' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 30.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 30.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 30.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 30.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 30.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 30.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 30.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 30.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Shift 'TK_NEQ', go to state 47
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ]
Parser(B) >> Input 'TK_INTEGER' in state 47
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ TK_INTEGER]
Parser(B) >> Input 'TK_THEN' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 47.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 47.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 47.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 47.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 47.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 47.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 47.
Parser(B) >> ... then shift 'concatenation', go to state 59
Parser(B) >> Reduce 213 [comparison ::= comparison TK_NEQ concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 30.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 30.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 30.
Parser(B) >> ... then shift 'expression', go to state 127
Parser(B) >> Reduce 254 [ncl0 ::=] without external action.
Parser(B) >> ... then shift 'ncl0', go to state 131
Parser(B) >> Shift 'TK_THEN', go to state 109
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN]
Parser(B) >> Input 'TK_DO' in state 109
Parser(B) >> Reduce 254 [ncl0 ::=] without external action.
Parser(B) >> ... then shift 'ncl0', go to state 15
Parser(B) >> Shift 'TK_DO', go to state 113
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO]
Parser(B) >> Input 'TK_EOC' in state 113
Parser(B) >> Shift 'TK_EOC', go to state 7
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 7
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 7.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 33
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_PLUS' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 33.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Shift 'TK_PLUS', go to state 64
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL addition TK_PLUS]
Parser(B) >> Input 'TK_INTEGER' in state 64
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL addition TK_PLUS TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 64.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 64.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 64.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 64.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 64.
Parser(B) >> ... then shift 'multiplication', go to state 240
Parser(B) >> Reduce 194 [addition ::= addition TK_PLUS multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 7.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 7.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_SAY' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 7.
Parser(B) >> ... then shift 'labeled_instruction', go to state 184
Parser(B) >> Reduce 33 [instruction_list ::= labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_SAY', go to state 22
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_SAY]
Parser(B) >> Input 'TK_STRING' in state 22
Parser(B) >> Shift 'TK_STRING', go to state 111
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_SAY TK_STRING]
Parser(B) >> Input 'TK_EOC' in state 111
Parser(B) >> Reduce 179 [term ::= TK_STRING], pop back to state 22.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 22.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 22.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 22.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 22.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 22.
Parser(B) >> ... then shift 'expression', go to state 331
Parser(B) >> Reduce 160 [say ::= TK_SAY expression], pop back to state 10.
Parser(B) >> ... then shift 'say', go to state 365
Parser(B) >> Reduce 60 [keyword_instruction ::= say], pop back to state 10.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 10.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_END' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 10.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_END', go to state 129
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_END]
Parser(B) >> Input 'TK_EOC' in state 129
Parser(B) >> Reduce 73 [simple_do ::= TK_DO TK_EOC instruction_list TK_END], pop back to state 15.
Parser(B) >> ... then shift 'simple_do', go to state 102
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 406
Parser(B) >> Shift 'TK_EOC', go to state 187
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 simple_do junk TK_EOC]
Parser(B) >> Input 'TK_IF' in state 187
Parser(B) >> Reduce 70 [group ::= simple_do junk TK_EOC], pop back to state 15.
Parser(B) >> ... then shift 'group', go to state 182
Parser(B) >> Reduce 41 [instruction ::= group], pop back to state 15.
Parser(B) >> ... then shift 'instruction', go to state 175
Parser(B) >> Reduce 110 [then ::= TK_THEN ncl0 instruction], pop back to state 131.
Parser(B) >> ... then shift 'then', go to state 108
Parser(B) >> Reduce 108 [if ::= TK_IF expression ncl0 then], pop back to state 8.
Parser(B) >> ... then shift 'if', go to state 185
Parser(B) >> Reduce 72 [group ::= if], pop back to state 8.
Parser(B) >> ... then shift 'group', go to state 193
Parser(B) >> Reduce 35 [labeled_instruction ::= group], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_IF', go to state 30
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 30
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_NEQ' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 30.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 30.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 30.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 30.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 30.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 30.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 30.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 30.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Shift 'TK_NEQ', go to state 47
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ]
Parser(B) >> Input 'TK_INTEGER' in state 47
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ TK_INTEGER]
Parser(B) >> Input 'TK_THEN' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 47.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 47.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 47.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 47.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 47.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 47.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 47.
Parser(B) >> ... then shift 'concatenation', go to state 59
Parser(B) >> Reduce 213 [comparison ::= comparison TK_NEQ concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 30.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 30.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 30.
Parser(B) >> ... then shift 'expression', go to state 127
Parser(B) >> Reduce 254 [ncl0 ::=] without external action.
Parser(B) >> ... then shift 'ncl0', go to state 131
Parser(B) >> Shift 'TK_THEN', go to state 109
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN]
Parser(B) >> Input 'TK_DO' in state 109
Parser(B) >> Reduce 254 [ncl0 ::=] without external action.
Parser(B) >> ... then shift 'ncl0', go to state 15
Parser(B) >> Shift 'TK_DO', go to state 113
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO]
Parser(B) >> Input 'TK_EOC' in state 113
Parser(B) >> Shift 'TK_EOC', go to state 7
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 7
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 7.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 33
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_PLUS' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 33.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Shift 'TK_PLUS', go to state 64
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL addition TK_PLUS]
Parser(B) >> Input 'TK_INTEGER' in state 64
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL addition TK_PLUS TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 64.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 64.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 64.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 64.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 64.
Parser(B) >> ... then shift 'multiplication', go to state 240
Parser(B) >> Reduce 194 [addition ::= addition TK_PLUS multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 7.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 7.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_SAY' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 7.
Parser(B) >> ... then shift 'labeled_instruction', go to state 184
Parser(B) >> Reduce 33 [instruction_list ::= labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_SAY', go to state 22
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_SAY]
Parser(B) >> Input 'TK_STRING' in state 22
Parser(B) >> Shift 'TK_STRING', go to state 111
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_SAY TK_STRING]
Parser(B) >> Input 'TK_EOC' in state 111
Parser(B) >> Reduce 179 [term ::= TK_STRING], pop back to state 22.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 22.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 22.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 22.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 22.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 22.
Parser(B) >> ... then shift 'expression', go to state 331
Parser(B) >> Reduce 160 [say ::= TK_SAY expression], pop back to state 10.
Parser(B) >> ... then shift 'say', go to state 365
Parser(B) >> Reduce 60 [keyword_instruction ::= say], pop back to state 10.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 10.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_END' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 10.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_END', go to state 129
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_END]
Parser(B) >> Input 'TK_EOC' in state 129
Parser(B) >> Reduce 73 [simple_do ::= TK_DO TK_EOC instruction_list TK_END], pop back to state 15.
Parser(B) >> ... then shift 'simple_do', go to state 102
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 406
Parser(B) >> Shift 'TK_EOC', go to state 187
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 simple_do junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 187
Parser(B) >> Reduce 70 [group ::= simple_do junk TK_EOC], pop back to state 15.
Parser(B) >> ... then shift 'group', go to state 182
Parser(B) >> Reduce 41 [instruction ::= group], pop back to state 15.
Parser(B) >> ... then shift 'instruction', go to state 175
Parser(B) >> Reduce 110 [then ::= TK_THEN ncl0 instruction], pop back to state 131.
Parser(B) >> ... then shift 'then', go to state 108
Parser(B) >> Reduce 108 [if ::= TK_IF expression ncl0 then], pop back to state 8.
Parser(B) >> ... then shift 'if', go to state 185
Parser(B) >> Reduce 72 [group ::= if], pop back to state 8.
Parser(B) >> ... then shift 'group', go to state 193
Parser(B) >> Reduce 35 [labeled_instruction ::= group], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 8.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_INTEGER' in state 33
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 8.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 8.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_STRING' in state 33
Parser(B) >> Shift 'TK_STRING', go to state 111
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL TK_STRING]
Parser(B) >> Input 'TK_EOC' in state 111
Parser(B) >> Reduce 179 [term ::= TK_STRING], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 8.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 8.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_STRING' in state 33
Parser(B) >> Shift 'TK_STRING', go to state 111
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL TK_STRING]
Parser(B) >> Input 'TK_EOC' in state 111
Parser(B) >> Reduce 179 [term ::= TK_STRING], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 8.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_DO' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_DO', go to state 113
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_DO]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 113
Parser(B) >> Reduce 80 [tk_doloop ::= TK_DO], pop back to state 8.
Parser(B) >> ... then shift 'tk_doloop', go to state 17
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 17.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_INTEGER' in state 33
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop var_symbol TK_EQUAL TK_INTEGER]
Parser(B) >> Input 'TK_TO' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 17.
Parser(B) >> ... then shift 'assignment', go to state 86
Parser(B) >> Shift 'TK_TO', go to state 27
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop assignment TK_TO]
Parser(B) >> Input 'TK_INTEGER' in state 27
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop assignment TK_TO TK_INTEGER]
Parser(B) >> Input 'TK_BY' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 27.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 27.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 27.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 27.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 27.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 27.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 27.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 27.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 27.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 27.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 27.
Parser(B) >> ... then shift 'expression', go to state 286
Parser(B) >> Reduce 101 [dorep_item ::= TK_TO expression], pop back to state 86.
Parser(B) >> ... then shift 'dorep_item', go to state 283
Parser(B) >> Reduce 99 [dorep_list ::= dorep_item], pop back to state 86.
Parser(B) >> ... then shift 'dorep_list', go to state 114
Parser(B) >> Shift 'TK_BY', go to state 26
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop assignment dorep_list TK_BY]
Parser(B) >> Input 'TK_INTEGER' in state 26
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop assignment dorep_list TK_BY TK_INTEGER]
Parser(B) >> Input 'TK_WHILE' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 26.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 26.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 26.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 26.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 26.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 26.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 26.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 26.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 26.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 26.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 26.
Parser(B) >> ... then shift 'expression', go to state 285
Parser(B) >> Reduce 102 [dorep_item ::= TK_BY expression], pop back to state 114.
Parser(B) >> ... then shift 'dorep_item', go to state 287
Parser(B) >> Reduce 100 [dorep_list ::= dorep_list dorep_item], pop back to state 86.
Parser(B) >> ... then shift 'dorep_list', go to state 114
Parser(B) >> Reduce 98 [dorep ::= assignment dorep_list], pop back to state 17.
Parser(B) >> ... then shift 'dorep', go to state 96
Parser(B) >> Shift 'TK_WHILE', go to state 29
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_WHILE]
Parser(B) >> Input 'TK_OPEN_BRACKET' in state 29
Parser(B) >> Shift 'TK_OPEN_BRACKET', go to state 34
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_WHILE TK_OPEN_BRACKET]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 34
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_WHILE TK_OPEN_BRACKET TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_LTE' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 34.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 34.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 34.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 34.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 34.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 34.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 34.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 34.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 34.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Shift 'TK_LTE', go to state 43
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_WHILE TK_OPEN_BRACKET comparison TK_LTE]
Parser(B) >> Input 'TK_INTEGER' in state 43
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_WHILE TK_OPEN_BRACKET comparison TK_LTE TK_INTEGER]
Parser(B) >> Input 'TK_CLOSE_BRACKET' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 43.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 43.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 43.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 43.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 43.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 43.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 43.
Parser(B) >> ... then shift 'concatenation', go to state 55
Parser(B) >> Reduce 217 [comparison ::= comparison TK_LTE concatenation], pop back to state 34.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 34.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 34.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 34.
Parser(B) >> ... then shift 'expression', go to state 408
Parser(B) >> Shift 'TK_CLOSE_BRACKET', go to state 228
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_WHILE TK_OPEN_BRACKET expression TK_CLOSE_BRACKET]
Parser(B) >> Input 'TK_EOC' in state 228
Parser(B) >> Reduce 181 [bracket ::= TK_OPEN_BRACKET expression TK_CLOSE_BRACKET], pop back to state 29.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 29.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 29.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 29.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 29.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 29.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 29.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 29.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 29.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 29.
Parser(B) >> ... then shift 'expression', go to state 397
Parser(B) >> Reduce 105 [docond ::= TK_WHILE expression], pop back to state 96.
Parser(B) >> ... then shift 'docond', go to state 398
Parser(B) >> Shift 'TK_EOC', go to state 6
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep docond TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 6
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep docond TK_EOC TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 6.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep docond TK_EOC var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 33
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep docond TK_EOC var_symbol TK_EQUAL TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_PLUS' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 33.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Shift 'TK_PLUS', go to state 64
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep docond TK_EOC var_symbol TK_EQUAL addition TK_PLUS]
Parser(B) >> Input 'TK_INTEGER' in state 64
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep docond TK_EOC var_symbol TK_EQUAL addition TK_PLUS TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 64.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 64.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 64.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 64.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 64.
Parser(B) >> ... then shift 'multiplication', go to state 240
Parser(B) >> Reduce 194 [addition ::= addition TK_PLUS multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 6.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 6.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep docond TK_EOC single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_END' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 6.
Parser(B) >> ... then shift 'labeled_instruction', go to state 184
Parser(B) >> Reduce 33 [instruction_list ::= labeled_instruction], pop back to state 6.
Parser(B) >> ... then shift 'instruction_list', go to state 14
Parser(B) >> Shift 'TK_END', go to state 125
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep docond TK_EOC instruction_list TK_END]
Parser(B) >> Input 'TK_EOC' in state 125
Parser(B) >> Reduce 84 [do ::= tk_doloop dorep docond TK_EOC instruction_list TK_END], pop back to state 8.
Parser(B) >> ... then shift 'do', go to state 101
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 405
Parser(B) >> Shift 'TK_EOC', go to state 186
Parser(B) >> Return. Stack=[rexx_options instruction_list do junk TK_EOC]
Parser(B) >> Input 'TK_IF' in state 186
Parser(B) >> Reduce 71 [group ::= do junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'group', go to state 193
Parser(B) >> Reduce 35 [labeled_instruction ::= group], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_IF', go to state 30
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 30
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_NEQ' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 30.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 30.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 30.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 30.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 30.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 30.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 30.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 30.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Shift 'TK_NEQ', go to state 47
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ]
Parser(B) >> Input 'TK_INTEGER' in state 47
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ TK_INTEGER]
Parser(B) >> Input 'TK_THEN' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 47.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 47.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 47.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 47.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 47.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 47.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 47.
Parser(B) >> ... then shift 'concatenation', go to state 59
Parser(B) >> Reduce 213 [comparison ::= comparison TK_NEQ concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 30.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 30.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 30.
Parser(B) >> ... then shift 'expression', go to state 127
Parser(B) >> Reduce 254 [ncl0 ::=] without external action.
Parser(B) >> ... then shift 'ncl0', go to state 131
Parser(B) >> Shift 'TK_THEN', go to state 109
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN]
Parser(B) >> Input 'TK_DO' in state 109
Parser(B) >> Reduce 254 [ncl0 ::=] without external action.
Parser(B) >> ... then shift 'ncl0', go to state 15
Parser(B) >> Shift 'TK_DO', go to state 113
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO]
Parser(B) >> Input 'TK_EOC' in state 113
Parser(B) >> Shift 'TK_EOC', go to state 7
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 7
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 7.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 33
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_PLUS' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 33.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Shift 'TK_PLUS', go to state 64
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL addition TK_PLUS]
Parser(B) >> Input 'TK_INTEGER' in state 64
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL addition TK_PLUS TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 64.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 64.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 64.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 64.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 64.
Parser(B) >> ... then shift 'multiplication', go to state 240
Parser(B) >> Reduce 194 [addition ::= addition TK_PLUS multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 7.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 7.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_SAY' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 7.
Parser(B) >> ... then shift 'labeled_instruction', go to state 184
Parser(B) >> Reduce 33 [instruction_list ::= labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_SAY', go to state 22
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_SAY]
Parser(B) >> Input 'TK_STRING' in state 22
Parser(B) >> Shift 'TK_STRING', go to state 111
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_SAY TK_STRING]
Parser(B) >> Input 'TK_EOC' in state 111
Parser(B) >> Reduce 179 [term ::= TK_STRING], pop back to state 22.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 22.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 22.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 22.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 22.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 22.
Parser(B) >> ... then shift 'expression', go to state 331
Parser(B) >> Reduce 160 [say ::= TK_SAY expression], pop back to state 10.
Parser(B) >> ... then shift 'say', go to state 365
Parser(B) >> Reduce 60 [keyword_instruction ::= say], pop back to state 10.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 10.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_END' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 10.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_END', go to state 129
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_END]
Parser(B) >> Input 'TK_EOC' in state 129
Parser(B) >> Reduce 73 [simple_do ::= TK_DO TK_EOC instruction_list TK_END], pop back to state 15.
Parser(B) >> ... then shift 'simple_do', go to state 102
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 406
Parser(B) >> Shift 'TK_EOC', go to state 187
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 simple_do junk TK_EOC]
Parser(B) >> Input 'TK_IF' in state 187
Parser(B) >> Reduce 70 [group ::= simple_do junk TK_EOC], pop back to state 15.
Parser(B) >> ... then shift 'group', go to state 182
Parser(B) >> Reduce 41 [instruction ::= group], pop back to state 15.
Parser(B) >> ... then shift 'instruction', go to state 175
Parser(B) >> Reduce 110 [then ::= TK_THEN ncl0 instruction], pop back to state 131.
Parser(B) >> ... then shift 'then', go to state 108
Parser(B) >> Reduce 108 [if ::= TK_IF expression ncl0 then], pop back to state 8.
Parser(B) >> ... then shift 'if', go to state 185
Parser(B) >> Reduce 72 [group ::= if], pop back to state 8.
Parser(B) >> ... then shift 'group', go to state 193
Parser(B) >> Reduce 35 [labeled_instruction ::= group], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_IF', go to state 30
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 30
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_NEQ' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 30.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 30.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 30.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 30.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 30.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 30.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 30.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 30.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Shift 'TK_NEQ', go to state 47
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ]
Parser(B) >> Input 'TK_INTEGER' in state 47
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ TK_INTEGER]
Parser(B) >> Input 'TK_THEN' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 47.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 47.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 47.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 47.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 47.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 47.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 47.
Parser(B) >> ... then shift 'concatenation', go to state 59
Parser(B) >> Reduce 213 [comparison ::= comparison TK_NEQ concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 30.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 30.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 30.
Parser(B) >> ... then shift 'expression', go to state 127
Parser(B) >> Reduce 254 [ncl0 ::=] without external action.
Parser(B) >> ... then shift 'ncl0', go to state 131
Parser(B) >> Shift 'TK_THEN', go to state 109
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN]
Parser(B) >> Input 'TK_DO' in state 109
Parser(B) >> Reduce 254 [ncl0 ::=] without external action.
Parser(B) >> ... then shift 'ncl0', go to state 15
Parser(B) >> Shift 'TK_DO', go to state 113
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO]
Parser(B) >> Input 'TK_EOC' in state 113
Parser(B) >> Shift 'TK_EOC', go to state 7
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 7
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 7.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 33
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_PLUS' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 33.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Shift 'TK_PLUS', go to state 64
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL addition TK_PLUS]
Parser(B) >> Input 'TK_INTEGER' in state 64
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL addition TK_PLUS TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 64.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 64.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 64.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 64.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 64.
Parser(B) >> ... then shift 'multiplication', go to state 240
Parser(B) >> Reduce 194 [addition ::= addition TK_PLUS multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 7.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 7.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_SAY' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 7.
Parser(B) >> ... then shift 'labeled_instruction', go to state 184
Parser(B) >> Reduce 33 [instruction_list ::= labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_SAY', go to state 22
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_SAY]
Parser(B) >> Input 'TK_STRING' in state 22
Parser(B) >> Shift 'TK_STRING', go to state 111
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_SAY TK_STRING]
Parser(B) >> Input 'TK_EOC' in state 111
Parser(B) >> Reduce 179 [term ::= TK_STRING], pop back to state 22.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 22.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 22.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 22.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 22.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 22.
Parser(B) >> ... then shift 'expression', go to state 331
Parser(B) >> Reduce 160 [say ::= TK_SAY expression], pop back to state 10.
Parser(B) >> ... then shift 'say', go to state 365
Parser(B) >> Reduce 60 [keyword_instruction ::= say], pop back to state 10.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 10.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_END' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 10.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_END', go to state 129
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_END]
Parser(B) >> Input 'TK_EOC' in state 129
Parser(B) >> Reduce 73 [simple_do ::= TK_DO TK_EOC instruction_list TK_END], pop back to state 15.
Parser(B) >> ... then shift 'simple_do', go to state 102
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 406
Parser(B) >> Shift 'TK_EOC', go to state 187
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 simple_do junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 187
Parser(B) >> Reduce 70 [group ::= simple_do junk TK_EOC], pop back to state 15.
Parser(B) >> ... then shift 'group', go to state 182
Parser(B) >> Reduce 41 [instruction ::= group], pop back to state 15.
Parser(B) >> ... then shift 'instruction', go to state 175
Parser(B) >> Reduce 110 [then ::= TK_THEN ncl0 instruction], pop back to state 131.
Parser(B) >> ... then shift 'then', go to state 108
Parser(B) >> Reduce 108 [if ::= TK_IF expression ncl0 then], pop back to state 8.
Parser(B) >> ... then shift 'if', go to state 185
Parser(B) >> Reduce 72 [group ::= if], pop back to state 8.
Parser(B) >> ... then shift 'group', go to state 193
Parser(B) >> Reduce 35 [labeled_instruction ::= group], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 8.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_INTEGER' in state 33
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 8.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 8.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_INTEGER' in state 33
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 8.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_DO' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_DO', go to state 113
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_DO]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 113
Parser(B) >> Reduce 80 [tk_doloop ::= TK_DO], pop back to state 8.
Parser(B) >> ... then shift 'tk_doloop', go to state 17
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 17.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_INTEGER' in state 33
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop var_symbol TK_EQUAL TK_INTEGER]
Parser(B) >> Input 'TK_MINUS' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Shift 'TK_MINUS', go to state 63
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop var_symbol TK_EQUAL addition TK_MINUS]
Parser(B) >> Input 'TK_INTEGER' in state 63
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop var_symbol TK_EQUAL addition TK_MINUS TK_INTEGER]
Parser(B) >> Input 'TK_TO' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 63.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 63.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 63.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 63.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 63.
Parser(B) >> ... then shift 'multiplication', go to state 239
Parser(B) >> Reduce 195 [addition ::= addition TK_MINUS multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 17.
Parser(B) >> ... then shift 'assignment', go to state 86
Parser(B) >> Shift 'TK_TO', go to state 27
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop assignment TK_TO]
Parser(B) >> Input 'TK_OPEN_BRACKET' in state 27
Parser(B) >> Shift 'TK_OPEN_BRACKET', go to state 34
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop assignment TK_TO TK_OPEN_BRACKET]
Parser(B) >> Input 'TK_INTEGER' in state 34
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop assignment TK_TO TK_OPEN_BRACKET TK_INTEGER]
Parser(B) >> Input 'TK_MINUS' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 34.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 34.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 34.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 34.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 34.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 34.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Shift 'TK_MINUS', go to state 63
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop assignment TK_TO TK_OPEN_BRACKET addition TK_MINUS]
Parser(B) >> Input 'TK_INTEGER' in state 63
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop assignment TK_TO TK_OPEN_BRACKET addition TK_MINUS TK_INTEGER]
Parser(B) >> Input 'TK_CLOSE_BRACKET' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 63.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 63.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 63.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 63.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 63.
Parser(B) >> ... then shift 'multiplication', go to state 239
Parser(B) >> Reduce 195 [addition ::= addition TK_MINUS multiplication], pop back to state 34.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 34.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 34.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 34.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 34.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 34.
Parser(B) >> ... then shift 'expression', go to state 408
Parser(B) >> Shift 'TK_CLOSE_BRACKET', go to state 228
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop assignment TK_TO TK_OPEN_BRACKET expression TK_CLOSE_BRACKET]
Parser(B) >> Input 'TK_BY' in state 228
Parser(B) >> Reduce 181 [bracket ::= TK_OPEN_BRACKET expression TK_CLOSE_BRACKET], pop back to state 27.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 27.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 27.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 27.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 27.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 27.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 27.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 27.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 27.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 27.
Parser(B) >> ... then shift 'expression', go to state 286
Parser(B) >> Reduce 101 [dorep_item ::= TK_TO expression], pop back to state 86.
Parser(B) >> ... then shift 'dorep_item', go to state 283
Parser(B) >> Reduce 99 [dorep_list ::= dorep_item], pop back to state 86.
Parser(B) >> ... then shift 'dorep_list', go to state 114
Parser(B) >> Shift 'TK_BY', go to state 26
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop assignment dorep_list TK_BY]
Parser(B) >> Input 'TK_INTEGER' in state 26
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop assignment dorep_list TK_BY TK_INTEGER]
Parser(B) >> Input 'TK_MINUS' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 26.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 26.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 26.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 26.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 26.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 26.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Shift 'TK_MINUS', go to state 63
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop assignment dorep_list TK_BY addition TK_MINUS]
Parser(B) >> Input 'TK_INTEGER' in state 63
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop assignment dorep_list TK_BY addition TK_MINUS TK_INTEGER]
Parser(B) >> Input 'TK_UNTIL' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 63.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 63.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 63.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 63.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 63.
Parser(B) >> ... then shift 'multiplication', go to state 239
Parser(B) >> Reduce 195 [addition ::= addition TK_MINUS multiplication], pop back to state 26.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 26.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 26.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 26.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 26.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 26.
Parser(B) >> ... then shift 'expression', go to state 285
Parser(B) >> Reduce 102 [dorep_item ::= TK_BY expression], pop back to state 114.
Parser(B) >> ... then shift 'dorep_item', go to state 287
Parser(B) >> Reduce 100 [dorep_list ::= dorep_list dorep_item], pop back to state 86.
Parser(B) >> ... then shift 'dorep_list', go to state 114
Parser(B) >> Reduce 98 [dorep ::= assignment dorep_list], pop back to state 17.
Parser(B) >> ... then shift 'dorep', go to state 96
Parser(B) >> Shift 'TK_UNTIL', go to state 28
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_UNTIL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 28
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_UNTIL TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_LT' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 28.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 28.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 28.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 28.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 28.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 28.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 28.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 28.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 28.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Shift 'TK_LT', go to state 45
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_UNTIL comparison TK_LT]
Parser(B) >> Input 'TK_MINUS' in state 45
Parser(B) >> Shift 'TK_MINUS', go to state 76
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_UNTIL comparison TK_LT TK_MINUS]
Parser(B) >> Input 'TK_INTEGER' in state 76
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_UNTIL comparison TK_LT TK_MINUS TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 76.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 76.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 76.
Parser(B) >> ... then shift 'prefix_expression', go to state 224
Parser(B) >> Reduce 185 [prefix_expression ::= TK_MINUS prefix_expression], pop back to state 45.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 45.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 45.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 45.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 45.
Parser(B) >> ... then shift 'concatenation', go to state 57
Parser(B) >> Reduce 215 [comparison ::= comparison TK_LT concatenation], pop back to state 28.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 28.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 28.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 28.
Parser(B) >> ... then shift 'expression', go to state 396
Parser(B) >> Reduce 106 [docond ::= TK_UNTIL expression], pop back to state 96.
Parser(B) >> ... then shift 'docond', go to state 398
Parser(B) >> Shift 'TK_EOC', go to state 6
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep docond TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 6
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep docond TK_EOC TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 6.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep docond TK_EOC var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 33
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep docond TK_EOC var_symbol TK_EQUAL TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_PLUS' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 33.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Shift 'TK_PLUS', go to state 64
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep docond TK_EOC var_symbol TK_EQUAL addition TK_PLUS]
Parser(B) >> Input 'TK_INTEGER' in state 64
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep docond TK_EOC var_symbol TK_EQUAL addition TK_PLUS TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 64.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 64.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 64.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 64.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 64.
Parser(B) >> ... then shift 'multiplication', go to state 240
Parser(B) >> Reduce 194 [addition ::= addition TK_PLUS multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 6.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 6.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep docond TK_EOC single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_END' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 6.
Parser(B) >> ... then shift 'labeled_instruction', go to state 184
Parser(B) >> Reduce 33 [instruction_list ::= labeled_instruction], pop back to state 6.
Parser(B) >> ... then shift 'instruction_list', go to state 14
Parser(B) >> Shift 'TK_END', go to state 125
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep docond TK_EOC instruction_list TK_END]
Parser(B) >> Input 'TK_EOC' in state 125
Parser(B) >> Reduce 84 [do ::= tk_doloop dorep docond TK_EOC instruction_list TK_END], pop back to state 8.
Parser(B) >> ... then shift 'do', go to state 101
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 405
Parser(B) >> Shift 'TK_EOC', go to state 186
Parser(B) >> Return. Stack=[rexx_options instruction_list do junk TK_EOC]
Parser(B) >> Input 'TK_IF' in state 186
Parser(B) >> Reduce 71 [group ::= do junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'group', go to state 193
Parser(B) >> Reduce 35 [labeled_instruction ::= group], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_IF', go to state 30
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 30
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_NEQ' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 30.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 30.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 30.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 30.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 30.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 30.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 30.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 30.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Shift 'TK_NEQ', go to state 47
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ]
Parser(B) >> Input 'TK_MINUS' in state 47
Parser(B) >> Shift 'TK_MINUS', go to state 76
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ TK_MINUS]
Parser(B) >> Input 'TK_INTEGER' in state 76
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ TK_MINUS TK_INTEGER]
Parser(B) >> Input 'TK_THEN' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 76.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 76.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 76.
Parser(B) >> ... then shift 'prefix_expression', go to state 224
Parser(B) >> Reduce 185 [prefix_expression ::= TK_MINUS prefix_expression], pop back to state 47.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 47.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 47.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 47.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 47.
Parser(B) >> ... then shift 'concatenation', go to state 59
Parser(B) >> Reduce 213 [comparison ::= comparison TK_NEQ concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 30.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 30.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 30.
Parser(B) >> ... then shift 'expression', go to state 127
Parser(B) >> Reduce 254 [ncl0 ::=] without external action.
Parser(B) >> ... then shift 'ncl0', go to state 131
Parser(B) >> Shift 'TK_THEN', go to state 109
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN]
Parser(B) >> Input 'TK_DO' in state 109
Parser(B) >> Reduce 254 [ncl0 ::=] without external action.
Parser(B) >> ... then shift 'ncl0', go to state 15
Parser(B) >> Shift 'TK_DO', go to state 113
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO]
Parser(B) >> Input 'TK_EOC' in state 113
Parser(B) >> Shift 'TK_EOC', go to state 7
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 7
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 7.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 33
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_PLUS' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 33.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Shift 'TK_PLUS', go to state 64
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL addition TK_PLUS]
Parser(B) >> Input 'TK_INTEGER' in state 64
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL addition TK_PLUS TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 64.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 64.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 64.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 64.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 64.
Parser(B) >> ... then shift 'multiplication', go to state 240
Parser(B) >> Reduce 194 [addition ::= addition TK_PLUS multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 7.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 7.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_SAY' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 7.
Parser(B) >> ... then shift 'labeled_instruction', go to state 184
Parser(B) >> Reduce 33 [instruction_list ::= labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_SAY', go to state 22
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_SAY]
Parser(B) >> Input 'TK_STRING' in state 22
Parser(B) >> Shift 'TK_STRING', go to state 111
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_SAY TK_STRING]
Parser(B) >> Input 'TK_EOC' in state 111
Parser(B) >> Reduce 179 [term ::= TK_STRING], pop back to state 22.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 22.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 22.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 22.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 22.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 22.
Parser(B) >> ... then shift 'expression', go to state 331
Parser(B) >> Reduce 160 [say ::= TK_SAY expression], pop back to state 10.
Parser(B) >> ... then shift 'say', go to state 365
Parser(B) >> Reduce 60 [keyword_instruction ::= say], pop back to state 10.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 10.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_END' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 10.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_END', go to state 129
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_END]
Parser(B) >> Input 'TK_EOC' in state 129
Parser(B) >> Reduce 73 [simple_do ::= TK_DO TK_EOC instruction_list TK_END], pop back to state 15.
Parser(B) >> ... then shift 'simple_do', go to state 102
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 406
Parser(B) >> Shift 'TK_EOC', go to state 187
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 simple_do junk TK_EOC]
Parser(B) >> Input 'TK_IF' in state 187
Parser(B) >> Reduce 70 [group ::= simple_do junk TK_EOC], pop back to state 15.
Parser(B) >> ... then shift 'group', go to state 182
Parser(B) >> Reduce 41 [instruction ::= group], pop back to state 15.
Parser(B) >> ... then shift 'instruction', go to state 175
Parser(B) >> Reduce 110 [then ::= TK_THEN ncl0 instruction], pop back to state 131.
Parser(B) >> ... then shift 'then', go to state 108
Parser(B) >> Reduce 108 [if ::= TK_IF expression ncl0 then], pop back to state 8.
Parser(B) >> ... then shift 'if', go to state 185
Parser(B) >> Reduce 72 [group ::= if], pop back to state 8.
Parser(B) >> ... then shift 'group', go to state 193
Parser(B) >> Reduce 35 [labeled_instruction ::= group], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_IF', go to state 30
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 30
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_NEQ' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 30.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 30.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 30.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 30.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 30.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 30.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 30.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 30.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Shift 'TK_NEQ', go to state 47
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ]
Parser(B) >> Input 'TK_INTEGER' in state 47
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ TK_INTEGER]
Parser(B) >> Input 'TK_THEN' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 47.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 47.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 47.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 47.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 47.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 47.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 47.
Parser(B) >> ... then shift 'concatenation', go to state 59
Parser(B) >> Reduce 213 [comparison ::= comparison TK_NEQ concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 30.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 30.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 30.
Parser(B) >> ... then shift 'expression', go to state 127
Parser(B) >> Reduce 254 [ncl0 ::=] without external action.
Parser(B) >> ... then shift 'ncl0', go to state 131
Parser(B) >> Shift 'TK_THEN', go to state 109
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN]
Parser(B) >> Input 'TK_DO' in state 109
Parser(B) >> Reduce 254 [ncl0 ::=] without external action.
Parser(B) >> ... then shift 'ncl0', go to state 15
Parser(B) >> Shift 'TK_DO', go to state 113
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO]
Parser(B) >> Input 'TK_EOC' in state 113
Parser(B) >> Shift 'TK_EOC', go to state 7
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 7
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 7.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 33
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_PLUS' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 33.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Shift 'TK_PLUS', go to state 64
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL addition TK_PLUS]
Parser(B) >> Input 'TK_INTEGER' in state 64
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL addition TK_PLUS TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 64.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 64.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 64.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 64.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 64.
Parser(B) >> ... then shift 'multiplication', go to state 240
Parser(B) >> Reduce 194 [addition ::= addition TK_PLUS multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 7.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 7.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_SAY' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 7.
Parser(B) >> ... then shift 'labeled_instruction', go to state 184
Parser(B) >> Reduce 33 [instruction_list ::= labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_SAY', go to state 22
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_SAY]
Parser(B) >> Input 'TK_STRING' in state 22
Parser(B) >> Shift 'TK_STRING', go to state 111
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_SAY TK_STRING]
Parser(B) >> Input 'TK_EOC' in state 111
Parser(B) >> Reduce 179 [term ::= TK_STRING], pop back to state 22.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 22.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 22.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 22.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 22.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 22.
Parser(B) >> ... then shift 'expression', go to state 331
Parser(B) >> Reduce 160 [say ::= TK_SAY expression], pop back to state 10.
Parser(B) >> ... then shift 'say', go to state 365
Parser(B) >> Reduce 60 [keyword_instruction ::= say], pop back to state 10.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 10.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_END' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 10.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_END', go to state 129
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_END]
Parser(B) >> Input 'TK_EOC' in state 129
Parser(B) >> Reduce 73 [simple_do ::= TK_DO TK_EOC instruction_list TK_END], pop back to state 15.
Parser(B) >> ... then shift 'simple_do', go to state 102
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 406
Parser(B) >> Shift 'TK_EOC', go to state 187
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 simple_do junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 187
Parser(B) >> Reduce 70 [group ::= simple_do junk TK_EOC], pop back to state 15.
Parser(B) >> ... then shift 'group', go to state 182
Parser(B) >> Reduce 41 [instruction ::= group], pop back to state 15.
Parser(B) >> ... then shift 'instruction', go to state 175
Parser(B) >> Reduce 110 [then ::= TK_THEN ncl0 instruction], pop back to state 131.
Parser(B) >> ... then shift 'then', go to state 108
Parser(B) >> Reduce 108 [if ::= TK_IF expression ncl0 then], pop back to state 8.
Parser(B) >> ... then shift 'if', go to state 185
Parser(B) >> Reduce 72 [group ::= if], pop back to state 8.
Parser(B) >> ... then shift 'group', go to state 193
Parser(B) >> Reduce 35 [labeled_instruction ::= group], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 8.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_INTEGER' in state 33
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 8.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 8.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_INTEGER' in state 33
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 8.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_DO' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_DO', go to state 113
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_DO]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 113
Parser(B) >> Reduce 80 [tk_doloop ::= TK_DO], pop back to state 8.
Parser(B) >> ... then shift 'tk_doloop', go to state 17
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 17.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_INTEGER' in state 33
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop var_symbol TK_EQUAL TK_INTEGER]
Parser(B) >> Input 'TK_TO' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 17.
Parser(B) >> ... then shift 'assignment', go to state 86
Parser(B) >> Shift 'TK_TO', go to state 27
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop assignment TK_TO]
Parser(B) >> Input 'TK_INTEGER' in state 27
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop assignment TK_TO TK_INTEGER]
Parser(B) >> Input 'TK_UNTIL' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 27.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 27.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 27.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 27.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 27.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 27.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 27.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 27.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 27.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 27.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 27.
Parser(B) >> ... then shift 'expression', go to state 286
Parser(B) >> Reduce 101 [dorep_item ::= TK_TO expression], pop back to state 86.
Parser(B) >> ... then shift 'dorep_item', go to state 283
Parser(B) >> Reduce 99 [dorep_list ::= dorep_item], pop back to state 86.
Parser(B) >> ... then shift 'dorep_list', go to state 114
Parser(B) >> Reduce 98 [dorep ::= assignment dorep_list], pop back to state 17.
Parser(B) >> ... then shift 'dorep', go to state 96
Parser(B) >> Shift 'TK_UNTIL', go to state 28
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_UNTIL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 28
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_UNTIL TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_GT' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 28.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 28.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 28.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 28.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 28.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 28.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 28.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 28.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 28.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Shift 'TK_GT', go to state 46
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_UNTIL comparison TK_GT]
Parser(B) >> Input 'TK_INTEGER' in state 46
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_UNTIL comparison TK_GT TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 46.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 46.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 46.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 46.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 46.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 46.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 46.
Parser(B) >> ... then shift 'concatenation', go to state 58
Parser(B) >> Reduce 214 [comparison ::= comparison TK_GT concatenation], pop back to state 28.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 28.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 28.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 28.
Parser(B) >> ... then shift 'expression', go to state 396
Parser(B) >> Reduce 106 [docond ::= TK_UNTIL expression], pop back to state 96.
Parser(B) >> ... then shift 'docond', go to state 398
Parser(B) >> Shift 'TK_EOC', go to state 6
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep docond TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 6
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep docond TK_EOC TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 6.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep docond TK_EOC var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 33
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep docond TK_EOC var_symbol TK_EQUAL TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_PLUS' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 33.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Shift 'TK_PLUS', go to state 64
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep docond TK_EOC var_symbol TK_EQUAL addition TK_PLUS]
Parser(B) >> Input 'TK_INTEGER' in state 64
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep docond TK_EOC var_symbol TK_EQUAL addition TK_PLUS TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 64.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 64.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 64.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 64.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 64.
Parser(B) >> ... then shift 'multiplication', go to state 240
Parser(B) >> Reduce 194 [addition ::= addition TK_PLUS multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 6.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 6.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep docond TK_EOC single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_END' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 6.
Parser(B) >> ... then shift 'labeled_instruction', go to state 184
Parser(B) >> Reduce 33 [instruction_list ::= labeled_instruction], pop back to state 6.
Parser(B) >> ... then shift 'instruction_list', go to state 14
Parser(B) >> Shift 'TK_END', go to state 125
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep docond TK_EOC instruction_list TK_END]
Parser(B) >> Input 'TK_EOC' in state 125
Parser(B) >> Reduce 84 [do ::= tk_doloop dorep docond TK_EOC instruction_list TK_END], pop back to state 8.
Parser(B) >> ... then shift 'do', go to state 101
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 405
Parser(B) >> Shift 'TK_EOC', go to state 186
Parser(B) >> Return. Stack=[rexx_options instruction_list do junk TK_EOC]
Parser(B) >> Input 'TK_IF' in state 186
Parser(B) >> Reduce 71 [group ::= do junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'group', go to state 193
Parser(B) >> Reduce 35 [labeled_instruction ::= group], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_IF', go to state 30
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 30
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_NEQ' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 30.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 30.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 30.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 30.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 30.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 30.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 30.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 30.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Shift 'TK_NEQ', go to state 47
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ]
Parser(B) >> Input 'TK_INTEGER' in state 47
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ TK_INTEGER]
Parser(B) >> Input 'TK_THEN' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 47.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 47.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 47.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 47.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 47.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 47.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 47.
Parser(B) >> ... then shift 'concatenation', go to state 59
Parser(B) >> Reduce 213 [comparison ::= comparison TK_NEQ concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 30.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 30.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 30.
Parser(B) >> ... then shift 'expression', go to state 127
Parser(B) >> Reduce 254 [ncl0 ::=] without external action.
Parser(B) >> ... then shift 'ncl0', go to state 131
Parser(B) >> Shift 'TK_THEN', go to state 109
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN]
Parser(B) >> Input 'TK_DO' in state 109
Parser(B) >> Reduce 254 [ncl0 ::=] without external action.
Parser(B) >> ... then shift 'ncl0', go to state 15
Parser(B) >> Shift 'TK_DO', go to state 113
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO]
Parser(B) >> Input 'TK_EOC' in state 113
Parser(B) >> Shift 'TK_EOC', go to state 7
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 7
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 7.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 33
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_PLUS' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 33.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Shift 'TK_PLUS', go to state 64
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL addition TK_PLUS]
Parser(B) >> Input 'TK_INTEGER' in state 64
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL addition TK_PLUS TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 64.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 64.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 64.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 64.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 64.
Parser(B) >> ... then shift 'multiplication', go to state 240
Parser(B) >> Reduce 194 [addition ::= addition TK_PLUS multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 7.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 7.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_SAY' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 7.
Parser(B) >> ... then shift 'labeled_instruction', go to state 184
Parser(B) >> Reduce 33 [instruction_list ::= labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_SAY', go to state 22
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_SAY]
Parser(B) >> Input 'TK_STRING' in state 22
Parser(B) >> Shift 'TK_STRING', go to state 111
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_SAY TK_STRING]
Parser(B) >> Input 'TK_EOC' in state 111
Parser(B) >> Reduce 179 [term ::= TK_STRING], pop back to state 22.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 22.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 22.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 22.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 22.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 22.
Parser(B) >> ... then shift 'expression', go to state 331
Parser(B) >> Reduce 160 [say ::= TK_SAY expression], pop back to state 10.
Parser(B) >> ... then shift 'say', go to state 365
Parser(B) >> Reduce 60 [keyword_instruction ::= say], pop back to state 10.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 10.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_END' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 10.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_END', go to state 129
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_END]
Parser(B) >> Input 'TK_EOC' in state 129
Parser(B) >> Reduce 73 [simple_do ::= TK_DO TK_EOC instruction_list TK_END], pop back to state 15.
Parser(B) >> ... then shift 'simple_do', go to state 102
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 406
Parser(B) >> Shift 'TK_EOC', go to state 187
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 simple_do junk TK_EOC]
Parser(B) >> Input 'TK_IF' in state 187
Parser(B) >> Reduce 70 [group ::= simple_do junk TK_EOC], pop back to state 15.
Parser(B) >> ... then shift 'group', go to state 182
Parser(B) >> Reduce 41 [instruction ::= group], pop back to state 15.
Parser(B) >> ... then shift 'instruction', go to state 175
Parser(B) >> Reduce 110 [then ::= TK_THEN ncl0 instruction], pop back to state 131.
Parser(B) >> ... then shift 'then', go to state 108
Parser(B) >> Reduce 108 [if ::= TK_IF expression ncl0 then], pop back to state 8.
Parser(B) >> ... then shift 'if', go to state 185
Parser(B) >> Reduce 72 [group ::= if], pop back to state 8.
Parser(B) >> ... then shift 'group', go to state 193
Parser(B) >> Reduce 35 [labeled_instruction ::= group], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_IF', go to state 30
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 30
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_NEQ' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 30.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 30.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 30.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 30.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 30.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 30.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 30.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 30.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Shift 'TK_NEQ', go to state 47
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ]
Parser(B) >> Input 'TK_INTEGER' in state 47
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ TK_INTEGER]
Parser(B) >> Input 'TK_THEN' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 47.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 47.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 47.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 47.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 47.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 47.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 47.
Parser(B) >> ... then shift 'concatenation', go to state 59
Parser(B) >> Reduce 213 [comparison ::= comparison TK_NEQ concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 30.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 30.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 30.
Parser(B) >> ... then shift 'expression', go to state 127
Parser(B) >> Reduce 254 [ncl0 ::=] without external action.
Parser(B) >> ... then shift 'ncl0', go to state 131
Parser(B) >> Shift 'TK_THEN', go to state 109
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN]
Parser(B) >> Input 'TK_DO' in state 109
Parser(B) >> Reduce 254 [ncl0 ::=] without external action.
Parser(B) >> ... then shift 'ncl0', go to state 15
Parser(B) >> Shift 'TK_DO', go to state 113
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO]
Parser(B) >> Input 'TK_EOC' in state 113
Parser(B) >> Shift 'TK_EOC', go to state 7
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 7
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 7.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 33
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_PLUS' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 33.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Shift 'TK_PLUS', go to state 64
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL addition TK_PLUS]
Parser(B) >> Input 'TK_INTEGER' in state 64
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL addition TK_PLUS TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 64.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 64.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 64.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 64.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 64.
Parser(B) >> ... then shift 'multiplication', go to state 240
Parser(B) >> Reduce 194 [addition ::= addition TK_PLUS multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 7.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 7.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_SAY' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 7.
Parser(B) >> ... then shift 'labeled_instruction', go to state 184
Parser(B) >> Reduce 33 [instruction_list ::= labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_SAY', go to state 22
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_SAY]
Parser(B) >> Input 'TK_STRING' in state 22
Parser(B) >> Shift 'TK_STRING', go to state 111
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_SAY TK_STRING]
Parser(B) >> Input 'TK_EOC' in state 111
Parser(B) >> Reduce 179 [term ::= TK_STRING], pop back to state 22.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 22.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 22.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 22.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 22.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 22.
Parser(B) >> ... then shift 'expression', go to state 331
Parser(B) >> Reduce 160 [say ::= TK_SAY expression], pop back to state 10.
Parser(B) >> ... then shift 'say', go to state 365
Parser(B) >> Reduce 60 [keyword_instruction ::= say], pop back to state 10.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 10.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_END' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 10.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_END', go to state 129
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_END]
Parser(B) >> Input 'TK_EOC' in state 129
Parser(B) >> Reduce 73 [simple_do ::= TK_DO TK_EOC instruction_list TK_END], pop back to state 15.
Parser(B) >> ... then shift 'simple_do', go to state 102
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 406
Parser(B) >> Shift 'TK_EOC', go to state 187
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 simple_do junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 187
Parser(B) >> Reduce 70 [group ::= simple_do junk TK_EOC], pop back to state 15.
Parser(B) >> ... then shift 'group', go to state 182
Parser(B) >> Reduce 41 [instruction ::= group], pop back to state 15.
Parser(B) >> ... then shift 'instruction', go to state 175
Parser(B) >> Reduce 110 [then ::= TK_THEN ncl0 instruction], pop back to state 131.
Parser(B) >> ... then shift 'then', go to state 108
Parser(B) >> Reduce 108 [if ::= TK_IF expression ncl0 then], pop back to state 8.
Parser(B) >> ... then shift 'if', go to state 185
Parser(B) >> Reduce 72 [group ::= if], pop back to state 8.
Parser(B) >> ... then shift 'group', go to state 193
Parser(B) >> Reduce 35 [labeled_instruction ::= group], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 8.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_INTEGER' in state 33
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 8.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_DO' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_DO', go to state 113
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_DO]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 113
Parser(B) >> Reduce 80 [tk_doloop ::= TK_DO], pop back to state 8.
Parser(B) >> ... then shift 'tk_doloop', go to state 17
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_PLUS' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 17.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 17.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 17.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 17.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 17.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 17.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 17.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Shift 'TK_PLUS', go to state 64
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop addition TK_PLUS]
Parser(B) >> Input 'TK_INTEGER' in state 64
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop addition TK_PLUS TK_INTEGER]
Parser(B) >> Input 'TK_UNTIL' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 64.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 64.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 64.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 64.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 64.
Parser(B) >> ... then shift 'multiplication', go to state 240
Parser(B) >> Reduce 194 [addition ::= addition TK_PLUS multiplication], pop back to state 17.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 17.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 17.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 17.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 17.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 17.
Parser(B) >> ... then shift 'expression', go to state 303
Parser(B) >> Reduce 96 [dorep ::= expression], pop back to state 17.
Parser(B) >> ... then shift 'dorep', go to state 96
Parser(B) >> Shift 'TK_UNTIL', go to state 28
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_UNTIL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 28
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_UNTIL TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 28.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 28.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 28.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 28.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 28.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 28.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 28.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 28.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 28.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Shift 'TK_EQUAL', go to state 48
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_UNTIL comparison TK_EQUAL]
Parser(B) >> Input 'TK_INTEGER' in state 48
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_UNTIL comparison TK_EQUAL TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 48.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 48.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 48.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 48.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 48.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 48.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 48.
Parser(B) >> ... then shift 'concatenation', go to state 60
Parser(B) >> Reduce 212 [comparison ::= comparison TK_EQUAL concatenation], pop back to state 28.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 28.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 28.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 28.
Parser(B) >> ... then shift 'expression', go to state 396
Parser(B) >> Reduce 106 [docond ::= TK_UNTIL expression], pop back to state 96.
Parser(B) >> ... then shift 'docond', go to state 398
Parser(B) >> Shift 'TK_EOC', go to state 6
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep docond TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 6
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep docond TK_EOC TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 6.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep docond TK_EOC var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 33
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep docond TK_EOC var_symbol TK_EQUAL TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_PLUS' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 33.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Shift 'TK_PLUS', go to state 64
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep docond TK_EOC var_symbol TK_EQUAL addition TK_PLUS]
Parser(B) >> Input 'TK_INTEGER' in state 64
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep docond TK_EOC var_symbol TK_EQUAL addition TK_PLUS TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 64.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 64.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 64.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 64.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 64.
Parser(B) >> ... then shift 'multiplication', go to state 240
Parser(B) >> Reduce 194 [addition ::= addition TK_PLUS multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 6.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 6.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep docond TK_EOC single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_END' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 6.
Parser(B) >> ... then shift 'labeled_instruction', go to state 184
Parser(B) >> Reduce 33 [instruction_list ::= labeled_instruction], pop back to state 6.
Parser(B) >> ... then shift 'instruction_list', go to state 14
Parser(B) >> Shift 'TK_END', go to state 125
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep docond TK_EOC instruction_list TK_END]
Parser(B) >> Input 'TK_EOC' in state 125
Parser(B) >> Reduce 84 [do ::= tk_doloop dorep docond TK_EOC instruction_list TK_END], pop back to state 8.
Parser(B) >> ... then shift 'do', go to state 101
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 405
Parser(B) >> Shift 'TK_EOC', go to state 186
Parser(B) >> Return. Stack=[rexx_options instruction_list do junk TK_EOC]
Parser(B) >> Input 'TK_IF' in state 186
Parser(B) >> Reduce 71 [group ::= do junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'group', go to state 193
Parser(B) >> Reduce 35 [labeled_instruction ::= group], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_IF', go to state 30
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 30
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_NEQ' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 30.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 30.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 30.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 30.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 30.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 30.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 30.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 30.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Shift 'TK_NEQ', go to state 47
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ]
Parser(B) >> Input 'TK_INTEGER' in state 47
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ TK_INTEGER]
Parser(B) >> Input 'TK_THEN' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 47.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 47.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 47.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 47.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 47.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 47.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 47.
Parser(B) >> ... then shift 'concatenation', go to state 59
Parser(B) >> Reduce 213 [comparison ::= comparison TK_NEQ concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 30.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 30.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 30.
Parser(B) >> ... then shift 'expression', go to state 127
Parser(B) >> Reduce 254 [ncl0 ::=] without external action.
Parser(B) >> ... then shift 'ncl0', go to state 131
Parser(B) >> Shift 'TK_THEN', go to state 109
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN]
Parser(B) >> Input 'TK_DO' in state 109
Parser(B) >> Reduce 254 [ncl0 ::=] without external action.
Parser(B) >> ... then shift 'ncl0', go to state 15
Parser(B) >> Shift 'TK_DO', go to state 113
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO]
Parser(B) >> Input 'TK_EOC' in state 113
Parser(B) >> Shift 'TK_EOC', go to state 7
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 7
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 7.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 33
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_PLUS' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 33.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Shift 'TK_PLUS', go to state 64
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL addition TK_PLUS]
Parser(B) >> Input 'TK_INTEGER' in state 64
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL addition TK_PLUS TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 64.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 64.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 64.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 64.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 64.
Parser(B) >> ... then shift 'multiplication', go to state 240
Parser(B) >> Reduce 194 [addition ::= addition TK_PLUS multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 7.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 7.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_SAY' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 7.
Parser(B) >> ... then shift 'labeled_instruction', go to state 184
Parser(B) >> Reduce 33 [instruction_list ::= labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_SAY', go to state 22
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_SAY]
Parser(B) >> Input 'TK_STRING' in state 22
Parser(B) >> Shift 'TK_STRING', go to state 111
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_SAY TK_STRING]
Parser(B) >> Input 'TK_EOC' in state 111
Parser(B) >> Reduce 179 [term ::= TK_STRING], pop back to state 22.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 22.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 22.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 22.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 22.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 22.
Parser(B) >> ... then shift 'expression', go to state 331
Parser(B) >> Reduce 160 [say ::= TK_SAY expression], pop back to state 10.
Parser(B) >> ... then shift 'say', go to state 365
Parser(B) >> Reduce 60 [keyword_instruction ::= say], pop back to state 10.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 10.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_END' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 10.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_END', go to state 129
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_END]
Parser(B) >> Input 'TK_EOC' in state 129
Parser(B) >> Reduce 73 [simple_do ::= TK_DO TK_EOC instruction_list TK_END], pop back to state 15.
Parser(B) >> ... then shift 'simple_do', go to state 102
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 406
Parser(B) >> Shift 'TK_EOC', go to state 187
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 simple_do junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 187
Parser(B) >> Reduce 70 [group ::= simple_do junk TK_EOC], pop back to state 15.
Parser(B) >> ... then shift 'group', go to state 182
Parser(B) >> Reduce 41 [instruction ::= group], pop back to state 15.
Parser(B) >> ... then shift 'instruction', go to state 175
Parser(B) >> Reduce 110 [then ::= TK_THEN ncl0 instruction], pop back to state 131.
Parser(B) >> ... then shift 'then', go to state 108
Parser(B) >> Reduce 108 [if ::= TK_IF expression ncl0 then], pop back to state 8.
Parser(B) >> ... then shift 'if', go to state 185
Parser(B) >> Reduce 72 [group ::= if], pop back to state 8.
Parser(B) >> ... then shift 'group', go to state 193
Parser(B) >> Reduce 35 [labeled_instruction ::= group], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 8.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_INTEGER' in state 33
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 8.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_DO' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_DO', go to state 113
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_DO]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 113
Parser(B) >> Reduce 80 [tk_doloop ::= TK_DO], pop back to state 8.
Parser(B) >> ... then shift 'tk_doloop', go to state 17
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 17.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_INTEGER' in state 33
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop var_symbol TK_EQUAL TK_INTEGER]
Parser(B) >> Input 'TK_TO' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 17.
Parser(B) >> ... then shift 'assignment', go to state 86
Parser(B) >> Shift 'TK_TO', go to state 27
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop assignment TK_TO]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 27
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop assignment TK_TO TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_PLUS' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 27.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 27.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 27.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 27.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 27.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 27.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 27.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Shift 'TK_PLUS', go to state 64
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop assignment TK_TO addition TK_PLUS]
Parser(B) >> Input 'TK_INTEGER' in state 64
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop assignment TK_TO addition TK_PLUS TK_INTEGER]
Parser(B) >> Input 'TK_UNTIL' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 64.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 64.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 64.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 64.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 64.
Parser(B) >> ... then shift 'multiplication', go to state 240
Parser(B) >> Reduce 194 [addition ::= addition TK_PLUS multiplication], pop back to state 27.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 27.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 27.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 27.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 27.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 27.
Parser(B) >> ... then shift 'expression', go to state 286
Parser(B) >> Reduce 101 [dorep_item ::= TK_TO expression], pop back to state 86.
Parser(B) >> ... then shift 'dorep_item', go to state 283
Parser(B) >> Reduce 99 [dorep_list ::= dorep_item], pop back to state 86.
Parser(B) >> ... then shift 'dorep_list', go to state 114
Parser(B) >> Reduce 98 [dorep ::= assignment dorep_list], pop back to state 17.
Parser(B) >> ... then shift 'dorep', go to state 96
Parser(B) >> Shift 'TK_UNTIL', go to state 28
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_UNTIL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 28
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_UNTIL TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 28.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 28.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 28.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 28.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 28.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 28.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 28.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 28.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 28.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Shift 'TK_EQUAL', go to state 48
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_UNTIL comparison TK_EQUAL]
Parser(B) >> Input 'TK_INTEGER' in state 48
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_UNTIL comparison TK_EQUAL TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 48.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 48.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 48.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 48.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 48.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 48.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 48.
Parser(B) >> ... then shift 'concatenation', go to state 60
Parser(B) >> Reduce 212 [comparison ::= comparison TK_EQUAL concatenation], pop back to state 28.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 28.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 28.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 28.
Parser(B) >> ... then shift 'expression', go to state 396
Parser(B) >> Reduce 106 [docond ::= TK_UNTIL expression], pop back to state 96.
Parser(B) >> ... then shift 'docond', go to state 398
Parser(B) >> Shift 'TK_EOC', go to state 6
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep docond TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 6
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep docond TK_EOC TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 6.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep docond TK_EOC var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 33
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep docond TK_EOC var_symbol TK_EQUAL TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_PLUS' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 33.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Shift 'TK_PLUS', go to state 64
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep docond TK_EOC var_symbol TK_EQUAL addition TK_PLUS]
Parser(B) >> Input 'TK_INTEGER' in state 64
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep docond TK_EOC var_symbol TK_EQUAL addition TK_PLUS TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 64.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 64.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 64.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 64.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 64.
Parser(B) >> ... then shift 'multiplication', go to state 240
Parser(B) >> Reduce 194 [addition ::= addition TK_PLUS multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 6.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 6.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep docond TK_EOC single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_END' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 6.
Parser(B) >> ... then shift 'labeled_instruction', go to state 184
Parser(B) >> Reduce 33 [instruction_list ::= labeled_instruction], pop back to state 6.
Parser(B) >> ... then shift 'instruction_list', go to state 14
Parser(B) >> Shift 'TK_END', go to state 125
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep docond TK_EOC instruction_list TK_END]
Parser(B) >> Input 'TK_EOC' in state 125
Parser(B) >> Reduce 84 [do ::= tk_doloop dorep docond TK_EOC instruction_list TK_END], pop back to state 8.
Parser(B) >> ... then shift 'do', go to state 101
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 405
Parser(B) >> Shift 'TK_EOC', go to state 186
Parser(B) >> Return. Stack=[rexx_options instruction_list do junk TK_EOC]
Parser(B) >> Input 'TK_IF' in state 186
Parser(B) >> Reduce 71 [group ::= do junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'group', go to state 193
Parser(B) >> Reduce 35 [labeled_instruction ::= group], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_IF', go to state 30
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 30
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_NEQ' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 30.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 30.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 30.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 30.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 30.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 30.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 30.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 30.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Shift 'TK_NEQ', go to state 47
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ]
Parser(B) >> Input 'TK_INTEGER' in state 47
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ TK_INTEGER]
Parser(B) >> Input 'TK_THEN' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 47.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 47.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 47.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 47.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 47.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 47.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 47.
Parser(B) >> ... then shift 'concatenation', go to state 59
Parser(B) >> Reduce 213 [comparison ::= comparison TK_NEQ concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 30.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 30.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 30.
Parser(B) >> ... then shift 'expression', go to state 127
Parser(B) >> Reduce 254 [ncl0 ::=] without external action.
Parser(B) >> ... then shift 'ncl0', go to state 131
Parser(B) >> Shift 'TK_THEN', go to state 109
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN]
Parser(B) >> Input 'TK_DO' in state 109
Parser(B) >> Reduce 254 [ncl0 ::=] without external action.
Parser(B) >> ... then shift 'ncl0', go to state 15
Parser(B) >> Shift 'TK_DO', go to state 113
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO]
Parser(B) >> Input 'TK_EOC' in state 113
Parser(B) >> Shift 'TK_EOC', go to state 7
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 7
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 7.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 33
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_PLUS' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 33.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Shift 'TK_PLUS', go to state 64
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL addition TK_PLUS]
Parser(B) >> Input 'TK_INTEGER' in state 64
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL addition TK_PLUS TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 64.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 64.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 64.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 64.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 64.
Parser(B) >> ... then shift 'multiplication', go to state 240
Parser(B) >> Reduce 194 [addition ::= addition TK_PLUS multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 7.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 7.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_SAY' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 7.
Parser(B) >> ... then shift 'labeled_instruction', go to state 184
Parser(B) >> Reduce 33 [instruction_list ::= labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_SAY', go to state 22
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_SAY]
Parser(B) >> Input 'TK_STRING' in state 22
Parser(B) >> Shift 'TK_STRING', go to state 111
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_SAY TK_STRING]
Parser(B) >> Input 'TK_EOC' in state 111
Parser(B) >> Reduce 179 [term ::= TK_STRING], pop back to state 22.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 22.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 22.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 22.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 22.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 22.
Parser(B) >> ... then shift 'expression', go to state 331
Parser(B) >> Reduce 160 [say ::= TK_SAY expression], pop back to state 10.
Parser(B) >> ... then shift 'say', go to state 365
Parser(B) >> Reduce 60 [keyword_instruction ::= say], pop back to state 10.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 10.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_END' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 10.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_END', go to state 129
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_END]
Parser(B) >> Input 'TK_EOC' in state 129
Parser(B) >> Reduce 73 [simple_do ::= TK_DO TK_EOC instruction_list TK_END], pop back to state 15.
Parser(B) >> ... then shift 'simple_do', go to state 102
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 406
Parser(B) >> Shift 'TK_EOC', go to state 187
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 simple_do junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 187
Parser(B) >> Reduce 70 [group ::= simple_do junk TK_EOC], pop back to state 15.
Parser(B) >> ... then shift 'group', go to state 182
Parser(B) >> Reduce 41 [instruction ::= group], pop back to state 15.
Parser(B) >> ... then shift 'instruction', go to state 175
Parser(B) >> Reduce 110 [then ::= TK_THEN ncl0 instruction], pop back to state 131.
Parser(B) >> ... then shift 'then', go to state 108
Parser(B) >> Reduce 108 [if ::= TK_IF expression ncl0 then], pop back to state 8.
Parser(B) >> ... then shift 'if', go to state 185
Parser(B) >> Reduce 72 [group ::= if], pop back to state 8.
Parser(B) >> ... then shift 'group', go to state 193
Parser(B) >> Reduce 35 [labeled_instruction ::= group], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 8.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_INTEGER' in state 33
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 8.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_DO' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_DO', go to state 113
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_DO]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 113
Parser(B) >> Reduce 80 [tk_doloop ::= TK_DO], pop back to state 8.
Parser(B) >> ... then shift 'tk_doloop', go to state 17
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 17.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_INTEGER' in state 33
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop var_symbol TK_EQUAL TK_INTEGER]
Parser(B) >> Input 'TK_TO' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 17.
Parser(B) >> ... then shift 'assignment', go to state 86
Parser(B) >> Shift 'TK_TO', go to state 27
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop assignment TK_TO]
Parser(B) >> Input 'TK_INTEGER' in state 27
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop assignment TK_TO TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 27.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 27.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 27.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 27.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 27.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 27.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 27.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 27.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 27.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 27.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 27.
Parser(B) >> ... then shift 'expression', go to state 286
Parser(B) >> Reduce 101 [dorep_item ::= TK_TO expression], pop back to state 86.
Parser(B) >> ... then shift 'dorep_item', go to state 283
Parser(B) >> Reduce 99 [dorep_list ::= dorep_item], pop back to state 86.
Parser(B) >> ... then shift 'dorep_list', go to state 114
Parser(B) >> Reduce 98 [dorep ::= assignment dorep_list], pop back to state 17.
Parser(B) >> ... then shift 'dorep', go to state 96
Parser(B) >> Shift 'TK_EOC', go to state 3
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_EOC]
Parser(B) >> Input 'TK_END' in state 3
Parser(B) >> Shift 'TK_END', go to state 126
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_EOC TK_END]
Parser(B) >> Input 'TK_EOC' in state 126
Parser(B) >> Reduce 83 [do ::= tk_doloop dorep TK_EOC TK_END], pop back to state 8.
Parser(B) >> ... then shift 'do', go to state 101
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 405
Parser(B) >> Shift 'TK_EOC', go to state 186
Parser(B) >> Return. Stack=[rexx_options instruction_list do junk TK_EOC]
Parser(B) >> Input 'TK_IF' in state 186
Parser(B) >> Reduce 71 [group ::= do junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'group', go to state 193
Parser(B) >> Reduce 35 [labeled_instruction ::= group], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_IF', go to state 30
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 30
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_NEQ' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 30.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 30.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 30.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 30.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 30.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 30.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 30.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 30.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Shift 'TK_NEQ', go to state 47
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ]
Parser(B) >> Input 'TK_INTEGER' in state 47
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ TK_INTEGER]
Parser(B) >> Input 'TK_THEN' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 47.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 47.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 47.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 47.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 47.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 47.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 47.
Parser(B) >> ... then shift 'concatenation', go to state 59
Parser(B) >> Reduce 213 [comparison ::= comparison TK_NEQ concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 30.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 30.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 30.
Parser(B) >> ... then shift 'expression', go to state 127
Parser(B) >> Reduce 254 [ncl0 ::=] without external action.
Parser(B) >> ... then shift 'ncl0', go to state 131
Parser(B) >> Shift 'TK_THEN', go to state 109
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN]
Parser(B) >> Input 'TK_DO' in state 109
Parser(B) >> Reduce 254 [ncl0 ::=] without external action.
Parser(B) >> ... then shift 'ncl0', go to state 15
Parser(B) >> Shift 'TK_DO', go to state 113
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO]
Parser(B) >> Input 'TK_EOC' in state 113
Parser(B) >> Shift 'TK_EOC', go to state 7
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 7
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 7.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 33
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_PLUS' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 33.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Shift 'TK_PLUS', go to state 64
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL addition TK_PLUS]
Parser(B) >> Input 'TK_INTEGER' in state 64
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL addition TK_PLUS TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 64.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 64.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 64.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 64.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 64.
Parser(B) >> ... then shift 'multiplication', go to state 240
Parser(B) >> Reduce 194 [addition ::= addition TK_PLUS multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 7.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 7.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_SAY' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 7.
Parser(B) >> ... then shift 'labeled_instruction', go to state 184
Parser(B) >> Reduce 33 [instruction_list ::= labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_SAY', go to state 22
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_SAY]
Parser(B) >> Input 'TK_STRING' in state 22
Parser(B) >> Shift 'TK_STRING', go to state 111
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_SAY TK_STRING]
Parser(B) >> Input 'TK_EOC' in state 111
Parser(B) >> Reduce 179 [term ::= TK_STRING], pop back to state 22.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 22.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 22.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 22.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 22.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 22.
Parser(B) >> ... then shift 'expression', go to state 331
Parser(B) >> Reduce 160 [say ::= TK_SAY expression], pop back to state 10.
Parser(B) >> ... then shift 'say', go to state 365
Parser(B) >> Reduce 60 [keyword_instruction ::= say], pop back to state 10.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 10.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_END' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 10.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_END', go to state 129
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_END]
Parser(B) >> Input 'TK_EOC' in state 129
Parser(B) >> Reduce 73 [simple_do ::= TK_DO TK_EOC instruction_list TK_END], pop back to state 15.
Parser(B) >> ... then shift 'simple_do', go to state 102
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 406
Parser(B) >> Shift 'TK_EOC', go to state 187
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 simple_do junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 187
Parser(B) >> Reduce 70 [group ::= simple_do junk TK_EOC], pop back to state 15.
Parser(B) >> ... then shift 'group', go to state 182
Parser(B) >> Reduce 41 [instruction ::= group], pop back to state 15.
Parser(B) >> ... then shift 'instruction', go to state 175
Parser(B) >> Reduce 110 [then ::= TK_THEN ncl0 instruction], pop back to state 131.
Parser(B) >> ... then shift 'then', go to state 108
Parser(B) >> Reduce 108 [if ::= TK_IF expression ncl0 then], pop back to state 8.
Parser(B) >> ... then shift 'if', go to state 185
Parser(B) >> Reduce 72 [group ::= if], pop back to state 8.
Parser(B) >> ... then shift 'group', go to state 193
Parser(B) >> Reduce 35 [labeled_instruction ::= group], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 8.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_INTEGER' in state 33
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 8.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_LOOP' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_LOOP', go to state 242
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_LOOP]
Parser(B) >> Input 'TK_INTEGER' in state 242
Parser(B) >> Reduce 81 [tk_doloop ::= TK_LOOP], pop back to state 8.
Parser(B) >> ... then shift 'tk_doloop', go to state 17
Parser(B) >> Shift 'TK_INTEGER', go to state 249
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 249
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 17.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 17.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 17.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 17.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 17.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 17.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 17.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 17.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 17.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 17.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 17.
Parser(B) >> ... then shift 'expression', go to state 303
Parser(B) >> Reduce 96 [dorep ::= expression], pop back to state 17.
Parser(B) >> ... then shift 'dorep', go to state 96
Parser(B) >> Shift 'TK_EOC', go to state 3
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 3
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_EOC TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 3.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_EOC var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 33
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_EOC var_symbol TK_EQUAL TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_PLUS' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 33.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Shift 'TK_PLUS', go to state 64
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_EOC var_symbol TK_EQUAL addition TK_PLUS]
Parser(B) >> Input 'TK_INTEGER' in state 64
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_EOC var_symbol TK_EQUAL addition TK_PLUS TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 64.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 64.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 64.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 64.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 64.
Parser(B) >> ... then shift 'multiplication', go to state 240
Parser(B) >> Reduce 194 [addition ::= addition TK_PLUS multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 3.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 3.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_EOC single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_END' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 3.
Parser(B) >> ... then shift 'labeled_instruction', go to state 184
Parser(B) >> Reduce 33 [instruction_list ::= labeled_instruction], pop back to state 3.
Parser(B) >> ... then shift 'instruction_list', go to state 9
Parser(B) >> Shift 'TK_END', go to state 128
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_EOC instruction_list TK_END]
Parser(B) >> Input 'TK_EOC' in state 128
Parser(B) >> Reduce 82 [do ::= tk_doloop dorep TK_EOC instruction_list TK_END], pop back to state 8.
Parser(B) >> ... then shift 'do', go to state 101
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 405
Parser(B) >> Shift 'TK_EOC', go to state 186
Parser(B) >> Return. Stack=[rexx_options instruction_list do junk TK_EOC]
Parser(B) >> Input 'TK_IF' in state 186
Parser(B) >> Reduce 71 [group ::= do junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'group', go to state 193
Parser(B) >> Reduce 35 [labeled_instruction ::= group], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_IF', go to state 30
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 30
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_NEQ' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 30.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 30.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 30.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 30.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 30.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 30.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 30.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 30.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Shift 'TK_NEQ', go to state 47
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ]
Parser(B) >> Input 'TK_INTEGER' in state 47
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ TK_INTEGER]
Parser(B) >> Input 'TK_THEN' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 47.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 47.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 47.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 47.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 47.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 47.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 47.
Parser(B) >> ... then shift 'concatenation', go to state 59
Parser(B) >> Reduce 213 [comparison ::= comparison TK_NEQ concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 30.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 30.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 30.
Parser(B) >> ... then shift 'expression', go to state 127
Parser(B) >> Reduce 254 [ncl0 ::=] without external action.
Parser(B) >> ... then shift 'ncl0', go to state 131
Parser(B) >> Shift 'TK_THEN', go to state 109
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN]
Parser(B) >> Input 'TK_DO' in state 109
Parser(B) >> Reduce 254 [ncl0 ::=] without external action.
Parser(B) >> ... then shift 'ncl0', go to state 15
Parser(B) >> Shift 'TK_DO', go to state 113
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO]
Parser(B) >> Input 'TK_EOC' in state 113
Parser(B) >> Shift 'TK_EOC', go to state 7
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 7
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 7.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 33
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_PLUS' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 33.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Shift 'TK_PLUS', go to state 64
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL addition TK_PLUS]
Parser(B) >> Input 'TK_INTEGER' in state 64
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL addition TK_PLUS TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 64.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 64.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 64.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 64.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 64.
Parser(B) >> ... then shift 'multiplication', go to state 240
Parser(B) >> Reduce 194 [addition ::= addition TK_PLUS multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 7.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 7.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_SAY' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 7.
Parser(B) >> ... then shift 'labeled_instruction', go to state 184
Parser(B) >> Reduce 33 [instruction_list ::= labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_SAY', go to state 22
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_SAY]
Parser(B) >> Input 'TK_STRING' in state 22
Parser(B) >> Shift 'TK_STRING', go to state 111
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_SAY TK_STRING]
Parser(B) >> Input 'TK_EOC' in state 111
Parser(B) >> Reduce 179 [term ::= TK_STRING], pop back to state 22.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 22.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 22.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 22.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 22.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 22.
Parser(B) >> ... then shift 'expression', go to state 331
Parser(B) >> Reduce 160 [say ::= TK_SAY expression], pop back to state 10.
Parser(B) >> ... then shift 'say', go to state 365
Parser(B) >> Reduce 60 [keyword_instruction ::= say], pop back to state 10.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 10.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_END' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 10.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_END', go to state 129
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_END]
Parser(B) >> Input 'TK_EOC' in state 129
Parser(B) >> Reduce 73 [simple_do ::= TK_DO TK_EOC instruction_list TK_END], pop back to state 15.
Parser(B) >> ... then shift 'simple_do', go to state 102
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 406
Parser(B) >> Shift 'TK_EOC', go to state 187
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 simple_do junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 187
Parser(B) >> Reduce 70 [group ::= simple_do junk TK_EOC], pop back to state 15.
Parser(B) >> ... then shift 'group', go to state 182
Parser(B) >> Reduce 41 [instruction ::= group], pop back to state 15.
Parser(B) >> ... then shift 'instruction', go to state 175
Parser(B) >> Reduce 110 [then ::= TK_THEN ncl0 instruction], pop back to state 131.
Parser(B) >> ... then shift 'then', go to state 108
Parser(B) >> Reduce 108 [if ::= TK_IF expression ncl0 then], pop back to state 8.
Parser(B) >> ... then shift 'if', go to state 185
Parser(B) >> Reduce 72 [group ::= if], pop back to state 8.
Parser(B) >> ... then shift 'group', go to state 193
Parser(B) >> Reduce 35 [labeled_instruction ::= group], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 8.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_INTEGER' in state 33
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 8.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_LOOP' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_LOOP', go to state 242
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_LOOP]
Parser(B) >> Input 'TK_FOREVER' in state 242
Parser(B) >> Reduce 81 [tk_doloop ::= TK_LOOP], pop back to state 8.
Parser(B) >> ... then shift 'tk_doloop', go to state 17
Parser(B) >> Shift 'TK_FOREVER', go to state 393
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop TK_FOREVER]
Parser(B) >> Input 'TK_EOC' in state 393
Parser(B) >> Reduce 104 [doforever ::= TK_FOREVER], pop back to state 17.
Parser(B) >> ... then shift 'doforever', go to state 394
Parser(B) >> Shift 'TK_EOC', go to state 4
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop doforever TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 4
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop doforever TK_EOC TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 4.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop doforever TK_EOC var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 33
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop doforever TK_EOC var_symbol TK_EQUAL TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_PLUS' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 33.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Shift 'TK_PLUS', go to state 64
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop doforever TK_EOC var_symbol TK_EQUAL addition TK_PLUS]
Parser(B) >> Input 'TK_INTEGER' in state 64
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop doforever TK_EOC var_symbol TK_EQUAL addition TK_PLUS TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 64.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 64.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 64.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 64.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 64.
Parser(B) >> ... then shift 'multiplication', go to state 240
Parser(B) >> Reduce 194 [addition ::= addition TK_PLUS multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 4.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 4.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop doforever TK_EOC single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 4.
Parser(B) >> ... then shift 'labeled_instruction', go to state 184
Parser(B) >> Reduce 33 [instruction_list ::= labeled_instruction], pop back to state 4.
Parser(B) >> ... then shift 'instruction_list', go to state 12
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop doforever TK_EOC instruction_list TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 12.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop doforever TK_EOC instruction_list var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 33
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop doforever TK_EOC instruction_list var_symbol TK_EQUAL TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_PLUS' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 33.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Shift 'TK_PLUS', go to state 64
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop doforever TK_EOC instruction_list var_symbol TK_EQUAL addition TK_PLUS]
Parser(B) >> Input 'TK_INTEGER' in state 64
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop doforever TK_EOC instruction_list var_symbol TK_EQUAL addition TK_PLUS TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 64.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 64.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 64.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 64.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 64.
Parser(B) >> ... then shift 'multiplication', go to state 240
Parser(B) >> Reduce 194 [addition ::= addition TK_PLUS multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 12.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 12.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop doforever TK_EOC instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_IF' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 12.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 4.
Parser(B) >> ... then shift 'instruction_list', go to state 12
Parser(B) >> Shift 'TK_IF', go to state 30
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop doforever TK_EOC instruction_list TK_IF]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 30
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop doforever TK_EOC instruction_list TK_IF TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 30.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 30.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 30.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 30.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 30.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 30.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 30.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 30.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Shift 'TK_EQUAL', go to state 48
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop doforever TK_EOC instruction_list TK_IF comparison TK_EQUAL]
Parser(B) >> Input 'TK_INTEGER' in state 48
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop doforever TK_EOC instruction_list TK_IF comparison TK_EQUAL TK_INTEGER]
Parser(B) >> Input 'TK_THEN' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 48.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 48.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 48.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 48.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 48.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 48.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 48.
Parser(B) >> ... then shift 'concatenation', go to state 60
Parser(B) >> Reduce 212 [comparison ::= comparison TK_EQUAL concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 30.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 30.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 30.
Parser(B) >> ... then shift 'expression', go to state 127
Parser(B) >> Reduce 254 [ncl0 ::=] without external action.
Parser(B) >> ... then shift 'ncl0', go to state 131
Parser(B) >> Shift 'TK_THEN', go to state 109
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop doforever TK_EOC instruction_list TK_IF expression ncl0 TK_THEN]
Parser(B) >> Input 'TK_LEAVE' in state 109
Parser(B) >> Reduce 254 [ncl0 ::=] without external action.
Parser(B) >> ... then shift 'ncl0', go to state 15
Parser(B) >> Shift 'TK_LEAVE', go to state 117
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop doforever TK_EOC instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_LEAVE]
Parser(B) >> Input 'TK_EOC' in state 117
Parser(B) >> Reduce 157 [leave ::= TK_LEAVE], pop back to state 15.
Parser(B) >> ... then shift 'leave', go to state 369
Parser(B) >> Reduce 56 [keyword_instruction ::= leave], pop back to state 15.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 15.
Parser(B) >> ... then shift 'single_instruction', go to state 100
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 404
Parser(B) >> Shift 'TK_EOC', go to state 181
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop doforever TK_EOC instruction_list TK_IF expression ncl0 TK_THEN ncl0 single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_END' in state 181
Parser(B) >> Reduce 42 [instruction ::= single_instruction junk TK_EOC], pop back to state 15.
Parser(B) >> ... then shift 'instruction', go to state 175
Parser(B) >> Reduce 110 [then ::= TK_THEN ncl0 instruction], pop back to state 131.
Parser(B) >> ... then shift 'then', go to state 108
Parser(B) >> Reduce 108 [if ::= TK_IF expression ncl0 then], pop back to state 12.
Parser(B) >> ... then shift 'if', go to state 185
Parser(B) >> Reduce 72 [group ::= if], pop back to state 12.
Parser(B) >> ... then shift 'group', go to state 193
Parser(B) >> Reduce 35 [labeled_instruction ::= group], pop back to state 12.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 4.
Parser(B) >> ... then shift 'instruction_list', go to state 12
Parser(B) >> Shift 'TK_END', go to state 121
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop doforever TK_EOC instruction_list TK_END]
Parser(B) >> Input 'TK_EOC' in state 121
Parser(B) >> Reduce 88 [do ::= tk_doloop doforever TK_EOC instruction_list TK_END], pop back to state 8.
Parser(B) >> ... then shift 'do', go to state 101
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 405
Parser(B) >> Shift 'TK_EOC', go to state 186
Parser(B) >> Return. Stack=[rexx_options instruction_list do junk TK_EOC]
Parser(B) >> Input 'TK_IF' in state 186
Parser(B) >> Reduce 71 [group ::= do junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'group', go to state 193
Parser(B) >> Reduce 35 [labeled_instruction ::= group], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_IF', go to state 30
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 30
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_NEQ' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 30.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 30.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 30.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 30.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 30.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 30.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 30.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 30.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Shift 'TK_NEQ', go to state 47
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ]
Parser(B) >> Input 'TK_INTEGER' in state 47
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 47.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 47.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 47.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 47.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 47.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 47.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 47.
Parser(B) >> ... then shift 'concatenation', go to state 59
Parser(B) >> Reduce 213 [comparison ::= comparison TK_NEQ concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 30.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 30.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 30.
Parser(B) >> ... then shift 'expression', go to state 127
Parser(B) >> Shift 'TK_EOC', go to state 206
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression TK_EOC]
Parser(B) >> Input 'TK_THEN' in state 206
Parser(B) >> Reduce 253 [ncl0 ::= TK_EOC] without external action, pop back to state 127.
Parser(B) >> ... then shift 'ncl0', go to state 131
Parser(B) >> Shift 'TK_THEN', go to state 109
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN]
Parser(B) >> Input 'TK_DO' in state 109
Parser(B) >> Reduce 254 [ncl0 ::=] without external action.
Parser(B) >> ... then shift 'ncl0', go to state 15
Parser(B) >> Shift 'TK_DO', go to state 113
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO]
Parser(B) >> Input 'TK_EOC' in state 113
Parser(B) >> Shift 'TK_EOC', go to state 7
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 7
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 7.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 33
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_PLUS' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 33.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Shift 'TK_PLUS', go to state 64
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL addition TK_PLUS]
Parser(B) >> Input 'TK_INTEGER' in state 64
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL addition TK_PLUS TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 64.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 64.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 64.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 64.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 64.
Parser(B) >> ... then shift 'multiplication', go to state 240
Parser(B) >> Reduce 194 [addition ::= addition TK_PLUS multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 7.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 7.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_SAY' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 7.
Parser(B) >> ... then shift 'labeled_instruction', go to state 184
Parser(B) >> Reduce 33 [instruction_list ::= labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_SAY', go to state 22
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_SAY]
Parser(B) >> Input 'TK_STRING' in state 22
Parser(B) >> Shift 'TK_STRING', go to state 111
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_SAY TK_STRING]
Parser(B) >> Input 'TK_EOC' in state 111
Parser(B) >> Reduce 179 [term ::= TK_STRING], pop back to state 22.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 22.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 22.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 22.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 22.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 22.
Parser(B) >> ... then shift 'expression', go to state 331
Parser(B) >> Reduce 160 [say ::= TK_SAY expression], pop back to state 10.
Parser(B) >> ... then shift 'say', go to state 365
Parser(B) >> Reduce 60 [keyword_instruction ::= say], pop back to state 10.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 10.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_END' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 10.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_END', go to state 129
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_END]
Parser(B) >> Input 'TK_EOC' in state 129
Parser(B) >> Reduce 73 [simple_do ::= TK_DO TK_EOC instruction_list TK_END], pop back to state 15.
Parser(B) >> ... then shift 'simple_do', go to state 102
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 406
Parser(B) >> Shift 'TK_EOC', go to state 187
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 simple_do junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 187
Parser(B) >> Reduce 70 [group ::= simple_do junk TK_EOC], pop back to state 15.
Parser(B) >> ... then shift 'group', go to state 182
Parser(B) >> Reduce 41 [instruction ::= group], pop back to state 15.
Parser(B) >> ... then shift 'instruction', go to state 175
Parser(B) >> Reduce 110 [then ::= TK_THEN ncl0 instruction], pop back to state 131.
Parser(B) >> ... then shift 'then', go to state 108
Parser(B) >> Reduce 108 [if ::= TK_IF expression ncl0 then], pop back to state 8.
Parser(B) >> ... then shift 'if', go to state 185
Parser(B) >> Reduce 72 [group ::= if], pop back to state 8.
Parser(B) >> ... then shift 'group', go to state 193
Parser(B) >> Reduce 35 [labeled_instruction ::= group], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 8.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_INTEGER' in state 33
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 8.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 8.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_INTEGER' in state 33
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 8.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_LOOP' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_LOOP', go to state 242
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_LOOP]
Parser(B) >> Input 'TK_UNTIL' in state 242
Parser(B) >> Reduce 81 [tk_doloop ::= TK_LOOP], pop back to state 8.
Parser(B) >> ... then shift 'tk_doloop', go to state 17
Parser(B) >> Shift 'TK_UNTIL', go to state 28
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop TK_UNTIL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 28
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop TK_UNTIL TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 28.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 28.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 28.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 28.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 28.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 28.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 28.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 28.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 28.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Shift 'TK_EQUAL', go to state 48
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop TK_UNTIL comparison TK_EQUAL]
Parser(B) >> Input 'TK_INTEGER' in state 48
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop TK_UNTIL comparison TK_EQUAL TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 48.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 48.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 48.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 48.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 48.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 48.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 48.
Parser(B) >> ... then shift 'concatenation', go to state 60
Parser(B) >> Reduce 212 [comparison ::= comparison TK_EQUAL concatenation], pop back to state 28.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 28.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 28.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 28.
Parser(B) >> ... then shift 'expression', go to state 396
Parser(B) >> Reduce 106 [docond ::= TK_UNTIL expression], pop back to state 17.
Parser(B) >> ... then shift 'docond', go to state 395
Parser(B) >> Shift 'TK_EOC', go to state 5
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop docond TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 5
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop docond TK_EOC TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 5.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop docond TK_EOC var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 33
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop docond TK_EOC var_symbol TK_EQUAL TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_PLUS' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 33.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Shift 'TK_PLUS', go to state 64
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop docond TK_EOC var_symbol TK_EQUAL addition TK_PLUS]
Parser(B) >> Input 'TK_INTEGER' in state 64
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop docond TK_EOC var_symbol TK_EQUAL addition TK_PLUS TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 64.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 64.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 64.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 64.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 64.
Parser(B) >> ... then shift 'multiplication', go to state 240
Parser(B) >> Reduce 194 [addition ::= addition TK_PLUS multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 5.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 5.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop docond TK_EOC single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 5.
Parser(B) >> ... then shift 'labeled_instruction', go to state 184
Parser(B) >> Reduce 33 [instruction_list ::= labeled_instruction], pop back to state 5.
Parser(B) >> ... then shift 'instruction_list', go to state 13
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop docond TK_EOC instruction_list TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 13.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop docond TK_EOC instruction_list var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 33
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop docond TK_EOC instruction_list var_symbol TK_EQUAL TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_PLUS' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 33.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Shift 'TK_PLUS', go to state 64
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop docond TK_EOC instruction_list var_symbol TK_EQUAL addition TK_PLUS]
Parser(B) >> Input 'TK_INTEGER' in state 64
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop docond TK_EOC instruction_list var_symbol TK_EQUAL addition TK_PLUS TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 64.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 64.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 64.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 64.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 64.
Parser(B) >> ... then shift 'multiplication', go to state 240
Parser(B) >> Reduce 194 [addition ::= addition TK_PLUS multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 13.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 13.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop docond TK_EOC instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_END' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 13.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 5.
Parser(B) >> ... then shift 'instruction_list', go to state 13
Parser(B) >> Shift 'TK_END', go to state 123
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop docond TK_EOC instruction_list TK_END]
Parser(B) >> Input 'TK_EOC' in state 123
Parser(B) >> Reduce 86 [do ::= tk_doloop docond TK_EOC instruction_list TK_END], pop back to state 8.
Parser(B) >> ... then shift 'do', go to state 101
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 405
Parser(B) >> Shift 'TK_EOC', go to state 186
Parser(B) >> Return. Stack=[rexx_options instruction_list do junk TK_EOC]
Parser(B) >> Input 'TK_IF' in state 186
Parser(B) >> Reduce 71 [group ::= do junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'group', go to state 193
Parser(B) >> Reduce 35 [labeled_instruction ::= group], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_IF', go to state 30
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 30
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_NEQ' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 30.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 30.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 30.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 30.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 30.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 30.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 30.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 30.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Shift 'TK_NEQ', go to state 47
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ]
Parser(B) >> Input 'TK_INTEGER' in state 47
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 47.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 47.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 47.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 47.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 47.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 47.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 47.
Parser(B) >> ... then shift 'concatenation', go to state 59
Parser(B) >> Reduce 213 [comparison ::= comparison TK_NEQ concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 30.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 30.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 30.
Parser(B) >> ... then shift 'expression', go to state 127
Parser(B) >> Shift 'TK_EOC', go to state 206
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression TK_EOC]
Parser(B) >> Input 'TK_THEN' in state 206
Parser(B) >> Reduce 253 [ncl0 ::= TK_EOC] without external action, pop back to state 127.
Parser(B) >> ... then shift 'ncl0', go to state 131
Parser(B) >> Shift 'TK_THEN', go to state 109
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN]
Parser(B) >> Input 'TK_DO' in state 109
Parser(B) >> Reduce 254 [ncl0 ::=] without external action.
Parser(B) >> ... then shift 'ncl0', go to state 15
Parser(B) >> Shift 'TK_DO', go to state 113
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO]
Parser(B) >> Input 'TK_EOC' in state 113
Parser(B) >> Shift 'TK_EOC', go to state 7
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 7
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 7.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 33
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_PLUS' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 33.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Shift 'TK_PLUS', go to state 64
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL addition TK_PLUS]
Parser(B) >> Input 'TK_INTEGER' in state 64
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL addition TK_PLUS TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 64.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 64.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 64.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 64.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 64.
Parser(B) >> ... then shift 'multiplication', go to state 240
Parser(B) >> Reduce 194 [addition ::= addition TK_PLUS multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 7.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 7.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_SAY' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 7.
Parser(B) >> ... then shift 'labeled_instruction', go to state 184
Parser(B) >> Reduce 33 [instruction_list ::= labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_SAY', go to state 22
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_SAY]
Parser(B) >> Input 'TK_STRING' in state 22
Parser(B) >> Shift 'TK_STRING', go to state 111
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_SAY TK_STRING]
Parser(B) >> Input 'TK_EOC' in state 111
Parser(B) >> Reduce 179 [term ::= TK_STRING], pop back to state 22.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 22.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 22.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 22.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 22.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 22.
Parser(B) >> ... then shift 'expression', go to state 331
Parser(B) >> Reduce 160 [say ::= TK_SAY expression], pop back to state 10.
Parser(B) >> ... then shift 'say', go to state 365
Parser(B) >> Reduce 60 [keyword_instruction ::= say], pop back to state 10.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 10.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_END' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 10.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_END', go to state 129
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_END]
Parser(B) >> Input 'TK_EOC' in state 129
Parser(B) >> Reduce 73 [simple_do ::= TK_DO TK_EOC instruction_list TK_END], pop back to state 15.
Parser(B) >> ... then shift 'simple_do', go to state 102
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 406
Parser(B) >> Shift 'TK_EOC', go to state 187
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 simple_do junk TK_EOC]
Parser(B) >> Input 'TK_IF' in state 187
Parser(B) >> Reduce 70 [group ::= simple_do junk TK_EOC], pop back to state 15.
Parser(B) >> ... then shift 'group', go to state 182
Parser(B) >> Reduce 41 [instruction ::= group], pop back to state 15.
Parser(B) >> ... then shift 'instruction', go to state 175
Parser(B) >> Reduce 110 [then ::= TK_THEN ncl0 instruction], pop back to state 131.
Parser(B) >> ... then shift 'then', go to state 108
Parser(B) >> Reduce 108 [if ::= TK_IF expression ncl0 then], pop back to state 8.
Parser(B) >> ... then shift 'if', go to state 185
Parser(B) >> Reduce 72 [group ::= if], pop back to state 8.
Parser(B) >> ... then shift 'group', go to state 193
Parser(B) >> Reduce 35 [labeled_instruction ::= group], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_IF', go to state 30
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 30
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_NEQ' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 30.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 30.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 30.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 30.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 30.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 30.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 30.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 30.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Shift 'TK_NEQ', go to state 47
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ]
Parser(B) >> Input 'TK_INTEGER' in state 47
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 47.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 47.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 47.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 47.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 47.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 47.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 47.
Parser(B) >> ... then shift 'concatenation', go to state 59
Parser(B) >> Reduce 213 [comparison ::= comparison TK_NEQ concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 30.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 30.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 30.
Parser(B) >> ... then shift 'expression', go to state 127
Parser(B) >> Shift 'TK_EOC', go to state 206
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression TK_EOC]
Parser(B) >> Input 'TK_THEN' in state 206
Parser(B) >> Reduce 253 [ncl0 ::= TK_EOC] without external action, pop back to state 127.
Parser(B) >> ... then shift 'ncl0', go to state 131
Parser(B) >> Shift 'TK_THEN', go to state 109
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN]
Parser(B) >> Input 'TK_DO' in state 109
Parser(B) >> Reduce 254 [ncl0 ::=] without external action.
Parser(B) >> ... then shift 'ncl0', go to state 15
Parser(B) >> Shift 'TK_DO', go to state 113
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO]
Parser(B) >> Input 'TK_EOC' in state 113
Parser(B) >> Shift 'TK_EOC', go to state 7
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 7
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 7.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 33
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_PLUS' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 33.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Shift 'TK_PLUS', go to state 64
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL addition TK_PLUS]
Parser(B) >> Input 'TK_INTEGER' in state 64
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL addition TK_PLUS TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 64.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 64.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 64.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 64.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 64.
Parser(B) >> ... then shift 'multiplication', go to state 240
Parser(B) >> Reduce 194 [addition ::= addition TK_PLUS multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 7.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 7.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_SAY' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 7.
Parser(B) >> ... then shift 'labeled_instruction', go to state 184
Parser(B) >> Reduce 33 [instruction_list ::= labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_SAY', go to state 22
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_SAY]
Parser(B) >> Input 'TK_STRING' in state 22
Parser(B) >> Shift 'TK_STRING', go to state 111
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_SAY TK_STRING]
Parser(B) >> Input 'TK_EOC' in state 111
Parser(B) >> Reduce 179 [term ::= TK_STRING], pop back to state 22.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 22.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 22.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 22.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 22.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 22.
Parser(B) >> ... then shift 'expression', go to state 331
Parser(B) >> Reduce 160 [say ::= TK_SAY expression], pop back to state 10.
Parser(B) >> ... then shift 'say', go to state 365
Parser(B) >> Reduce 60 [keyword_instruction ::= say], pop back to state 10.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 10.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_END' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 10.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_END', go to state 129
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_END]
Parser(B) >> Input 'TK_EOC' in state 129
Parser(B) >> Reduce 73 [simple_do ::= TK_DO TK_EOC instruction_list TK_END], pop back to state 15.
Parser(B) >> ... then shift 'simple_do', go to state 102
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 406
Parser(B) >> Shift 'TK_EOC', go to state 187
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 simple_do junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 187
Parser(B) >> Reduce 70 [group ::= simple_do junk TK_EOC], pop back to state 15.
Parser(B) >> ... then shift 'group', go to state 182
Parser(B) >> Reduce 41 [instruction ::= group], pop back to state 15.
Parser(B) >> ... then shift 'instruction', go to state 175
Parser(B) >> Reduce 110 [then ::= TK_THEN ncl0 instruction], pop back to state 131.
Parser(B) >> ... then shift 'then', go to state 108
Parser(B) >> Reduce 108 [if ::= TK_IF expression ncl0 then], pop back to state 8.
Parser(B) >> ... then shift 'if', go to state 185
Parser(B) >> Reduce 72 [group ::= if], pop back to state 8.
Parser(B) >> ... then shift 'group', go to state 193
Parser(B) >> Reduce 35 [labeled_instruction ::= group], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 8.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_INTEGER' in state 33
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 8.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 8.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_INTEGER' in state 33
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 8.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_LOOP' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_LOOP', go to state 242
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_LOOP]
Parser(B) >> Input 'TK_WHILE' in state 242
Parser(B) >> Reduce 81 [tk_doloop ::= TK_LOOP], pop back to state 8.
Parser(B) >> ... then shift 'tk_doloop', go to state 17
Parser(B) >> Shift 'TK_WHILE', go to state 29
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop TK_WHILE]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 29
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop TK_WHILE TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_LT' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 29.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 29.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 29.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 29.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 29.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 29.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 29.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 29.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 29.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Shift 'TK_LT', go to state 45
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop TK_WHILE comparison TK_LT]
Parser(B) >> Input 'TK_INTEGER' in state 45
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop TK_WHILE comparison TK_LT TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 45.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 45.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 45.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 45.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 45.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 45.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 45.
Parser(B) >> ... then shift 'concatenation', go to state 57
Parser(B) >> Reduce 215 [comparison ::= comparison TK_LT concatenation], pop back to state 29.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 29.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 29.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 29.
Parser(B) >> ... then shift 'expression', go to state 397
Parser(B) >> Reduce 105 [docond ::= TK_WHILE expression], pop back to state 17.
Parser(B) >> ... then shift 'docond', go to state 395
Parser(B) >> Shift 'TK_EOC', go to state 5
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop docond TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 5
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop docond TK_EOC TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 5.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop docond TK_EOC var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 33
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop docond TK_EOC var_symbol TK_EQUAL TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_PLUS' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 33.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Shift 'TK_PLUS', go to state 64
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop docond TK_EOC var_symbol TK_EQUAL addition TK_PLUS]
Parser(B) >> Input 'TK_INTEGER' in state 64
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop docond TK_EOC var_symbol TK_EQUAL addition TK_PLUS TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 64.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 64.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 64.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 64.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 64.
Parser(B) >> ... then shift 'multiplication', go to state 240
Parser(B) >> Reduce 194 [addition ::= addition TK_PLUS multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 5.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 5.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop docond TK_EOC single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 5.
Parser(B) >> ... then shift 'labeled_instruction', go to state 184
Parser(B) >> Reduce 33 [instruction_list ::= labeled_instruction], pop back to state 5.
Parser(B) >> ... then shift 'instruction_list', go to state 13
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop docond TK_EOC instruction_list TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 13.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop docond TK_EOC instruction_list var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 33
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop docond TK_EOC instruction_list var_symbol TK_EQUAL TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_PLUS' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 33.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Shift 'TK_PLUS', go to state 64
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop docond TK_EOC instruction_list var_symbol TK_EQUAL addition TK_PLUS]
Parser(B) >> Input 'TK_INTEGER' in state 64
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop docond TK_EOC instruction_list var_symbol TK_EQUAL addition TK_PLUS TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 64.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 64.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 64.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 64.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 64.
Parser(B) >> ... then shift 'multiplication', go to state 240
Parser(B) >> Reduce 194 [addition ::= addition TK_PLUS multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 13.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 13.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop docond TK_EOC instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_END' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 13.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 5.
Parser(B) >> ... then shift 'instruction_list', go to state 13
Parser(B) >> Shift 'TK_END', go to state 123
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop docond TK_EOC instruction_list TK_END]
Parser(B) >> Input 'TK_EOC' in state 123
Parser(B) >> Reduce 86 [do ::= tk_doloop docond TK_EOC instruction_list TK_END], pop back to state 8.
Parser(B) >> ... then shift 'do', go to state 101
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 405
Parser(B) >> Shift 'TK_EOC', go to state 186
Parser(B) >> Return. Stack=[rexx_options instruction_list do junk TK_EOC]
Parser(B) >> Input 'TK_IF' in state 186
Parser(B) >> Reduce 71 [group ::= do junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'group', go to state 193
Parser(B) >> Reduce 35 [labeled_instruction ::= group], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_IF', go to state 30
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 30
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_NEQ' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 30.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 30.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 30.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 30.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 30.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 30.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 30.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 30.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Shift 'TK_NEQ', go to state 47
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ]
Parser(B) >> Input 'TK_INTEGER' in state 47
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 47.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 47.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 47.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 47.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 47.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 47.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 47.
Parser(B) >> ... then shift 'concatenation', go to state 59
Parser(B) >> Reduce 213 [comparison ::= comparison TK_NEQ concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 30.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 30.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 30.
Parser(B) >> ... then shift 'expression', go to state 127
Parser(B) >> Shift 'TK_EOC', go to state 206
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression TK_EOC]
Parser(B) >> Input 'TK_THEN' in state 206
Parser(B) >> Reduce 253 [ncl0 ::= TK_EOC] without external action, pop back to state 127.
Parser(B) >> ... then shift 'ncl0', go to state 131
Parser(B) >> Shift 'TK_THEN', go to state 109
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN]
Parser(B) >> Input 'TK_DO' in state 109
Parser(B) >> Reduce 254 [ncl0 ::=] without external action.
Parser(B) >> ... then shift 'ncl0', go to state 15
Parser(B) >> Shift 'TK_DO', go to state 113
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO]
Parser(B) >> Input 'TK_EOC' in state 113
Parser(B) >> Shift 'TK_EOC', go to state 7
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 7
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 7.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 33
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_PLUS' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 33.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Shift 'TK_PLUS', go to state 64
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL addition TK_PLUS]
Parser(B) >> Input 'TK_INTEGER' in state 64
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL addition TK_PLUS TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 64.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 64.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 64.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 64.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 64.
Parser(B) >> ... then shift 'multiplication', go to state 240
Parser(B) >> Reduce 194 [addition ::= addition TK_PLUS multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 7.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 7.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_SAY' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 7.
Parser(B) >> ... then shift 'labeled_instruction', go to state 184
Parser(B) >> Reduce 33 [instruction_list ::= labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_SAY', go to state 22
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_SAY]
Parser(B) >> Input 'TK_STRING' in state 22
Parser(B) >> Shift 'TK_STRING', go to state 111
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_SAY TK_STRING]
Parser(B) >> Input 'TK_EOC' in state 111
Parser(B) >> Reduce 179 [term ::= TK_STRING], pop back to state 22.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 22.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 22.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 22.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 22.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 22.
Parser(B) >> ... then shift 'expression', go to state 331
Parser(B) >> Reduce 160 [say ::= TK_SAY expression], pop back to state 10.
Parser(B) >> ... then shift 'say', go to state 365
Parser(B) >> Reduce 60 [keyword_instruction ::= say], pop back to state 10.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 10.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_END' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 10.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_END', go to state 129
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_END]
Parser(B) >> Input 'TK_EOC' in state 129
Parser(B) >> Reduce 73 [simple_do ::= TK_DO TK_EOC instruction_list TK_END], pop back to state 15.
Parser(B) >> ... then shift 'simple_do', go to state 102
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 406
Parser(B) >> Shift 'TK_EOC', go to state 187
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 simple_do junk TK_EOC]
Parser(B) >> Input 'TK_IF' in state 187
Parser(B) >> Reduce 70 [group ::= simple_do junk TK_EOC], pop back to state 15.
Parser(B) >> ... then shift 'group', go to state 182
Parser(B) >> Reduce 41 [instruction ::= group], pop back to state 15.
Parser(B) >> ... then shift 'instruction', go to state 175
Parser(B) >> Reduce 110 [then ::= TK_THEN ncl0 instruction], pop back to state 131.
Parser(B) >> ... then shift 'then', go to state 108
Parser(B) >> Reduce 108 [if ::= TK_IF expression ncl0 then], pop back to state 8.
Parser(B) >> ... then shift 'if', go to state 185
Parser(B) >> Reduce 72 [group ::= if], pop back to state 8.
Parser(B) >> ... then shift 'group', go to state 193
Parser(B) >> Reduce 35 [labeled_instruction ::= group], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_IF', go to state 30
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 30
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_NEQ' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 30.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 30.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 30.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 30.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 30.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 30.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 30.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 30.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Shift 'TK_NEQ', go to state 47
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ]
Parser(B) >> Input 'TK_INTEGER' in state 47
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 47.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 47.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 47.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 47.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 47.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 47.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 47.
Parser(B) >> ... then shift 'concatenation', go to state 59
Parser(B) >> Reduce 213 [comparison ::= comparison TK_NEQ concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 30.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 30.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 30.
Parser(B) >> ... then shift 'expression', go to state 127
Parser(B) >> Shift 'TK_EOC', go to state 206
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression TK_EOC]
Parser(B) >> Input 'TK_THEN' in state 206
Parser(B) >> Reduce 253 [ncl0 ::= TK_EOC] without external action, pop back to state 127.
Parser(B) >> ... then shift 'ncl0', go to state 131
Parser(B) >> Shift 'TK_THEN', go to state 109
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN]
Parser(B) >> Input 'TK_DO' in state 109
Parser(B) >> Reduce 254 [ncl0 ::=] without external action.
Parser(B) >> ... then shift 'ncl0', go to state 15
Parser(B) >> Shift 'TK_DO', go to state 113
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO]
Parser(B) >> Input 'TK_EOC' in state 113
Parser(B) >> Shift 'TK_EOC', go to state 7
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 7
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 7.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 33
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_PLUS' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 33.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Shift 'TK_PLUS', go to state 64
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL addition TK_PLUS]
Parser(B) >> Input 'TK_INTEGER' in state 64
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL addition TK_PLUS TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 64.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 64.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 64.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 64.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 64.
Parser(B) >> ... then shift 'multiplication', go to state 240
Parser(B) >> Reduce 194 [addition ::= addition TK_PLUS multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 7.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 7.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_SAY' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 7.
Parser(B) >> ... then shift 'labeled_instruction', go to state 184
Parser(B) >> Reduce 33 [instruction_list ::= labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_SAY', go to state 22
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_SAY]
Parser(B) >> Input 'TK_STRING' in state 22
Parser(B) >> Shift 'TK_STRING', go to state 111
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_SAY TK_STRING]
Parser(B) >> Input 'TK_EOC' in state 111
Parser(B) >> Reduce 179 [term ::= TK_STRING], pop back to state 22.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 22.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 22.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 22.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 22.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 22.
Parser(B) >> ... then shift 'expression', go to state 331
Parser(B) >> Reduce 160 [say ::= TK_SAY expression], pop back to state 10.
Parser(B) >> ... then shift 'say', go to state 365
Parser(B) >> Reduce 60 [keyword_instruction ::= say], pop back to state 10.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 10.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_END' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 10.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_END', go to state 129
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_END]
Parser(B) >> Input 'TK_EOC' in state 129
Parser(B) >> Reduce 73 [simple_do ::= TK_DO TK_EOC instruction_list TK_END], pop back to state 15.
Parser(B) >> ... then shift 'simple_do', go to state 102
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 406
Parser(B) >> Shift 'TK_EOC', go to state 187
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 simple_do junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 187
Parser(B) >> Reduce 70 [group ::= simple_do junk TK_EOC], pop back to state 15.
Parser(B) >> ... then shift 'group', go to state 182
Parser(B) >> Reduce 41 [instruction ::= group], pop back to state 15.
Parser(B) >> ... then shift 'instruction', go to state 175
Parser(B) >> Reduce 110 [then ::= TK_THEN ncl0 instruction], pop back to state 131.
Parser(B) >> ... then shift 'then', go to state 108
Parser(B) >> Reduce 108 [if ::= TK_IF expression ncl0 then], pop back to state 8.
Parser(B) >> ... then shift 'if', go to state 185
Parser(B) >> Reduce 72 [group ::= if], pop back to state 8.
Parser(B) >> ... then shift 'group', go to state 193
Parser(B) >> Reduce 35 [labeled_instruction ::= group], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 8.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_INTEGER' in state 33
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 8.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 8.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_INTEGER' in state 33
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 8.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_LOOP' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_LOOP', go to state 242
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_LOOP]
Parser(B) >> Input 'TK_WHILE' in state 242
Parser(B) >> Reduce 81 [tk_doloop ::= TK_LOOP], pop back to state 8.
Parser(B) >> ... then shift 'tk_doloop', go to state 17
Parser(B) >> Shift 'TK_WHILE', go to state 29
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop TK_WHILE]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 29
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop TK_WHILE TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_LT' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 29.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 29.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 29.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 29.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 29.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 29.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 29.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 29.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 29.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Shift 'TK_LT', go to state 45
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop TK_WHILE comparison TK_LT]
Parser(B) >> Input 'TK_INTEGER' in state 45
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop TK_WHILE comparison TK_LT TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 45.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 45.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 45.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 45.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 45.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 45.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 45.
Parser(B) >> ... then shift 'concatenation', go to state 57
Parser(B) >> Reduce 215 [comparison ::= comparison TK_LT concatenation], pop back to state 29.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 29.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 29.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 29.
Parser(B) >> ... then shift 'expression', go to state 397
Parser(B) >> Reduce 105 [docond ::= TK_WHILE expression], pop back to state 17.
Parser(B) >> ... then shift 'docond', go to state 395
Parser(B) >> Shift 'TK_EOC', go to state 5
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop docond TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 5
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop docond TK_EOC TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 5.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop docond TK_EOC var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 33
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop docond TK_EOC var_symbol TK_EQUAL TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_PLUS' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 33.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Shift 'TK_PLUS', go to state 64
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop docond TK_EOC var_symbol TK_EQUAL addition TK_PLUS]
Parser(B) >> Input 'TK_INTEGER' in state 64
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop docond TK_EOC var_symbol TK_EQUAL addition TK_PLUS TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 64.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 64.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 64.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 64.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 64.
Parser(B) >> ... then shift 'multiplication', go to state 240
Parser(B) >> Reduce 194 [addition ::= addition TK_PLUS multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 5.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 5.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop docond TK_EOC single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_IF' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 5.
Parser(B) >> ... then shift 'labeled_instruction', go to state 184
Parser(B) >> Reduce 33 [instruction_list ::= labeled_instruction], pop back to state 5.
Parser(B) >> ... then shift 'instruction_list', go to state 13
Parser(B) >> Shift 'TK_IF', go to state 30
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop docond TK_EOC instruction_list TK_IF]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 30
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop docond TK_EOC instruction_list TK_IF TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 30.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 30.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 30.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 30.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 30.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 30.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 30.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 30.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Shift 'TK_EQUAL', go to state 48
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop docond TK_EOC instruction_list TK_IF comparison TK_EQUAL]
Parser(B) >> Input 'TK_INTEGER' in state 48
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop docond TK_EOC instruction_list TK_IF comparison TK_EQUAL TK_INTEGER]
Parser(B) >> Input 'TK_THEN' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 48.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 48.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 48.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 48.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 48.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 48.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 48.
Parser(B) >> ... then shift 'concatenation', go to state 60
Parser(B) >> Reduce 212 [comparison ::= comparison TK_EQUAL concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 30.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 30.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 30.
Parser(B) >> ... then shift 'expression', go to state 127
Parser(B) >> Reduce 254 [ncl0 ::=] without external action.
Parser(B) >> ... then shift 'ncl0', go to state 131
Parser(B) >> Shift 'TK_THEN', go to state 109
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop docond TK_EOC instruction_list TK_IF expression ncl0 TK_THEN]
Parser(B) >> Input 'TK_LEAVE' in state 109
Parser(B) >> Reduce 254 [ncl0 ::=] without external action.
Parser(B) >> ... then shift 'ncl0', go to state 15
Parser(B) >> Shift 'TK_LEAVE', go to state 117
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop docond TK_EOC instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_LEAVE]
Parser(B) >> Input 'TK_EOC' in state 117
Parser(B) >> Reduce 157 [leave ::= TK_LEAVE], pop back to state 15.
Parser(B) >> ... then shift 'leave', go to state 369
Parser(B) >> Reduce 56 [keyword_instruction ::= leave], pop back to state 15.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 15.
Parser(B) >> ... then shift 'single_instruction', go to state 100
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 404
Parser(B) >> Shift 'TK_EOC', go to state 181
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop docond TK_EOC instruction_list TK_IF expression ncl0 TK_THEN ncl0 single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 181
Parser(B) >> Reduce 42 [instruction ::= single_instruction junk TK_EOC], pop back to state 15.
Parser(B) >> ... then shift 'instruction', go to state 175
Parser(B) >> Reduce 110 [then ::= TK_THEN ncl0 instruction], pop back to state 131.
Parser(B) >> ... then shift 'then', go to state 108
Parser(B) >> Reduce 108 [if ::= TK_IF expression ncl0 then], pop back to state 13.
Parser(B) >> ... then shift 'if', go to state 185
Parser(B) >> Reduce 72 [group ::= if], pop back to state 13.
Parser(B) >> ... then shift 'group', go to state 193
Parser(B) >> Reduce 35 [labeled_instruction ::= group], pop back to state 13.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 5.
Parser(B) >> ... then shift 'instruction_list', go to state 13
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop docond TK_EOC instruction_list TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 13.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop docond TK_EOC instruction_list var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 33
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop docond TK_EOC instruction_list var_symbol TK_EQUAL TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_PLUS' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 33.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Shift 'TK_PLUS', go to state 64
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop docond TK_EOC instruction_list var_symbol TK_EQUAL addition TK_PLUS]
Parser(B) >> Input 'TK_INTEGER' in state 64
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop docond TK_EOC instruction_list var_symbol TK_EQUAL addition TK_PLUS TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 64.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 64.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 64.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 64.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 64.
Parser(B) >> ... then shift 'multiplication', go to state 240
Parser(B) >> Reduce 194 [addition ::= addition TK_PLUS multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 13.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 13.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop docond TK_EOC instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_END' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 13.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 5.
Parser(B) >> ... then shift 'instruction_list', go to state 13
Parser(B) >> Shift 'TK_END', go to state 123
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop docond TK_EOC instruction_list TK_END]
Parser(B) >> Input 'TK_EOC' in state 123
Parser(B) >> Reduce 86 [do ::= tk_doloop docond TK_EOC instruction_list TK_END], pop back to state 8.
Parser(B) >> ... then shift 'do', go to state 101
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 405
Parser(B) >> Shift 'TK_EOC', go to state 186
Parser(B) >> Return. Stack=[rexx_options instruction_list do junk TK_EOC]
Parser(B) >> Input 'TK_IF' in state 186
Parser(B) >> Reduce 71 [group ::= do junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'group', go to state 193
Parser(B) >> Reduce 35 [labeled_instruction ::= group], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_IF', go to state 30
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 30
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_NEQ' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 30.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 30.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 30.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 30.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 30.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 30.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 30.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 30.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Shift 'TK_NEQ', go to state 47
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ]
Parser(B) >> Input 'TK_INTEGER' in state 47
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 47.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 47.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 47.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 47.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 47.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 47.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 47.
Parser(B) >> ... then shift 'concatenation', go to state 59
Parser(B) >> Reduce 213 [comparison ::= comparison TK_NEQ concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 30.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 30.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 30.
Parser(B) >> ... then shift 'expression', go to state 127
Parser(B) >> Shift 'TK_EOC', go to state 206
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression TK_EOC]
Parser(B) >> Input 'TK_THEN' in state 206
Parser(B) >> Reduce 253 [ncl0 ::= TK_EOC] without external action, pop back to state 127.
Parser(B) >> ... then shift 'ncl0', go to state 131
Parser(B) >> Shift 'TK_THEN', go to state 109
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN]
Parser(B) >> Input 'TK_DO' in state 109
Parser(B) >> Reduce 254 [ncl0 ::=] without external action.
Parser(B) >> ... then shift 'ncl0', go to state 15
Parser(B) >> Shift 'TK_DO', go to state 113
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO]
Parser(B) >> Input 'TK_EOC' in state 113
Parser(B) >> Shift 'TK_EOC', go to state 7
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 7
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 7.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 33
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_PLUS' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 33.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Shift 'TK_PLUS', go to state 64
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL addition TK_PLUS]
Parser(B) >> Input 'TK_INTEGER' in state 64
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL addition TK_PLUS TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 64.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 64.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 64.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 64.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 64.
Parser(B) >> ... then shift 'multiplication', go to state 240
Parser(B) >> Reduce 194 [addition ::= addition TK_PLUS multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 7.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 7.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_SAY' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 7.
Parser(B) >> ... then shift 'labeled_instruction', go to state 184
Parser(B) >> Reduce 33 [instruction_list ::= labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_SAY', go to state 22
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_SAY]
Parser(B) >> Input 'TK_STRING' in state 22
Parser(B) >> Shift 'TK_STRING', go to state 111
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_SAY TK_STRING]
Parser(B) >> Input 'TK_EOC' in state 111
Parser(B) >> Reduce 179 [term ::= TK_STRING], pop back to state 22.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 22.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 22.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 22.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 22.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 22.
Parser(B) >> ... then shift 'expression', go to state 331
Parser(B) >> Reduce 160 [say ::= TK_SAY expression], pop back to state 10.
Parser(B) >> ... then shift 'say', go to state 365
Parser(B) >> Reduce 60 [keyword_instruction ::= say], pop back to state 10.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 10.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_END' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 10.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_END', go to state 129
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_END]
Parser(B) >> Input 'TK_EOC' in state 129
Parser(B) >> Reduce 73 [simple_do ::= TK_DO TK_EOC instruction_list TK_END], pop back to state 15.
Parser(B) >> ... then shift 'simple_do', go to state 102
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 406
Parser(B) >> Shift 'TK_EOC', go to state 187
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 simple_do junk TK_EOC]
Parser(B) >> Input 'TK_IF' in state 187
Parser(B) >> Reduce 70 [group ::= simple_do junk TK_EOC], pop back to state 15.
Parser(B) >> ... then shift 'group', go to state 182
Parser(B) >> Reduce 41 [instruction ::= group], pop back to state 15.
Parser(B) >> ... then shift 'instruction', go to state 175
Parser(B) >> Reduce 110 [then ::= TK_THEN ncl0 instruction], pop back to state 131.
Parser(B) >> ... then shift 'then', go to state 108
Parser(B) >> Reduce 108 [if ::= TK_IF expression ncl0 then], pop back to state 8.
Parser(B) >> ... then shift 'if', go to state 185
Parser(B) >> Reduce 72 [group ::= if], pop back to state 8.
Parser(B) >> ... then shift 'group', go to state 193
Parser(B) >> Reduce 35 [labeled_instruction ::= group], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_IF', go to state 30
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 30
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_NEQ' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 30.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 30.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 30.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 30.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 30.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 30.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 30.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 30.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Shift 'TK_NEQ', go to state 47
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ]
Parser(B) >> Input 'TK_INTEGER' in state 47
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 47.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 47.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 47.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 47.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 47.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 47.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 47.
Parser(B) >> ... then shift 'concatenation', go to state 59
Parser(B) >> Reduce 213 [comparison ::= comparison TK_NEQ concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 30.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 30.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 30.
Parser(B) >> ... then shift 'expression', go to state 127
Parser(B) >> Shift 'TK_EOC', go to state 206
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression TK_EOC]
Parser(B) >> Input 'TK_THEN' in state 206
Parser(B) >> Reduce 253 [ncl0 ::= TK_EOC] without external action, pop back to state 127.
Parser(B) >> ... then shift 'ncl0', go to state 131
Parser(B) >> Shift 'TK_THEN', go to state 109
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN]
Parser(B) >> Input 'TK_DO' in state 109
Parser(B) >> Reduce 254 [ncl0 ::=] without external action.
Parser(B) >> ... then shift 'ncl0', go to state 15
Parser(B) >> Shift 'TK_DO', go to state 113
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO]
Parser(B) >> Input 'TK_EOC' in state 113
Parser(B) >> Shift 'TK_EOC', go to state 7
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 7
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 7.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 33
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_PLUS' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 33.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Shift 'TK_PLUS', go to state 64
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL addition TK_PLUS]
Parser(B) >> Input 'TK_INTEGER' in state 64
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL addition TK_PLUS TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 64.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 64.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 64.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 64.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 64.
Parser(B) >> ... then shift 'multiplication', go to state 240
Parser(B) >> Reduce 194 [addition ::= addition TK_PLUS multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 7.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 7.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_SAY' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 7.
Parser(B) >> ... then shift 'labeled_instruction', go to state 184
Parser(B) >> Reduce 33 [instruction_list ::= labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_SAY', go to state 22
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_SAY]
Parser(B) >> Input 'TK_STRING' in state 22
Parser(B) >> Shift 'TK_STRING', go to state 111
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_SAY TK_STRING]
Parser(B) >> Input 'TK_EOC' in state 111
Parser(B) >> Reduce 179 [term ::= TK_STRING], pop back to state 22.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 22.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 22.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 22.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 22.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 22.
Parser(B) >> ... then shift 'expression', go to state 331
Parser(B) >> Reduce 160 [say ::= TK_SAY expression], pop back to state 10.
Parser(B) >> ... then shift 'say', go to state 365
Parser(B) >> Reduce 60 [keyword_instruction ::= say], pop back to state 10.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 10.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_END' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 10.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_END', go to state 129
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_END]
Parser(B) >> Input 'TK_EOC' in state 129
Parser(B) >> Reduce 73 [simple_do ::= TK_DO TK_EOC instruction_list TK_END], pop back to state 15.
Parser(B) >> ... then shift 'simple_do', go to state 102
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 406
Parser(B) >> Shift 'TK_EOC', go to state 187
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 simple_do junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 187
Parser(B) >> Reduce 70 [group ::= simple_do junk TK_EOC], pop back to state 15.
Parser(B) >> ... then shift 'group', go to state 182
Parser(B) >> Reduce 41 [instruction ::= group], pop back to state 15.
Parser(B) >> ... then shift 'instruction', go to state 175
Parser(B) >> Reduce 110 [then ::= TK_THEN ncl0 instruction], pop back to state 131.
Parser(B) >> ... then shift 'then', go to state 108
Parser(B) >> Reduce 108 [if ::= TK_IF expression ncl0 then], pop back to state 8.
Parser(B) >> ... then shift 'if', go to state 185
Parser(B) >> Reduce 72 [group ::= if], pop back to state 8.
Parser(B) >> ... then shift 'group', go to state 193
Parser(B) >> Reduce 35 [labeled_instruction ::= group], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 8.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_INTEGER' in state 33
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 8.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 8.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_STRING' in state 33
Parser(B) >> Shift 'TK_STRING', go to state 111
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL TK_STRING]
Parser(B) >> Input 'TK_EOC' in state 111
Parser(B) >> Reduce 179 [term ::= TK_STRING], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 8.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 8.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_STRING' in state 33
Parser(B) >> Shift 'TK_STRING', go to state 111
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL TK_STRING]
Parser(B) >> Input 'TK_EOC' in state 111
Parser(B) >> Reduce 179 [term ::= TK_STRING], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 8.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_LOOP' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_LOOP', go to state 242
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_LOOP]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 242
Parser(B) >> Reduce 81 [tk_doloop ::= TK_LOOP], pop back to state 8.
Parser(B) >> ... then shift 'tk_doloop', go to state 17
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 17.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_INTEGER' in state 33
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop var_symbol TK_EQUAL TK_INTEGER]
Parser(B) >> Input 'TK_TO' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 17.
Parser(B) >> ... then shift 'assignment', go to state 86
Parser(B) >> Shift 'TK_TO', go to state 27
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop assignment TK_TO]
Parser(B) >> Input 'TK_INTEGER' in state 27
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop assignment TK_TO TK_INTEGER]
Parser(B) >> Input 'TK_BY' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 27.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 27.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 27.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 27.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 27.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 27.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 27.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 27.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 27.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 27.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 27.
Parser(B) >> ... then shift 'expression', go to state 286
Parser(B) >> Reduce 101 [dorep_item ::= TK_TO expression], pop back to state 86.
Parser(B) >> ... then shift 'dorep_item', go to state 283
Parser(B) >> Reduce 99 [dorep_list ::= dorep_item], pop back to state 86.
Parser(B) >> ... then shift 'dorep_list', go to state 114
Parser(B) >> Shift 'TK_BY', go to state 26
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop assignment dorep_list TK_BY]
Parser(B) >> Input 'TK_INTEGER' in state 26
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop assignment dorep_list TK_BY TK_INTEGER]
Parser(B) >> Input 'TK_WHILE' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 26.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 26.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 26.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 26.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 26.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 26.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 26.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 26.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 26.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 26.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 26.
Parser(B) >> ... then shift 'expression', go to state 285
Parser(B) >> Reduce 102 [dorep_item ::= TK_BY expression], pop back to state 114.
Parser(B) >> ... then shift 'dorep_item', go to state 287
Parser(B) >> Reduce 100 [dorep_list ::= dorep_list dorep_item], pop back to state 86.
Parser(B) >> ... then shift 'dorep_list', go to state 114
Parser(B) >> Reduce 98 [dorep ::= assignment dorep_list], pop back to state 17.
Parser(B) >> ... then shift 'dorep', go to state 96
Parser(B) >> Shift 'TK_WHILE', go to state 29
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_WHILE]
Parser(B) >> Input 'TK_OPEN_BRACKET' in state 29
Parser(B) >> Shift 'TK_OPEN_BRACKET', go to state 34
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_WHILE TK_OPEN_BRACKET]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 34
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_WHILE TK_OPEN_BRACKET TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_LTE' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 34.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 34.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 34.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 34.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 34.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 34.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 34.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 34.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 34.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Shift 'TK_LTE', go to state 43
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_WHILE TK_OPEN_BRACKET comparison TK_LTE]
Parser(B) >> Input 'TK_INTEGER' in state 43
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_WHILE TK_OPEN_BRACKET comparison TK_LTE TK_INTEGER]
Parser(B) >> Input 'TK_CLOSE_BRACKET' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 43.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 43.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 43.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 43.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 43.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 43.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 43.
Parser(B) >> ... then shift 'concatenation', go to state 55
Parser(B) >> Reduce 217 [comparison ::= comparison TK_LTE concatenation], pop back to state 34.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 34.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 34.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 34.
Parser(B) >> ... then shift 'expression', go to state 408
Parser(B) >> Shift 'TK_CLOSE_BRACKET', go to state 228
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_WHILE TK_OPEN_BRACKET expression TK_CLOSE_BRACKET]
Parser(B) >> Input 'TK_EOC' in state 228
Parser(B) >> Reduce 181 [bracket ::= TK_OPEN_BRACKET expression TK_CLOSE_BRACKET], pop back to state 29.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 29.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 29.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 29.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 29.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 29.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 29.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 29.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 29.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 29.
Parser(B) >> ... then shift 'expression', go to state 397
Parser(B) >> Reduce 105 [docond ::= TK_WHILE expression], pop back to state 96.
Parser(B) >> ... then shift 'docond', go to state 398
Parser(B) >> Shift 'TK_EOC', go to state 6
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep docond TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 6
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep docond TK_EOC TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 6.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep docond TK_EOC var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 33
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep docond TK_EOC var_symbol TK_EQUAL TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_PLUS' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 33.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Shift 'TK_PLUS', go to state 64
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep docond TK_EOC var_symbol TK_EQUAL addition TK_PLUS]
Parser(B) >> Input 'TK_INTEGER' in state 64
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep docond TK_EOC var_symbol TK_EQUAL addition TK_PLUS TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 64.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 64.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 64.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 64.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 64.
Parser(B) >> ... then shift 'multiplication', go to state 240
Parser(B) >> Reduce 194 [addition ::= addition TK_PLUS multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 6.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 6.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep docond TK_EOC single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_END' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 6.
Parser(B) >> ... then shift 'labeled_instruction', go to state 184
Parser(B) >> Reduce 33 [instruction_list ::= labeled_instruction], pop back to state 6.
Parser(B) >> ... then shift 'instruction_list', go to state 14
Parser(B) >> Shift 'TK_END', go to state 125
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep docond TK_EOC instruction_list TK_END]
Parser(B) >> Input 'TK_EOC' in state 125
Parser(B) >> Reduce 84 [do ::= tk_doloop dorep docond TK_EOC instruction_list TK_END], pop back to state 8.
Parser(B) >> ... then shift 'do', go to state 101
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 405
Parser(B) >> Shift 'TK_EOC', go to state 186
Parser(B) >> Return. Stack=[rexx_options instruction_list do junk TK_EOC]
Parser(B) >> Input 'TK_IF' in state 186
Parser(B) >> Reduce 71 [group ::= do junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'group', go to state 193
Parser(B) >> Reduce 35 [labeled_instruction ::= group], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_IF', go to state 30
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 30
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_NEQ' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 30.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 30.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 30.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 30.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 30.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 30.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 30.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 30.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Shift 'TK_NEQ', go to state 47
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ]
Parser(B) >> Input 'TK_INTEGER' in state 47
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 47.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 47.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 47.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 47.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 47.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 47.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 47.
Parser(B) >> ... then shift 'concatenation', go to state 59
Parser(B) >> Reduce 213 [comparison ::= comparison TK_NEQ concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 30.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 30.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 30.
Parser(B) >> ... then shift 'expression', go to state 127
Parser(B) >> Shift 'TK_EOC', go to state 206
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression TK_EOC]
Parser(B) >> Input 'TK_THEN' in state 206
Parser(B) >> Reduce 253 [ncl0 ::= TK_EOC] without external action, pop back to state 127.
Parser(B) >> ... then shift 'ncl0', go to state 131
Parser(B) >> Shift 'TK_THEN', go to state 109
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN]
Parser(B) >> Input 'TK_DO' in state 109
Parser(B) >> Reduce 254 [ncl0 ::=] without external action.
Parser(B) >> ... then shift 'ncl0', go to state 15
Parser(B) >> Shift 'TK_DO', go to state 113
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO]
Parser(B) >> Input 'TK_EOC' in state 113
Parser(B) >> Shift 'TK_EOC', go to state 7
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 7
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 7.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 33
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_PLUS' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 33.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Shift 'TK_PLUS', go to state 64
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL addition TK_PLUS]
Parser(B) >> Input 'TK_INTEGER' in state 64
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL addition TK_PLUS TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 64.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 64.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 64.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 64.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 64.
Parser(B) >> ... then shift 'multiplication', go to state 240
Parser(B) >> Reduce 194 [addition ::= addition TK_PLUS multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 7.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 7.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_SAY' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 7.
Parser(B) >> ... then shift 'labeled_instruction', go to state 184
Parser(B) >> Reduce 33 [instruction_list ::= labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_SAY', go to state 22
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_SAY]
Parser(B) >> Input 'TK_STRING' in state 22
Parser(B) >> Shift 'TK_STRING', go to state 111
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_SAY TK_STRING]
Parser(B) >> Input 'TK_EOC' in state 111
Parser(B) >> Reduce 179 [term ::= TK_STRING], pop back to state 22.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 22.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 22.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 22.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 22.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 22.
Parser(B) >> ... then shift 'expression', go to state 331
Parser(B) >> Reduce 160 [say ::= TK_SAY expression], pop back to state 10.
Parser(B) >> ... then shift 'say', go to state 365
Parser(B) >> Reduce 60 [keyword_instruction ::= say], pop back to state 10.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 10.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_END' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 10.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_END', go to state 129
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_END]
Parser(B) >> Input 'TK_EOC' in state 129
Parser(B) >> Reduce 73 [simple_do ::= TK_DO TK_EOC instruction_list TK_END], pop back to state 15.
Parser(B) >> ... then shift 'simple_do', go to state 102
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 406
Parser(B) >> Shift 'TK_EOC', go to state 187
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 simple_do junk TK_EOC]
Parser(B) >> Input 'TK_IF' in state 187
Parser(B) >> Reduce 70 [group ::= simple_do junk TK_EOC], pop back to state 15.
Parser(B) >> ... then shift 'group', go to state 182
Parser(B) >> Reduce 41 [instruction ::= group], pop back to state 15.
Parser(B) >> ... then shift 'instruction', go to state 175
Parser(B) >> Reduce 110 [then ::= TK_THEN ncl0 instruction], pop back to state 131.
Parser(B) >> ... then shift 'then', go to state 108
Parser(B) >> Reduce 108 [if ::= TK_IF expression ncl0 then], pop back to state 8.
Parser(B) >> ... then shift 'if', go to state 185
Parser(B) >> Reduce 72 [group ::= if], pop back to state 8.
Parser(B) >> ... then shift 'group', go to state 193
Parser(B) >> Reduce 35 [labeled_instruction ::= group], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_IF', go to state 30
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 30
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_NEQ' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 30.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 30.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 30.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 30.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 30.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 30.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 30.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 30.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Shift 'TK_NEQ', go to state 47
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ]
Parser(B) >> Input 'TK_INTEGER' in state 47
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 47.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 47.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 47.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 47.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 47.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 47.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 47.
Parser(B) >> ... then shift 'concatenation', go to state 59
Parser(B) >> Reduce 213 [comparison ::= comparison TK_NEQ concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 30.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 30.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 30.
Parser(B) >> ... then shift 'expression', go to state 127
Parser(B) >> Shift 'TK_EOC', go to state 206
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression TK_EOC]
Parser(B) >> Input 'TK_THEN' in state 206
Parser(B) >> Reduce 253 [ncl0 ::= TK_EOC] without external action, pop back to state 127.
Parser(B) >> ... then shift 'ncl0', go to state 131
Parser(B) >> Shift 'TK_THEN', go to state 109
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN]
Parser(B) >> Input 'TK_DO' in state 109
Parser(B) >> Reduce 254 [ncl0 ::=] without external action.
Parser(B) >> ... then shift 'ncl0', go to state 15
Parser(B) >> Shift 'TK_DO', go to state 113
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO]
Parser(B) >> Input 'TK_EOC' in state 113
Parser(B) >> Shift 'TK_EOC', go to state 7
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 7
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 7.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 33
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_PLUS' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 33.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Shift 'TK_PLUS', go to state 64
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL addition TK_PLUS]
Parser(B) >> Input 'TK_INTEGER' in state 64
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL addition TK_PLUS TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 64.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 64.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 64.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 64.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 64.
Parser(B) >> ... then shift 'multiplication', go to state 240
Parser(B) >> Reduce 194 [addition ::= addition TK_PLUS multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 7.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 7.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_SAY' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 7.
Parser(B) >> ... then shift 'labeled_instruction', go to state 184
Parser(B) >> Reduce 33 [instruction_list ::= labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_SAY', go to state 22
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_SAY]
Parser(B) >> Input 'TK_STRING' in state 22
Parser(B) >> Shift 'TK_STRING', go to state 111
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_SAY TK_STRING]
Parser(B) >> Input 'TK_EOC' in state 111
Parser(B) >> Reduce 179 [term ::= TK_STRING], pop back to state 22.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 22.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 22.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 22.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 22.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 22.
Parser(B) >> ... then shift 'expression', go to state 331
Parser(B) >> Reduce 160 [say ::= TK_SAY expression], pop back to state 10.
Parser(B) >> ... then shift 'say', go to state 365
Parser(B) >> Reduce 60 [keyword_instruction ::= say], pop back to state 10.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 10.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_END' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 10.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_END', go to state 129
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_END]
Parser(B) >> Input 'TK_EOC' in state 129
Parser(B) >> Reduce 73 [simple_do ::= TK_DO TK_EOC instruction_list TK_END], pop back to state 15.
Parser(B) >> ... then shift 'simple_do', go to state 102
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 406
Parser(B) >> Shift 'TK_EOC', go to state 187
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 simple_do junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 187
Parser(B) >> Reduce 70 [group ::= simple_do junk TK_EOC], pop back to state 15.
Parser(B) >> ... then shift 'group', go to state 182
Parser(B) >> Reduce 41 [instruction ::= group], pop back to state 15.
Parser(B) >> ... then shift 'instruction', go to state 175
Parser(B) >> Reduce 110 [then ::= TK_THEN ncl0 instruction], pop back to state 131.
Parser(B) >> ... then shift 'then', go to state 108
Parser(B) >> Reduce 108 [if ::= TK_IF expression ncl0 then], pop back to state 8.
Parser(B) >> ... then shift 'if', go to state 185
Parser(B) >> Reduce 72 [group ::= if], pop back to state 8.
Parser(B) >> ... then shift 'group', go to state 193
Parser(B) >> Reduce 35 [labeled_instruction ::= group], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 8.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_INTEGER' in state 33
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 8.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 8.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_INTEGER' in state 33
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 8.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_LOOP' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_LOOP', go to state 242
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_LOOP]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 242
Parser(B) >> Reduce 81 [tk_doloop ::= TK_LOOP], pop back to state 8.
Parser(B) >> ... then shift 'tk_doloop', go to state 17
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 17.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_INTEGER' in state 33
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop var_symbol TK_EQUAL TK_INTEGER]
Parser(B) >> Input 'TK_MINUS' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Shift 'TK_MINUS', go to state 63
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop var_symbol TK_EQUAL addition TK_MINUS]
Parser(B) >> Input 'TK_INTEGER' in state 63
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop var_symbol TK_EQUAL addition TK_MINUS TK_INTEGER]
Parser(B) >> Input 'TK_TO' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 63.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 63.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 63.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 63.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 63.
Parser(B) >> ... then shift 'multiplication', go to state 239
Parser(B) >> Reduce 195 [addition ::= addition TK_MINUS multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 17.
Parser(B) >> ... then shift 'assignment', go to state 86
Parser(B) >> Shift 'TK_TO', go to state 27
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop assignment TK_TO]
Parser(B) >> Input 'TK_OPEN_BRACKET' in state 27
Parser(B) >> Shift 'TK_OPEN_BRACKET', go to state 34
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop assignment TK_TO TK_OPEN_BRACKET]
Parser(B) >> Input 'TK_INTEGER' in state 34
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop assignment TK_TO TK_OPEN_BRACKET TK_INTEGER]
Parser(B) >> Input 'TK_MINUS' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 34.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 34.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 34.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 34.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 34.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 34.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Shift 'TK_MINUS', go to state 63
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop assignment TK_TO TK_OPEN_BRACKET addition TK_MINUS]
Parser(B) >> Input 'TK_INTEGER' in state 63
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop assignment TK_TO TK_OPEN_BRACKET addition TK_MINUS TK_INTEGER]
Parser(B) >> Input 'TK_CLOSE_BRACKET' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 63.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 63.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 63.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 63.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 63.
Parser(B) >> ... then shift 'multiplication', go to state 239
Parser(B) >> Reduce 195 [addition ::= addition TK_MINUS multiplication], pop back to state 34.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 34.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 34.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 34.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 34.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 34.
Parser(B) >> ... then shift 'expression', go to state 408
Parser(B) >> Shift 'TK_CLOSE_BRACKET', go to state 228
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop assignment TK_TO TK_OPEN_BRACKET expression TK_CLOSE_BRACKET]
Parser(B) >> Input 'TK_BY' in state 228
Parser(B) >> Reduce 181 [bracket ::= TK_OPEN_BRACKET expression TK_CLOSE_BRACKET], pop back to state 27.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 27.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 27.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 27.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 27.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 27.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 27.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 27.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 27.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 27.
Parser(B) >> ... then shift 'expression', go to state 286
Parser(B) >> Reduce 101 [dorep_item ::= TK_TO expression], pop back to state 86.
Parser(B) >> ... then shift 'dorep_item', go to state 283
Parser(B) >> Reduce 99 [dorep_list ::= dorep_item], pop back to state 86.
Parser(B) >> ... then shift 'dorep_list', go to state 114
Parser(B) >> Shift 'TK_BY', go to state 26
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop assignment dorep_list TK_BY]
Parser(B) >> Input 'TK_INTEGER' in state 26
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop assignment dorep_list TK_BY TK_INTEGER]
Parser(B) >> Input 'TK_MINUS' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 26.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 26.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 26.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 26.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 26.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 26.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Shift 'TK_MINUS', go to state 63
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop assignment dorep_list TK_BY addition TK_MINUS]
Parser(B) >> Input 'TK_INTEGER' in state 63
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop assignment dorep_list TK_BY addition TK_MINUS TK_INTEGER]
Parser(B) >> Input 'TK_UNTIL' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 63.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 63.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 63.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 63.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 63.
Parser(B) >> ... then shift 'multiplication', go to state 239
Parser(B) >> Reduce 195 [addition ::= addition TK_MINUS multiplication], pop back to state 26.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 26.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 26.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 26.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 26.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 26.
Parser(B) >> ... then shift 'expression', go to state 285
Parser(B) >> Reduce 102 [dorep_item ::= TK_BY expression], pop back to state 114.
Parser(B) >> ... then shift 'dorep_item', go to state 287
Parser(B) >> Reduce 100 [dorep_list ::= dorep_list dorep_item], pop back to state 86.
Parser(B) >> ... then shift 'dorep_list', go to state 114
Parser(B) >> Reduce 98 [dorep ::= assignment dorep_list], pop back to state 17.
Parser(B) >> ... then shift 'dorep', go to state 96
Parser(B) >> Shift 'TK_UNTIL', go to state 28
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_UNTIL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 28
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_UNTIL TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_LT' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 28.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 28.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 28.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 28.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 28.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 28.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 28.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 28.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 28.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Shift 'TK_LT', go to state 45
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_UNTIL comparison TK_LT]
Parser(B) >> Input 'TK_MINUS' in state 45
Parser(B) >> Shift 'TK_MINUS', go to state 76
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_UNTIL comparison TK_LT TK_MINUS]
Parser(B) >> Input 'TK_INTEGER' in state 76
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_UNTIL comparison TK_LT TK_MINUS TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 76.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 76.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 76.
Parser(B) >> ... then shift 'prefix_expression', go to state 224
Parser(B) >> Reduce 185 [prefix_expression ::= TK_MINUS prefix_expression], pop back to state 45.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 45.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 45.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 45.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 45.
Parser(B) >> ... then shift 'concatenation', go to state 57
Parser(B) >> Reduce 215 [comparison ::= comparison TK_LT concatenation], pop back to state 28.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 28.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 28.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 28.
Parser(B) >> ... then shift 'expression', go to state 396
Parser(B) >> Reduce 106 [docond ::= TK_UNTIL expression], pop back to state 96.
Parser(B) >> ... then shift 'docond', go to state 398
Parser(B) >> Shift 'TK_EOC', go to state 6
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep docond TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 6
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep docond TK_EOC TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 6.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep docond TK_EOC var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 33
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep docond TK_EOC var_symbol TK_EQUAL TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_PLUS' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 33.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Shift 'TK_PLUS', go to state 64
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep docond TK_EOC var_symbol TK_EQUAL addition TK_PLUS]
Parser(B) >> Input 'TK_INTEGER' in state 64
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep docond TK_EOC var_symbol TK_EQUAL addition TK_PLUS TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 64.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 64.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 64.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 64.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 64.
Parser(B) >> ... then shift 'multiplication', go to state 240
Parser(B) >> Reduce 194 [addition ::= addition TK_PLUS multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 6.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 6.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep docond TK_EOC single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_END' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 6.
Parser(B) >> ... then shift 'labeled_instruction', go to state 184
Parser(B) >> Reduce 33 [instruction_list ::= labeled_instruction], pop back to state 6.
Parser(B) >> ... then shift 'instruction_list', go to state 14
Parser(B) >> Shift 'TK_END', go to state 125
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep docond TK_EOC instruction_list TK_END]
Parser(B) >> Input 'TK_EOC' in state 125
Parser(B) >> Reduce 84 [do ::= tk_doloop dorep docond TK_EOC instruction_list TK_END], pop back to state 8.
Parser(B) >> ... then shift 'do', go to state 101
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 405
Parser(B) >> Shift 'TK_EOC', go to state 186
Parser(B) >> Return. Stack=[rexx_options instruction_list do junk TK_EOC]
Parser(B) >> Input 'TK_IF' in state 186
Parser(B) >> Reduce 71 [group ::= do junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'group', go to state 193
Parser(B) >> Reduce 35 [labeled_instruction ::= group], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_IF', go to state 30
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 30
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_NEQ' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 30.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 30.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 30.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 30.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 30.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 30.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 30.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 30.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Shift 'TK_NEQ', go to state 47
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ]
Parser(B) >> Input 'TK_MINUS' in state 47
Parser(B) >> Shift 'TK_MINUS', go to state 76
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ TK_MINUS]
Parser(B) >> Input 'TK_INTEGER' in state 76
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ TK_MINUS TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 76.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 76.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 76.
Parser(B) >> ... then shift 'prefix_expression', go to state 224
Parser(B) >> Reduce 185 [prefix_expression ::= TK_MINUS prefix_expression], pop back to state 47.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 47.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 47.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 47.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 47.
Parser(B) >> ... then shift 'concatenation', go to state 59
Parser(B) >> Reduce 213 [comparison ::= comparison TK_NEQ concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 30.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 30.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 30.
Parser(B) >> ... then shift 'expression', go to state 127
Parser(B) >> Shift 'TK_EOC', go to state 206
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression TK_EOC]
Parser(B) >> Input 'TK_THEN' in state 206
Parser(B) >> Reduce 253 [ncl0 ::= TK_EOC] without external action, pop back to state 127.
Parser(B) >> ... then shift 'ncl0', go to state 131
Parser(B) >> Shift 'TK_THEN', go to state 109
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN]
Parser(B) >> Input 'TK_DO' in state 109
Parser(B) >> Reduce 254 [ncl0 ::=] without external action.
Parser(B) >> ... then shift 'ncl0', go to state 15
Parser(B) >> Shift 'TK_DO', go to state 113
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO]
Parser(B) >> Input 'TK_EOC' in state 113
Parser(B) >> Shift 'TK_EOC', go to state 7
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 7
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 7.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 33
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_PLUS' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 33.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Shift 'TK_PLUS', go to state 64
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL addition TK_PLUS]
Parser(B) >> Input 'TK_INTEGER' in state 64
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL addition TK_PLUS TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 64.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 64.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 64.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 64.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 64.
Parser(B) >> ... then shift 'multiplication', go to state 240
Parser(B) >> Reduce 194 [addition ::= addition TK_PLUS multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 7.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 7.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_SAY' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 7.
Parser(B) >> ... then shift 'labeled_instruction', go to state 184
Parser(B) >> Reduce 33 [instruction_list ::= labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_SAY', go to state 22
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_SAY]
Parser(B) >> Input 'TK_STRING' in state 22
Parser(B) >> Shift 'TK_STRING', go to state 111
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_SAY TK_STRING]
Parser(B) >> Input 'TK_EOC' in state 111
Parser(B) >> Reduce 179 [term ::= TK_STRING], pop back to state 22.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 22.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 22.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 22.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 22.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 22.
Parser(B) >> ... then shift 'expression', go to state 331
Parser(B) >> Reduce 160 [say ::= TK_SAY expression], pop back to state 10.
Parser(B) >> ... then shift 'say', go to state 365
Parser(B) >> Reduce 60 [keyword_instruction ::= say], pop back to state 10.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 10.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_END' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 10.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_END', go to state 129
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_END]
Parser(B) >> Input 'TK_EOC' in state 129
Parser(B) >> Reduce 73 [simple_do ::= TK_DO TK_EOC instruction_list TK_END], pop back to state 15.
Parser(B) >> ... then shift 'simple_do', go to state 102
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 406
Parser(B) >> Shift 'TK_EOC', go to state 187
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 simple_do junk TK_EOC]
Parser(B) >> Input 'TK_IF' in state 187
Parser(B) >> Reduce 70 [group ::= simple_do junk TK_EOC], pop back to state 15.
Parser(B) >> ... then shift 'group', go to state 182
Parser(B) >> Reduce 41 [instruction ::= group], pop back to state 15.
Parser(B) >> ... then shift 'instruction', go to state 175
Parser(B) >> Reduce 110 [then ::= TK_THEN ncl0 instruction], pop back to state 131.
Parser(B) >> ... then shift 'then', go to state 108
Parser(B) >> Reduce 108 [if ::= TK_IF expression ncl0 then], pop back to state 8.
Parser(B) >> ... then shift 'if', go to state 185
Parser(B) >> Reduce 72 [group ::= if], pop back to state 8.
Parser(B) >> ... then shift 'group', go to state 193
Parser(B) >> Reduce 35 [labeled_instruction ::= group], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_IF', go to state 30
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 30
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_NEQ' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 30.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 30.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 30.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 30.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 30.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 30.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 30.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 30.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Shift 'TK_NEQ', go to state 47
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ]
Parser(B) >> Input 'TK_INTEGER' in state 47
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 47.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 47.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 47.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 47.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 47.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 47.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 47.
Parser(B) >> ... then shift 'concatenation', go to state 59
Parser(B) >> Reduce 213 [comparison ::= comparison TK_NEQ concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 30.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 30.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 30.
Parser(B) >> ... then shift 'expression', go to state 127
Parser(B) >> Shift 'TK_EOC', go to state 206
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression TK_EOC]
Parser(B) >> Input 'TK_THEN' in state 206
Parser(B) >> Reduce 253 [ncl0 ::= TK_EOC] without external action, pop back to state 127.
Parser(B) >> ... then shift 'ncl0', go to state 131
Parser(B) >> Shift 'TK_THEN', go to state 109
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN]
Parser(B) >> Input 'TK_DO' in state 109
Parser(B) >> Reduce 254 [ncl0 ::=] without external action.
Parser(B) >> ... then shift 'ncl0', go to state 15
Parser(B) >> Shift 'TK_DO', go to state 113
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO]
Parser(B) >> Input 'TK_EOC' in state 113
Parser(B) >> Shift 'TK_EOC', go to state 7
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 7
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 7.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 33
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_PLUS' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 33.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Shift 'TK_PLUS', go to state 64
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL addition TK_PLUS]
Parser(B) >> Input 'TK_INTEGER' in state 64
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL addition TK_PLUS TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 64.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 64.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 64.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 64.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 64.
Parser(B) >> ... then shift 'multiplication', go to state 240
Parser(B) >> Reduce 194 [addition ::= addition TK_PLUS multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 7.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 7.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_SAY' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 7.
Parser(B) >> ... then shift 'labeled_instruction', go to state 184
Parser(B) >> Reduce 33 [instruction_list ::= labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_SAY', go to state 22
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_SAY]
Parser(B) >> Input 'TK_STRING' in state 22
Parser(B) >> Shift 'TK_STRING', go to state 111
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_SAY TK_STRING]
Parser(B) >> Input 'TK_EOC' in state 111
Parser(B) >> Reduce 179 [term ::= TK_STRING], pop back to state 22.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 22.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 22.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 22.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 22.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 22.
Parser(B) >> ... then shift 'expression', go to state 331
Parser(B) >> Reduce 160 [say ::= TK_SAY expression], pop back to state 10.
Parser(B) >> ... then shift 'say', go to state 365
Parser(B) >> Reduce 60 [keyword_instruction ::= say], pop back to state 10.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 10.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_END' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 10.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_END', go to state 129
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_END]
Parser(B) >> Input 'TK_EOC' in state 129
Parser(B) >> Reduce 73 [simple_do ::= TK_DO TK_EOC instruction_list TK_END], pop back to state 15.
Parser(B) >> ... then shift 'simple_do', go to state 102
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 406
Parser(B) >> Shift 'TK_EOC', go to state 187
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 simple_do junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 187
Parser(B) >> Reduce 70 [group ::= simple_do junk TK_EOC], pop back to state 15.
Parser(B) >> ... then shift 'group', go to state 182
Parser(B) >> Reduce 41 [instruction ::= group], pop back to state 15.
Parser(B) >> ... then shift 'instruction', go to state 175
Parser(B) >> Reduce 110 [then ::= TK_THEN ncl0 instruction], pop back to state 131.
Parser(B) >> ... then shift 'then', go to state 108
Parser(B) >> Reduce 108 [if ::= TK_IF expression ncl0 then], pop back to state 8.
Parser(B) >> ... then shift 'if', go to state 185
Parser(B) >> Reduce 72 [group ::= if], pop back to state 8.
Parser(B) >> ... then shift 'group', go to state 193
Parser(B) >> Reduce 35 [labeled_instruction ::= group], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 8.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_INTEGER' in state 33
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 8.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 8.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_INTEGER' in state 33
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 8.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_LOOP' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_LOOP', go to state 242
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_LOOP]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 242
Parser(B) >> Reduce 81 [tk_doloop ::= TK_LOOP], pop back to state 8.
Parser(B) >> ... then shift 'tk_doloop', go to state 17
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 17.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_INTEGER' in state 33
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop var_symbol TK_EQUAL TK_INTEGER]
Parser(B) >> Input 'TK_TO' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 17.
Parser(B) >> ... then shift 'assignment', go to state 86
Parser(B) >> Shift 'TK_TO', go to state 27
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop assignment TK_TO]
Parser(B) >> Input 'TK_INTEGER' in state 27
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop assignment TK_TO TK_INTEGER]
Parser(B) >> Input 'TK_UNTIL' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 27.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 27.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 27.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 27.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 27.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 27.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 27.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 27.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 27.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 27.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 27.
Parser(B) >> ... then shift 'expression', go to state 286
Parser(B) >> Reduce 101 [dorep_item ::= TK_TO expression], pop back to state 86.
Parser(B) >> ... then shift 'dorep_item', go to state 283
Parser(B) >> Reduce 99 [dorep_list ::= dorep_item], pop back to state 86.
Parser(B) >> ... then shift 'dorep_list', go to state 114
Parser(B) >> Reduce 98 [dorep ::= assignment dorep_list], pop back to state 17.
Parser(B) >> ... then shift 'dorep', go to state 96
Parser(B) >> Shift 'TK_UNTIL', go to state 28
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_UNTIL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 28
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_UNTIL TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_GT' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 28.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 28.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 28.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 28.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 28.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 28.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 28.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 28.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 28.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Shift 'TK_GT', go to state 46
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_UNTIL comparison TK_GT]
Parser(B) >> Input 'TK_INTEGER' in state 46
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_UNTIL comparison TK_GT TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 46.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 46.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 46.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 46.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 46.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 46.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 46.
Parser(B) >> ... then shift 'concatenation', go to state 58
Parser(B) >> Reduce 214 [comparison ::= comparison TK_GT concatenation], pop back to state 28.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 28.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 28.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 28.
Parser(B) >> ... then shift 'expression', go to state 396
Parser(B) >> Reduce 106 [docond ::= TK_UNTIL expression], pop back to state 96.
Parser(B) >> ... then shift 'docond', go to state 398
Parser(B) >> Shift 'TK_EOC', go to state 6
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep docond TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 6
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep docond TK_EOC TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 6.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep docond TK_EOC var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 33
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep docond TK_EOC var_symbol TK_EQUAL TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_PLUS' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 33.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Shift 'TK_PLUS', go to state 64
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep docond TK_EOC var_symbol TK_EQUAL addition TK_PLUS]
Parser(B) >> Input 'TK_INTEGER' in state 64
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep docond TK_EOC var_symbol TK_EQUAL addition TK_PLUS TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 64.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 64.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 64.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 64.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 64.
Parser(B) >> ... then shift 'multiplication', go to state 240
Parser(B) >> Reduce 194 [addition ::= addition TK_PLUS multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 6.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 6.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep docond TK_EOC single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_END' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 6.
Parser(B) >> ... then shift 'labeled_instruction', go to state 184
Parser(B) >> Reduce 33 [instruction_list ::= labeled_instruction], pop back to state 6.
Parser(B) >> ... then shift 'instruction_list', go to state 14
Parser(B) >> Shift 'TK_END', go to state 125
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep docond TK_EOC instruction_list TK_END]
Parser(B) >> Input 'TK_EOC' in state 125
Parser(B) >> Reduce 84 [do ::= tk_doloop dorep docond TK_EOC instruction_list TK_END], pop back to state 8.
Parser(B) >> ... then shift 'do', go to state 101
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 405
Parser(B) >> Shift 'TK_EOC', go to state 186
Parser(B) >> Return. Stack=[rexx_options instruction_list do junk TK_EOC]
Parser(B) >> Input 'TK_IF' in state 186
Parser(B) >> Reduce 71 [group ::= do junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'group', go to state 193
Parser(B) >> Reduce 35 [labeled_instruction ::= group], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_IF', go to state 30
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 30
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_NEQ' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 30.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 30.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 30.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 30.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 30.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 30.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 30.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 30.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Shift 'TK_NEQ', go to state 47
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ]
Parser(B) >> Input 'TK_INTEGER' in state 47
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 47.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 47.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 47.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 47.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 47.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 47.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 47.
Parser(B) >> ... then shift 'concatenation', go to state 59
Parser(B) >> Reduce 213 [comparison ::= comparison TK_NEQ concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 30.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 30.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 30.
Parser(B) >> ... then shift 'expression', go to state 127
Parser(B) >> Shift 'TK_EOC', go to state 206
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression TK_EOC]
Parser(B) >> Input 'TK_THEN' in state 206
Parser(B) >> Reduce 253 [ncl0 ::= TK_EOC] without external action, pop back to state 127.
Parser(B) >> ... then shift 'ncl0', go to state 131
Parser(B) >> Shift 'TK_THEN', go to state 109
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN]
Parser(B) >> Input 'TK_DO' in state 109
Parser(B) >> Reduce 254 [ncl0 ::=] without external action.
Parser(B) >> ... then shift 'ncl0', go to state 15
Parser(B) >> Shift 'TK_DO', go to state 113
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO]
Parser(B) >> Input 'TK_EOC' in state 113
Parser(B) >> Shift 'TK_EOC', go to state 7
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 7
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 7.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 33
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_PLUS' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 33.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Shift 'TK_PLUS', go to state 64
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL addition TK_PLUS]
Parser(B) >> Input 'TK_INTEGER' in state 64
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL addition TK_PLUS TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 64.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 64.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 64.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 64.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 64.
Parser(B) >> ... then shift 'multiplication', go to state 240
Parser(B) >> Reduce 194 [addition ::= addition TK_PLUS multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 7.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 7.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_SAY' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 7.
Parser(B) >> ... then shift 'labeled_instruction', go to state 184
Parser(B) >> Reduce 33 [instruction_list ::= labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_SAY', go to state 22
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_SAY]
Parser(B) >> Input 'TK_STRING' in state 22
Parser(B) >> Shift 'TK_STRING', go to state 111
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_SAY TK_STRING]
Parser(B) >> Input 'TK_EOC' in state 111
Parser(B) >> Reduce 179 [term ::= TK_STRING], pop back to state 22.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 22.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 22.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 22.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 22.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 22.
Parser(B) >> ... then shift 'expression', go to state 331
Parser(B) >> Reduce 160 [say ::= TK_SAY expression], pop back to state 10.
Parser(B) >> ... then shift 'say', go to state 365
Parser(B) >> Reduce 60 [keyword_instruction ::= say], pop back to state 10.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 10.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_END' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 10.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_END', go to state 129
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_END]
Parser(B) >> Input 'TK_EOC' in state 129
Parser(B) >> Reduce 73 [simple_do ::= TK_DO TK_EOC instruction_list TK_END], pop back to state 15.
Parser(B) >> ... then shift 'simple_do', go to state 102
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 406
Parser(B) >> Shift 'TK_EOC', go to state 187
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 simple_do junk TK_EOC]
Parser(B) >> Input 'TK_IF' in state 187
Parser(B) >> Reduce 70 [group ::= simple_do junk TK_EOC], pop back to state 15.
Parser(B) >> ... then shift 'group', go to state 182
Parser(B) >> Reduce 41 [instruction ::= group], pop back to state 15.
Parser(B) >> ... then shift 'instruction', go to state 175
Parser(B) >> Reduce 110 [then ::= TK_THEN ncl0 instruction], pop back to state 131.
Parser(B) >> ... then shift 'then', go to state 108
Parser(B) >> Reduce 108 [if ::= TK_IF expression ncl0 then], pop back to state 8.
Parser(B) >> ... then shift 'if', go to state 185
Parser(B) >> Reduce 72 [group ::= if], pop back to state 8.
Parser(B) >> ... then shift 'group', go to state 193
Parser(B) >> Reduce 35 [labeled_instruction ::= group], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_IF', go to state 30
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 30
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_NEQ' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 30.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 30.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 30.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 30.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 30.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 30.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 30.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 30.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Shift 'TK_NEQ', go to state 47
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ]
Parser(B) >> Input 'TK_INTEGER' in state 47
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 47.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 47.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 47.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 47.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 47.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 47.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 47.
Parser(B) >> ... then shift 'concatenation', go to state 59
Parser(B) >> Reduce 213 [comparison ::= comparison TK_NEQ concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 30.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 30.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 30.
Parser(B) >> ... then shift 'expression', go to state 127
Parser(B) >> Shift 'TK_EOC', go to state 206
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression TK_EOC]
Parser(B) >> Input 'TK_THEN' in state 206
Parser(B) >> Reduce 253 [ncl0 ::= TK_EOC] without external action, pop back to state 127.
Parser(B) >> ... then shift 'ncl0', go to state 131
Parser(B) >> Shift 'TK_THEN', go to state 109
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN]
Parser(B) >> Input 'TK_DO' in state 109
Parser(B) >> Reduce 254 [ncl0 ::=] without external action.
Parser(B) >> ... then shift 'ncl0', go to state 15
Parser(B) >> Shift 'TK_DO', go to state 113
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO]
Parser(B) >> Input 'TK_EOC' in state 113
Parser(B) >> Shift 'TK_EOC', go to state 7
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 7
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 7.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 33
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_PLUS' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 33.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Shift 'TK_PLUS', go to state 64
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL addition TK_PLUS]
Parser(B) >> Input 'TK_INTEGER' in state 64
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL addition TK_PLUS TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 64.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 64.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 64.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 64.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 64.
Parser(B) >> ... then shift 'multiplication', go to state 240
Parser(B) >> Reduce 194 [addition ::= addition TK_PLUS multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 7.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 7.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_SAY' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 7.
Parser(B) >> ... then shift 'labeled_instruction', go to state 184
Parser(B) >> Reduce 33 [instruction_list ::= labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_SAY', go to state 22
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_SAY]
Parser(B) >> Input 'TK_STRING' in state 22
Parser(B) >> Shift 'TK_STRING', go to state 111
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_SAY TK_STRING]
Parser(B) >> Input 'TK_EOC' in state 111
Parser(B) >> Reduce 179 [term ::= TK_STRING], pop back to state 22.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 22.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 22.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 22.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 22.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 22.
Parser(B) >> ... then shift 'expression', go to state 331
Parser(B) >> Reduce 160 [say ::= TK_SAY expression], pop back to state 10.
Parser(B) >> ... then shift 'say', go to state 365
Parser(B) >> Reduce 60 [keyword_instruction ::= say], pop back to state 10.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 10.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_END' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 10.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_END', go to state 129
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_END]
Parser(B) >> Input 'TK_EOC' in state 129
Parser(B) >> Reduce 73 [simple_do ::= TK_DO TK_EOC instruction_list TK_END], pop back to state 15.
Parser(B) >> ... then shift 'simple_do', go to state 102
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 406
Parser(B) >> Shift 'TK_EOC', go to state 187
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 simple_do junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 187
Parser(B) >> Reduce 70 [group ::= simple_do junk TK_EOC], pop back to state 15.
Parser(B) >> ... then shift 'group', go to state 182
Parser(B) >> Reduce 41 [instruction ::= group], pop back to state 15.
Parser(B) >> ... then shift 'instruction', go to state 175
Parser(B) >> Reduce 110 [then ::= TK_THEN ncl0 instruction], pop back to state 131.
Parser(B) >> ... then shift 'then', go to state 108
Parser(B) >> Reduce 108 [if ::= TK_IF expression ncl0 then], pop back to state 8.
Parser(B) >> ... then shift 'if', go to state 185
Parser(B) >> Reduce 72 [group ::= if], pop back to state 8.
Parser(B) >> ... then shift 'group', go to state 193
Parser(B) >> Reduce 35 [labeled_instruction ::= group], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 8.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_INTEGER' in state 33
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 8.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_LOOP' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_LOOP', go to state 242
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_LOOP]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 242
Parser(B) >> Reduce 81 [tk_doloop ::= TK_LOOP], pop back to state 8.
Parser(B) >> ... then shift 'tk_doloop', go to state 17
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_PLUS' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 17.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 17.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 17.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 17.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 17.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 17.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 17.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Shift 'TK_PLUS', go to state 64
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop addition TK_PLUS]
Parser(B) >> Input 'TK_INTEGER' in state 64
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop addition TK_PLUS TK_INTEGER]
Parser(B) >> Input 'TK_UNTIL' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 64.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 64.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 64.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 64.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 64.
Parser(B) >> ... then shift 'multiplication', go to state 240
Parser(B) >> Reduce 194 [addition ::= addition TK_PLUS multiplication], pop back to state 17.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 17.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 17.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 17.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 17.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 17.
Parser(B) >> ... then shift 'expression', go to state 303
Parser(B) >> Reduce 96 [dorep ::= expression], pop back to state 17.
Parser(B) >> ... then shift 'dorep', go to state 96
Parser(B) >> Shift 'TK_UNTIL', go to state 28
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_UNTIL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 28
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_UNTIL TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 28.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 28.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 28.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 28.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 28.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 28.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 28.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 28.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 28.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Shift 'TK_EQUAL', go to state 48
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_UNTIL comparison TK_EQUAL]
Parser(B) >> Input 'TK_INTEGER' in state 48
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_UNTIL comparison TK_EQUAL TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 48.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 48.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 48.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 48.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 48.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 48.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 48.
Parser(B) >> ... then shift 'concatenation', go to state 60
Parser(B) >> Reduce 212 [comparison ::= comparison TK_EQUAL concatenation], pop back to state 28.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 28.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 28.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 28.
Parser(B) >> ... then shift 'expression', go to state 396
Parser(B) >> Reduce 106 [docond ::= TK_UNTIL expression], pop back to state 96.
Parser(B) >> ... then shift 'docond', go to state 398
Parser(B) >> Shift 'TK_EOC', go to state 6
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep docond TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 6
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep docond TK_EOC TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 6.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep docond TK_EOC var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 33
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep docond TK_EOC var_symbol TK_EQUAL TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_PLUS' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 33.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Shift 'TK_PLUS', go to state 64
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep docond TK_EOC var_symbol TK_EQUAL addition TK_PLUS]
Parser(B) >> Input 'TK_INTEGER' in state 64
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep docond TK_EOC var_symbol TK_EQUAL addition TK_PLUS TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 64.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 64.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 64.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 64.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 64.
Parser(B) >> ... then shift 'multiplication', go to state 240
Parser(B) >> Reduce 194 [addition ::= addition TK_PLUS multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 6.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 6.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep docond TK_EOC single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_END' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 6.
Parser(B) >> ... then shift 'labeled_instruction', go to state 184
Parser(B) >> Reduce 33 [instruction_list ::= labeled_instruction], pop back to state 6.
Parser(B) >> ... then shift 'instruction_list', go to state 14
Parser(B) >> Shift 'TK_END', go to state 125
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep docond TK_EOC instruction_list TK_END]
Parser(B) >> Input 'TK_EOC' in state 125
Parser(B) >> Reduce 84 [do ::= tk_doloop dorep docond TK_EOC instruction_list TK_END], pop back to state 8.
Parser(B) >> ... then shift 'do', go to state 101
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 405
Parser(B) >> Shift 'TK_EOC', go to state 186
Parser(B) >> Return. Stack=[rexx_options instruction_list do junk TK_EOC]
Parser(B) >> Input 'TK_IF' in state 186
Parser(B) >> Reduce 71 [group ::= do junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'group', go to state 193
Parser(B) >> Reduce 35 [labeled_instruction ::= group], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_IF', go to state 30
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 30
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_NEQ' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 30.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 30.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 30.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 30.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 30.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 30.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 30.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 30.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Shift 'TK_NEQ', go to state 47
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ]
Parser(B) >> Input 'TK_INTEGER' in state 47
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 47.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 47.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 47.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 47.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 47.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 47.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 47.
Parser(B) >> ... then shift 'concatenation', go to state 59
Parser(B) >> Reduce 213 [comparison ::= comparison TK_NEQ concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 30.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 30.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 30.
Parser(B) >> ... then shift 'expression', go to state 127
Parser(B) >> Shift 'TK_EOC', go to state 206
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression TK_EOC]
Parser(B) >> Input 'TK_THEN' in state 206
Parser(B) >> Reduce 253 [ncl0 ::= TK_EOC] without external action, pop back to state 127.
Parser(B) >> ... then shift 'ncl0', go to state 131
Parser(B) >> Shift 'TK_THEN', go to state 109
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN]
Parser(B) >> Input 'TK_DO' in state 109
Parser(B) >> Reduce 254 [ncl0 ::=] without external action.
Parser(B) >> ... then shift 'ncl0', go to state 15
Parser(B) >> Shift 'TK_DO', go to state 113
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO]
Parser(B) >> Input 'TK_EOC' in state 113
Parser(B) >> Shift 'TK_EOC', go to state 7
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 7
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 7.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 33
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_PLUS' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 33.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Shift 'TK_PLUS', go to state 64
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL addition TK_PLUS]
Parser(B) >> Input 'TK_INTEGER' in state 64
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL addition TK_PLUS TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 64.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 64.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 64.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 64.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 64.
Parser(B) >> ... then shift 'multiplication', go to state 240
Parser(B) >> Reduce 194 [addition ::= addition TK_PLUS multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 7.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 7.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_SAY' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 7.
Parser(B) >> ... then shift 'labeled_instruction', go to state 184
Parser(B) >> Reduce 33 [instruction_list ::= labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_SAY', go to state 22
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_SAY]
Parser(B) >> Input 'TK_STRING' in state 22
Parser(B) >> Shift 'TK_STRING', go to state 111
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_SAY TK_STRING]
Parser(B) >> Input 'TK_EOC' in state 111
Parser(B) >> Reduce 179 [term ::= TK_STRING], pop back to state 22.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 22.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 22.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 22.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 22.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 22.
Parser(B) >> ... then shift 'expression', go to state 331
Parser(B) >> Reduce 160 [say ::= TK_SAY expression], pop back to state 10.
Parser(B) >> ... then shift 'say', go to state 365
Parser(B) >> Reduce 60 [keyword_instruction ::= say], pop back to state 10.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 10.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_END' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 10.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_END', go to state 129
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_END]
Parser(B) >> Input 'TK_EOC' in state 129
Parser(B) >> Reduce 73 [simple_do ::= TK_DO TK_EOC instruction_list TK_END], pop back to state 15.
Parser(B) >> ... then shift 'simple_do', go to state 102
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 406
Parser(B) >> Shift 'TK_EOC', go to state 187
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 simple_do junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 187
Parser(B) >> Reduce 70 [group ::= simple_do junk TK_EOC], pop back to state 15.
Parser(B) >> ... then shift 'group', go to state 182
Parser(B) >> Reduce 41 [instruction ::= group], pop back to state 15.
Parser(B) >> ... then shift 'instruction', go to state 175
Parser(B) >> Reduce 110 [then ::= TK_THEN ncl0 instruction], pop back to state 131.
Parser(B) >> ... then shift 'then', go to state 108
Parser(B) >> Reduce 108 [if ::= TK_IF expression ncl0 then], pop back to state 8.
Parser(B) >> ... then shift 'if', go to state 185
Parser(B) >> Reduce 72 [group ::= if], pop back to state 8.
Parser(B) >> ... then shift 'group', go to state 193
Parser(B) >> Reduce 35 [labeled_instruction ::= group], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 8.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_INTEGER' in state 33
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 8.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_LOOP' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_LOOP', go to state 242
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_LOOP]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 242
Parser(B) >> Reduce 81 [tk_doloop ::= TK_LOOP], pop back to state 8.
Parser(B) >> ... then shift 'tk_doloop', go to state 17
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 17.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_INTEGER' in state 33
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop var_symbol TK_EQUAL TK_INTEGER]
Parser(B) >> Input 'TK_TO' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 17.
Parser(B) >> ... then shift 'assignment', go to state 86
Parser(B) >> Shift 'TK_TO', go to state 27
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop assignment TK_TO]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 27
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop assignment TK_TO TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_PLUS' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 27.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 27.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 27.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 27.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 27.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 27.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 27.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Shift 'TK_PLUS', go to state 64
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop assignment TK_TO addition TK_PLUS]
Parser(B) >> Input 'TK_INTEGER' in state 64
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop assignment TK_TO addition TK_PLUS TK_INTEGER]
Parser(B) >> Input 'TK_UNTIL' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 64.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 64.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 64.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 64.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 64.
Parser(B) >> ... then shift 'multiplication', go to state 240
Parser(B) >> Reduce 194 [addition ::= addition TK_PLUS multiplication], pop back to state 27.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 27.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 27.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 27.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 27.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 27.
Parser(B) >> ... then shift 'expression', go to state 286
Parser(B) >> Reduce 101 [dorep_item ::= TK_TO expression], pop back to state 86.
Parser(B) >> ... then shift 'dorep_item', go to state 283
Parser(B) >> Reduce 99 [dorep_list ::= dorep_item], pop back to state 86.
Parser(B) >> ... then shift 'dorep_list', go to state 114
Parser(B) >> Reduce 98 [dorep ::= assignment dorep_list], pop back to state 17.
Parser(B) >> ... then shift 'dorep', go to state 96
Parser(B) >> Shift 'TK_UNTIL', go to state 28
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_UNTIL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 28
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_UNTIL TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 28.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 28.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 28.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 28.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 28.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 28.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 28.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 28.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 28.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Shift 'TK_EQUAL', go to state 48
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_UNTIL comparison TK_EQUAL]
Parser(B) >> Input 'TK_INTEGER' in state 48
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_UNTIL comparison TK_EQUAL TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 48.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 48.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 48.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 48.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 48.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 48.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 48.
Parser(B) >> ... then shift 'concatenation', go to state 60
Parser(B) >> Reduce 212 [comparison ::= comparison TK_EQUAL concatenation], pop back to state 28.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 28.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 28.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 28.
Parser(B) >> ... then shift 'expression', go to state 396
Parser(B) >> Reduce 106 [docond ::= TK_UNTIL expression], pop back to state 96.
Parser(B) >> ... then shift 'docond', go to state 398
Parser(B) >> Shift 'TK_EOC', go to state 6
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep docond TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 6
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep docond TK_EOC TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 6.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep docond TK_EOC var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 33
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep docond TK_EOC var_symbol TK_EQUAL TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_PLUS' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 33.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Shift 'TK_PLUS', go to state 64
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep docond TK_EOC var_symbol TK_EQUAL addition TK_PLUS]
Parser(B) >> Input 'TK_INTEGER' in state 64
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep docond TK_EOC var_symbol TK_EQUAL addition TK_PLUS TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 64.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 64.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 64.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 64.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 64.
Parser(B) >> ... then shift 'multiplication', go to state 240
Parser(B) >> Reduce 194 [addition ::= addition TK_PLUS multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 6.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 6.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep docond TK_EOC single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_END' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 6.
Parser(B) >> ... then shift 'labeled_instruction', go to state 184
Parser(B) >> Reduce 33 [instruction_list ::= labeled_instruction], pop back to state 6.
Parser(B) >> ... then shift 'instruction_list', go to state 14
Parser(B) >> Shift 'TK_END', go to state 125
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep docond TK_EOC instruction_list TK_END]
Parser(B) >> Input 'TK_EOC' in state 125
Parser(B) >> Reduce 84 [do ::= tk_doloop dorep docond TK_EOC instruction_list TK_END], pop back to state 8.
Parser(B) >> ... then shift 'do', go to state 101
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 405
Parser(B) >> Shift 'TK_EOC', go to state 186
Parser(B) >> Return. Stack=[rexx_options instruction_list do junk TK_EOC]
Parser(B) >> Input 'TK_IF' in state 186
Parser(B) >> Reduce 71 [group ::= do junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'group', go to state 193
Parser(B) >> Reduce 35 [labeled_instruction ::= group], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_IF', go to state 30
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 30
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_NEQ' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 30.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 30.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 30.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 30.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 30.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 30.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 30.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 30.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Shift 'TK_NEQ', go to state 47
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ]
Parser(B) >> Input 'TK_INTEGER' in state 47
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 47.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 47.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 47.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 47.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 47.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 47.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 47.
Parser(B) >> ... then shift 'concatenation', go to state 59
Parser(B) >> Reduce 213 [comparison ::= comparison TK_NEQ concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 30.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 30.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 30.
Parser(B) >> ... then shift 'expression', go to state 127
Parser(B) >> Shift 'TK_EOC', go to state 206
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression TK_EOC]
Parser(B) >> Input 'TK_THEN' in state 206
Parser(B) >> Reduce 253 [ncl0 ::= TK_EOC] without external action, pop back to state 127.
Parser(B) >> ... then shift 'ncl0', go to state 131
Parser(B) >> Shift 'TK_THEN', go to state 109
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN]
Parser(B) >> Input 'TK_DO' in state 109
Parser(B) >> Reduce 254 [ncl0 ::=] without external action.
Parser(B) >> ... then shift 'ncl0', go to state 15
Parser(B) >> Shift 'TK_DO', go to state 113
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO]
Parser(B) >> Input 'TK_EOC' in state 113
Parser(B) >> Shift 'TK_EOC', go to state 7
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 7
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 7.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 33
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_PLUS' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 33.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Shift 'TK_PLUS', go to state 64
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL addition TK_PLUS]
Parser(B) >> Input 'TK_INTEGER' in state 64
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL addition TK_PLUS TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 64.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 64.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 64.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 64.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 64.
Parser(B) >> ... then shift 'multiplication', go to state 240
Parser(B) >> Reduce 194 [addition ::= addition TK_PLUS multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 7.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 7.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_SAY' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 7.
Parser(B) >> ... then shift 'labeled_instruction', go to state 184
Parser(B) >> Reduce 33 [instruction_list ::= labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_SAY', go to state 22
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_SAY]
Parser(B) >> Input 'TK_STRING' in state 22
Parser(B) >> Shift 'TK_STRING', go to state 111
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_SAY TK_STRING]
Parser(B) >> Input 'TK_EOC' in state 111
Parser(B) >> Reduce 179 [term ::= TK_STRING], pop back to state 22.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 22.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 22.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 22.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 22.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 22.
Parser(B) >> ... then shift 'expression', go to state 331
Parser(B) >> Reduce 160 [say ::= TK_SAY expression], pop back to state 10.
Parser(B) >> ... then shift 'say', go to state 365
Parser(B) >> Reduce 60 [keyword_instruction ::= say], pop back to state 10.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 10.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_END' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 10.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_END', go to state 129
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_END]
Parser(B) >> Input 'TK_EOC' in state 129
Parser(B) >> Reduce 73 [simple_do ::= TK_DO TK_EOC instruction_list TK_END], pop back to state 15.
Parser(B) >> ... then shift 'simple_do', go to state 102
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 406
Parser(B) >> Shift 'TK_EOC', go to state 187
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 simple_do junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 187
Parser(B) >> Reduce 70 [group ::= simple_do junk TK_EOC], pop back to state 15.
Parser(B) >> ... then shift 'group', go to state 182
Parser(B) >> Reduce 41 [instruction ::= group], pop back to state 15.
Parser(B) >> ... then shift 'instruction', go to state 175
Parser(B) >> Reduce 110 [then ::= TK_THEN ncl0 instruction], pop back to state 131.
Parser(B) >> ... then shift 'then', go to state 108
Parser(B) >> Reduce 108 [if ::= TK_IF expression ncl0 then], pop back to state 8.
Parser(B) >> ... then shift 'if', go to state 185
Parser(B) >> Reduce 72 [group ::= if], pop back to state 8.
Parser(B) >> ... then shift 'group', go to state 193
Parser(B) >> Reduce 35 [labeled_instruction ::= group], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 8.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_INTEGER' in state 33
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 8.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_LOOP' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_LOOP', go to state 242
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_LOOP]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 242
Parser(B) >> Reduce 81 [tk_doloop ::= TK_LOOP], pop back to state 8.
Parser(B) >> ... then shift 'tk_doloop', go to state 17
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 17.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_INTEGER' in state 33
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop var_symbol TK_EQUAL TK_INTEGER]
Parser(B) >> Input 'TK_TO' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 17.
Parser(B) >> ... then shift 'assignment', go to state 86
Parser(B) >> Shift 'TK_TO', go to state 27
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop assignment TK_TO]
Parser(B) >> Input 'TK_INTEGER' in state 27
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop assignment TK_TO TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 27.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 27.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 27.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 27.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 27.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 27.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 27.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 27.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 27.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 27.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 27.
Parser(B) >> ... then shift 'expression', go to state 286
Parser(B) >> Reduce 101 [dorep_item ::= TK_TO expression], pop back to state 86.
Parser(B) >> ... then shift 'dorep_item', go to state 283
Parser(B) >> Reduce 99 [dorep_list ::= dorep_item], pop back to state 86.
Parser(B) >> ... then shift 'dorep_list', go to state 114
Parser(B) >> Reduce 98 [dorep ::= assignment dorep_list], pop back to state 17.
Parser(B) >> ... then shift 'dorep', go to state 96
Parser(B) >> Shift 'TK_EOC', go to state 3
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_EOC]
Parser(B) >> Input 'TK_END' in state 3
Parser(B) >> Shift 'TK_END', go to state 126
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_EOC TK_END]
Parser(B) >> Input 'TK_EOC' in state 126
Parser(B) >> Reduce 83 [do ::= tk_doloop dorep TK_EOC TK_END], pop back to state 8.
Parser(B) >> ... then shift 'do', go to state 101
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 405
Parser(B) >> Shift 'TK_EOC', go to state 186
Parser(B) >> Return. Stack=[rexx_options instruction_list do junk TK_EOC]
Parser(B) >> Input 'TK_IF' in state 186
Parser(B) >> Reduce 71 [group ::= do junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'group', go to state 193
Parser(B) >> Reduce 35 [labeled_instruction ::= group], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_IF', go to state 30
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 30
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_NEQ' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 30.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 30.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 30.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 30.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 30.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 30.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 30.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 30.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Shift 'TK_NEQ', go to state 47
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ]
Parser(B) >> Input 'TK_INTEGER' in state 47
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 47.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 47.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 47.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 47.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 47.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 47.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 47.
Parser(B) >> ... then shift 'concatenation', go to state 59
Parser(B) >> Reduce 213 [comparison ::= comparison TK_NEQ concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 30.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 30.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 30.
Parser(B) >> ... then shift 'expression', go to state 127
Parser(B) >> Shift 'TK_EOC', go to state 206
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression TK_EOC]
Parser(B) >> Input 'TK_THEN' in state 206
Parser(B) >> Reduce 253 [ncl0 ::= TK_EOC] without external action, pop back to state 127.
Parser(B) >> ... then shift 'ncl0', go to state 131
Parser(B) >> Shift 'TK_THEN', go to state 109
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN]
Parser(B) >> Input 'TK_DO' in state 109
Parser(B) >> Reduce 254 [ncl0 ::=] without external action.
Parser(B) >> ... then shift 'ncl0', go to state 15
Parser(B) >> Shift 'TK_DO', go to state 113
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO]
Parser(B) >> Input 'TK_EOC' in state 113
Parser(B) >> Shift 'TK_EOC', go to state 7
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 7
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 7.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 33
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_PLUS' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 33.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Shift 'TK_PLUS', go to state 64
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL addition TK_PLUS]
Parser(B) >> Input 'TK_INTEGER' in state 64
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL addition TK_PLUS TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 64.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 64.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 64.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 64.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 64.
Parser(B) >> ... then shift 'multiplication', go to state 240
Parser(B) >> Reduce 194 [addition ::= addition TK_PLUS multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 7.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 7.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_SAY' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 7.
Parser(B) >> ... then shift 'labeled_instruction', go to state 184
Parser(B) >> Reduce 33 [instruction_list ::= labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_SAY', go to state 22
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_SAY]
Parser(B) >> Input 'TK_STRING' in state 22
Parser(B) >> Shift 'TK_STRING', go to state 111
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_SAY TK_STRING]
Parser(B) >> Input 'TK_EOC' in state 111
Parser(B) >> Reduce 179 [term ::= TK_STRING], pop back to state 22.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 22.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 22.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 22.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 22.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 22.
Parser(B) >> ... then shift 'expression', go to state 331
Parser(B) >> Reduce 160 [say ::= TK_SAY expression], pop back to state 10.
Parser(B) >> ... then shift 'say', go to state 365
Parser(B) >> Reduce 60 [keyword_instruction ::= say], pop back to state 10.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 10.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_END' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 10.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_END', go to state 129
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_END]
Parser(B) >> Input 'TK_EOC' in state 129
Parser(B) >> Reduce 73 [simple_do ::= TK_DO TK_EOC instruction_list TK_END], pop back to state 15.
Parser(B) >> ... then shift 'simple_do', go to state 102
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 406
Parser(B) >> Shift 'TK_EOC', go to state 187
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 simple_do junk TK_EOC]
Parser(B) >> Input 'TK_RETURN' in state 187
Parser(B) >> Reduce 70 [group ::= simple_do junk TK_EOC], pop back to state 15.
Parser(B) >> ... then shift 'group', go to state 182
Parser(B) >> Reduce 41 [instruction ::= group], pop back to state 15.
Parser(B) >> ... then shift 'instruction', go to state 175
Parser(B) >> Reduce 110 [then ::= TK_THEN ncl0 instruction], pop back to state 131.
Parser(B) >> ... then shift 'then', go to state 108
Parser(B) >> Reduce 108 [if ::= TK_IF expression ncl0 then], pop back to state 8.
Parser(B) >> ... then shift 'if', go to state 185
Parser(B) >> Reduce 72 [group ::= if], pop back to state 8.
Parser(B) >> ... then shift 'group', go to state 193
Parser(B) >> Reduce 35 [labeled_instruction ::= group], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_RETURN', go to state 23
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_RETURN]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 23
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_RETURN TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_NEQ' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 23.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 23.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 23.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 23.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 23.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 23.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 23.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 23.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 23.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Shift 'TK_NEQ', go to state 47
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_RETURN comparison TK_NEQ]
Parser(B) >> Input 'TK_INTEGER' in state 47
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_RETURN comparison TK_NEQ TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 47.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 47.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 47.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 47.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 47.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 47.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 47.
Parser(B) >> ... then shift 'concatenation', go to state 59
Parser(B) >> Reduce 213 [comparison ::= comparison TK_NEQ concatenation], pop back to state 23.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 23.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 23.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 23.
Parser(B) >> ... then shift 'expression', go to state 332
Parser(B) >> Reduce 158 [return ::= TK_RETURN expression], pop back to state 8.
Parser(B) >> ... then shift 'return', go to state 366
Parser(B) >> Reduce 59 [keyword_instruction ::= return], pop back to state 8.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_EOS' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_EOS', go to state 388
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_EOS]
Parser(B) >> Input '$' in state 388
Parser(B) >> Reduce 1 [program ::= rexx_options instruction_list TK_EOS], pop back to state 0.
Parser(B) >> ... then shift 'program', pending reduce -2
Parser(B) >> Accept!
Options parser >> Input 'TK_OPTIONS' in state 0
Options parser >> Shift 'TK_OPTIONS', go to state 1
Options parser >> Return. Stack=[TK_OPTIONS]
Options parser >> Input 'TK_LEVELB' in state 1
Options parser >> Shift 'TK_LEVELB', go to state 16
Options parser >> Return. Stack=[TK_OPTIONS TK_LEVELB]
Options parser >> Input 'TK_EOC' in state 16
Options parser >> Reduce 4 [option ::= TK_LEVELB], pop back to state 1.
Options parser >> ... then shift 'option', go to state 4
Options parser >> Reduce 18 [option_list ::= option] without external action, pop back to state 1.
Options parser >> ... then shift 'option_list', go to state 2
Options parser >> Shift 'TK_EOC', go to state 23
Options parser >> Return. Stack=[TK_OPTIONS option_list TK_EOC]
Options parser >> Input 'TK_SYMBOL' in state 23
Options parser >> WILDCARD TK_SYMBOL => ANYTHING
Options parser >> Reduce 2 [rexx_options ::= TK_OPTIONS option_list TK_EOC], pop back to state 0.
Options parser >> ... then shift 'rexx_options', go to state 3
Options parser >> WILDCARD TK_SYMBOL => ANYTHING
Options parser >> Shift 'TK_SYMBOL', go to state 20
Options parser >> Return. Stack=[rexx_options TK_SYMBOL]
Options parser >> Popping TK_SYMBOL
Options parser >> Popping rexx_options
Parser(B) >> Stack grows from 0 to 100 entries.
Parser(B) >> Input 'TK_OPTIONS' in state 0
Parser(B) >> Shift 'TK_OPTIONS', go to state 81
Parser(B) >> Return. Stack=[TK_OPTIONS]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 81
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 301
Parser(B) >> Return. Stack=[TK_OPTIONS TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EOC' in state 301
Parser(B) >> Reduce 18 [option ::= TK_VAR_SYMBOL], pop back to state 81.
Parser(B) >> ... then shift 'option', go to state 300
Parser(B) >> Reduce 16 [option_list ::= option], pop back to state 81.
Parser(B) >> ... then shift 'option_list', go to state 90
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 130
Parser(B) >> Shift 'TK_EOC', go to state 195
Parser(B) >> Return. Stack=[TK_OPTIONS option_list junk TK_EOC]
Parser(B) >> Input 'TK_LABEL' in state 195
Parser(B) >> Reduce 15 [rexx_options ::= TK_OPTIONS option_list junk TK_EOC], pop back to state 0.
Parser(B) >> ... then shift 'rexx_options', go to state 1
Parser(B) >> Shift 'TK_LABEL', go to state 173
Parser(B) >> Return. Stack=[rexx_options TK_LABEL]
Parser(B) >> Input 'TK_PROCEDURE' in state 173
Parser(B) >> Shift 'TK_PROCEDURE', go to state 319
Parser(B) >> Return. Stack=[rexx_options TK_LABEL TK_PROCEDURE]
Parser(B) >> Input 'TK_EQUAL' in state 319
Parser(B) >> Shift 'TK_EQUAL', go to state 132
Parser(B) >> Return. Stack=[rexx_options TK_LABEL TK_PROCEDURE TK_EQUAL]
Parser(B) >> Input 'TK_CLASS' in state 132
Parser(B) >> Shift 'TK_CLASS', go to state 318
Parser(B) >> Return. Stack=[rexx_options TK_LABEL TK_PROCEDURE TK_EQUAL TK_CLASS]
Parser(B) >> Input 'TK_EOC' in state 318
Parser(B) >> Reduce 120 [class ::= TK_CLASS], pop back to state 132.
Parser(B) >> ... then shift 'class', go to state 379
Parser(B) >> Reduce 116 [procedure ::= TK_LABEL TK_PROCEDURE TK_EQUAL class], pop back to state 1.
Parser(B) >> ... then shift 'procedure', go to state 367
Parser(B) >> Reduce 58 [keyword_instruction ::= procedure], pop back to state 1.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 1.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_ARG' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 1.
Parser(B) >> ... then shift 'labeled_instruction', go to state 184
Parser(B) >> Reduce 33 [instruction_list ::= labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_ARG', go to state 82
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_ARG]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 82
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 297
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_ARG TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 297
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 82.
Parser(B) >> ... then shift 'var_symbol', go to state 401
Parser(B) >> Shift 'TK_EQUAL', go to state 19
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_ARG var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_CLASS' in state 19
Parser(B) >> Shift 'TK_CLASS', go to state 318
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_ARG var_symbol TK_EQUAL TK_CLASS]
Parser(B) >> Input 'TK_COMMA' in state 318
Parser(B) >> Reduce 120 [class ::= TK_CLASS], pop back to state 19.
Parser(B) >> ... then shift 'class', go to state 313
Parser(B) >> Reduce 125 [argument ::= var_symbol TK_EQUAL class], pop back to state 82.
Parser(B) >> ... then shift 'argument', go to state 311
Parser(B) >> Reduce 122 [arg_list ::= argument], pop back to state 82.
Parser(B) >> ... then shift 'arg_list', go to state 317
Parser(B) >> Shift 'TK_COMMA', go to state 105
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_ARG arg_list TK_COMMA]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 105
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 297
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_ARG arg_list TK_COMMA TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 297
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 105.
Parser(B) >> ... then shift 'var_symbol', go to state 401
Parser(B) >> Shift 'TK_EQUAL', go to state 19
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_ARG arg_list TK_COMMA var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_CLASS' in state 19
Parser(B) >> Shift 'TK_CLASS', go to state 318
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_ARG arg_list TK_COMMA var_symbol TK_EQUAL TK_CLASS]
Parser(B) >> Input 'TK_EOC' in state 318
Parser(B) >> Reduce 120 [class ::= TK_CLASS], pop back to state 19.
Parser(B) >> ... then shift 'class', go to state 313
Parser(B) >> Reduce 125 [argument ::= var_symbol TK_EQUAL class], pop back to state 105.
Parser(B) >> ... then shift 'argument', go to state 316
Parser(B) >> Reduce 123 [arg_list ::= arg_list TK_COMMA argument], pop back to state 82.
Parser(B) >> ... then shift 'arg_list', go to state 317
Parser(B) >> Reduce 119 [arg ::= TK_ARG arg_list], pop back to state 8.
Parser(B) >> ... then shift 'arg', go to state 372
Parser(B) >> Reduce 53 [keyword_instruction ::= arg], pop back to state 8.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_RETURN' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_RETURN', go to state 23
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_RETURN]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 23
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_RETURN TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_PLUS' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 23.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 23.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 23.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 23.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 23.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 23.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 23.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Shift 'TK_PLUS', go to state 64
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_RETURN addition TK_PLUS]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 64
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_RETURN addition TK_PLUS TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EOC' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 64.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 64.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 64.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 64.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 64.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 64.
Parser(B) >> ... then shift 'multiplication', go to state 240
Parser(B) >> Reduce 194 [addition ::= addition TK_PLUS multiplication], pop back to state 23.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 23.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 23.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 23.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 23.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 23.
Parser(B) >> ... then shift 'expression', go to state 332
Parser(B) >> Reduce 158 [return ::= TK_RETURN expression], pop back to state 8.
Parser(B) >> ... then shift 'return', go to state 366
Parser(B) >> Reduce 59 [keyword_instruction ::= return], pop back to state 8.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_EOS' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_EOS', go to state 388
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_EOS]
Parser(B) >> Input '$' in state 388
Parser(B) >> Reduce 1 [program ::= rexx_options instruction_list TK_EOS], pop back to state 0.
Parser(B) >> ... then shift 'program', pending reduce -2
Parser(B) >> Accept!
Options parser >> Input 'TK_OPTIONS' in state 0
Options parser >> Shift 'TK_OPTIONS', go to state 1
Options parser >> Return. Stack=[TK_OPTIONS]
Options parser >> Input 'TK_LEVELB' in state 1
Options parser >> Shift 'TK_LEVELB', go to state 16
Options parser >> Return. Stack=[TK_OPTIONS TK_LEVELB]
Options parser >> Input 'TK_EOC' in state 16
Options parser >> Reduce 4 [option ::= TK_LEVELB], pop back to state 1.
Options parser >> ... then shift 'option', go to state 4
Options parser >> Reduce 18 [option_list ::= option] without external action, pop back to state 1.
Options parser >> ... then shift 'option_list', go to state 2
Options parser >> Shift 'TK_EOC', go to state 23
Options parser >> Return. Stack=[TK_OPTIONS option_list TK_EOC]
Options parser >> Input 'TK_SYMBOL' in state 23
Options parser >> WILDCARD TK_SYMBOL => ANYTHING
Options parser >> Reduce 2 [rexx_options ::= TK_OPTIONS option_list TK_EOC], pop back to state 0.
Options parser >> ... then shift 'rexx_options', go to state 3
Options parser >> WILDCARD TK_SYMBOL => ANYTHING
Options parser >> Shift 'TK_SYMBOL', go to state 20
Options parser >> Return. Stack=[rexx_options TK_SYMBOL]
Options parser >> Popping TK_SYMBOL
Options parser >> Popping rexx_options
Parser(B) >> Stack grows from 0 to 100 entries.
Parser(B) >> Input 'TK_OPTIONS' in state 0
Parser(B) >> Shift 'TK_OPTIONS', go to state 81
Parser(B) >> Return. Stack=[TK_OPTIONS]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 81
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 301
Parser(B) >> Return. Stack=[TK_OPTIONS TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EOC' in state 301
Parser(B) >> Reduce 18 [option ::= TK_VAR_SYMBOL], pop back to state 81.
Parser(B) >> ... then shift 'option', go to state 300
Parser(B) >> Reduce 16 [option_list ::= option], pop back to state 81.
Parser(B) >> ... then shift 'option_list', go to state 90
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 130
Parser(B) >> Shift 'TK_EOC', go to state 195
Parser(B) >> Return. Stack=[TK_OPTIONS option_list junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 195
Parser(B) >> Reduce 15 [rexx_options ::= TK_OPTIONS option_list junk TK_EOC], pop back to state 0.
Parser(B) >> ... then shift 'rexx_options', go to state 1
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 1.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_FLOAT' in state 33
Parser(B) >> Shift 'TK_FLOAT', go to state 231
Parser(B) >> Return. Stack=[rexx_options var_symbol TK_EQUAL TK_FLOAT]
Parser(B) >> Input 'TK_EOC' in state 231
Parser(B) >> Reduce 177 [term ::= TK_FLOAT], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 1.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 1.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 1.
Parser(B) >> ... then shift 'labeled_instruction', go to state 184
Parser(B) >> Reduce 33 [instruction_list ::= labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 8.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_INTEGER' in state 33
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL TK_INTEGER]
Parser(B) >> Input 'TK_POWER' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Shift 'TK_POWER', go to state 75
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL power_expression TK_POWER]
Parser(B) >> Input 'TK_INTEGER' in state 75
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL power_expression TK_POWER TK_INTEGER]
Parser(B) >> Input 'TK_MINUS' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 75.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 75.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 75.
Parser(B) >> ... then shift 'prefix_expression', go to state 221
Parser(B) >> Reduce 187 [power_expression ::= power_expression TK_POWER prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Shift 'TK_MINUS', go to state 63
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL addition TK_MINUS]
Parser(B) >> Input 'TK_INTEGER' in state 63
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL addition TK_MINUS TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 63.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 63.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 63.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 63.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 63.
Parser(B) >> ... then shift 'multiplication', go to state 239
Parser(B) >> Reduce 195 [addition ::= addition TK_MINUS multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 8.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 8.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_INTEGER' in state 33
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 8.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 8.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_INTEGER' in state 33
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 8.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 8.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_INTEGER' in state 33
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 8.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 8.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_STRING' in state 33
Parser(B) >> Shift 'TK_STRING', go to state 111
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL TK_STRING]
Parser(B) >> Input 'TK_EOC' in state 111
Parser(B) >> Reduce 179 [term ::= TK_STRING], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 8.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_SAY' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_SAY', go to state 22
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 22
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 22.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 22.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 22.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 22.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY concatenation TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 61.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 61.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 61.
Parser(B) >> ... then shift 'bracket', go to state 216
Parser(B) >> Reduce 196 [prefix_expression_c ::= bracket], pop back to state 61.
Parser(B) >> ... then shift 'prefix_expression_c', go to state 214
Parser(B) >> Reduce 198 [power_expression_c ::= prefix_expression_c], pop back to state 61.
Parser(B) >> ... then shift 'power_expression_c', go to state 213
Parser(B) >> Reduce 200 [multiplication_c ::= power_expression_c], pop back to state 61.
Parser(B) >> ... then shift 'multiplication_c', go to state 238
Parser(B) >> Reduce 205 [addition_c ::= multiplication_c], pop back to state 61.
Parser(B) >> ... then shift 'addition_c', go to state 244
Parser(B) >> Reduce 210 [concatenation ::= concatenation addition_c], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY concatenation TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EOC' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 61.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 61.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 61.
Parser(B) >> ... then shift 'bracket', go to state 216
Parser(B) >> Reduce 196 [prefix_expression_c ::= bracket], pop back to state 61.
Parser(B) >> ... then shift 'prefix_expression_c', go to state 214
Parser(B) >> Reduce 198 [power_expression_c ::= prefix_expression_c], pop back to state 61.
Parser(B) >> ... then shift 'power_expression_c', go to state 213
Parser(B) >> Reduce 200 [multiplication_c ::= power_expression_c], pop back to state 61.
Parser(B) >> ... then shift 'multiplication_c', go to state 238
Parser(B) >> Reduce 205 [addition_c ::= multiplication_c], pop back to state 61.
Parser(B) >> ... then shift 'addition_c', go to state 244
Parser(B) >> Reduce 210 [concatenation ::= concatenation addition_c], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 22.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 22.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 22.
Parser(B) >> ... then shift 'expression', go to state 331
Parser(B) >> Reduce 160 [say ::= TK_SAY expression], pop back to state 8.
Parser(B) >> ... then shift 'say', go to state 365
Parser(B) >> Reduce 60 [keyword_instruction ::= say], pop back to state 8.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_DO' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_DO', go to state 113
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_DO]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 113
Parser(B) >> Reduce 80 [tk_doloop ::= TK_DO], pop back to state 8.
Parser(B) >> ... then shift 'tk_doloop', go to state 17
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 17.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_INTEGER' in state 33
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop var_symbol TK_EQUAL TK_INTEGER]
Parser(B) >> Input 'TK_TO' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 17.
Parser(B) >> ... then shift 'assignment', go to state 86
Parser(B) >> Shift 'TK_TO', go to state 27
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop assignment TK_TO]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 27
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop assignment TK_TO TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EOC' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 27.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 27.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 27.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 27.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 27.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 27.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 27.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 27.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 27.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 27.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 27.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 27.
Parser(B) >> ... then shift 'expression', go to state 286
Parser(B) >> Reduce 101 [dorep_item ::= TK_TO expression], pop back to state 86.
Parser(B) >> ... then shift 'dorep_item', go to state 283
Parser(B) >> Reduce 99 [dorep_list ::= dorep_item], pop back to state 86.
Parser(B) >> ... then shift 'dorep_list', go to state 114
Parser(B) >> Reduce 98 [dorep ::= assignment dorep_list], pop back to state 17.
Parser(B) >> ... then shift 'dorep', go to state 96
Parser(B) >> Shift 'TK_EOC', go to state 3
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 3
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_EOC TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 3.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_EOC var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 33
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_EOC var_symbol TK_EQUAL TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_PLUS' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 33.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Shift 'TK_PLUS', go to state 64
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_EOC var_symbol TK_EQUAL addition TK_PLUS]
Parser(B) >> Input 'TK_INTEGER' in state 64
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_EOC var_symbol TK_EQUAL addition TK_PLUS TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 64.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 64.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 64.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 64.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 64.
Parser(B) >> ... then shift 'multiplication', go to state 240
Parser(B) >> Reduce 194 [addition ::= addition TK_PLUS multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 3.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 3.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_EOC single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 3.
Parser(B) >> ... then shift 'labeled_instruction', go to state 184
Parser(B) >> Reduce 33 [instruction_list ::= labeled_instruction], pop back to state 3.
Parser(B) >> ... then shift 'instruction_list', go to state 9
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_EOC instruction_list TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 9.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_EOC instruction_list var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 33
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_EOC instruction_list var_symbol TK_EQUAL TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_DIV' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 33.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Shift 'TK_DIV', go to state 69
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_EOC instruction_list var_symbol TK_EQUAL multiplication TK_DIV]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 69
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_EOC instruction_list var_symbol TK_EQUAL multiplication TK_DIV TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EOC' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 69.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 69.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 69.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 69.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 69.
Parser(B) >> ... then shift 'power_expression', go to state 219
Parser(B) >> Reduce 190 [multiplication ::= multiplication TK_DIV power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 9.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 9.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_EOC instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_SAY' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 9.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 3.
Parser(B) >> ... then shift 'instruction_list', go to state 9
Parser(B) >> Shift 'TK_SAY', go to state 22
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_EOC instruction_list TK_SAY]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 22
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_EOC instruction_list TK_SAY TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 22.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 22.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 22.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 22.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_EOC instruction_list TK_SAY concatenation TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 61.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 61.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 61.
Parser(B) >> ... then shift 'bracket', go to state 216
Parser(B) >> Reduce 196 [prefix_expression_c ::= bracket], pop back to state 61.
Parser(B) >> ... then shift 'prefix_expression_c', go to state 214
Parser(B) >> Reduce 198 [power_expression_c ::= prefix_expression_c], pop back to state 61.
Parser(B) >> ... then shift 'power_expression_c', go to state 213
Parser(B) >> Reduce 200 [multiplication_c ::= power_expression_c], pop back to state 61.
Parser(B) >> ... then shift 'multiplication_c', go to state 238
Parser(B) >> Reduce 205 [addition_c ::= multiplication_c], pop back to state 61.
Parser(B) >> ... then shift 'addition_c', go to state 244
Parser(B) >> Reduce 210 [concatenation ::= concatenation addition_c], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_EOC instruction_list TK_SAY concatenation TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 61.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 61.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 61.
Parser(B) >> ... then shift 'bracket', go to state 216
Parser(B) >> Reduce 196 [prefix_expression_c ::= bracket], pop back to state 61.
Parser(B) >> ... then shift 'prefix_expression_c', go to state 214
Parser(B) >> Reduce 198 [power_expression_c ::= prefix_expression_c], pop back to state 61.
Parser(B) >> ... then shift 'power_expression_c', go to state 213
Parser(B) >> Reduce 200 [multiplication_c ::= power_expression_c], pop back to state 61.
Parser(B) >> ... then shift 'multiplication_c', go to state 238
Parser(B) >> Reduce 205 [addition_c ::= multiplication_c], pop back to state 61.
Parser(B) >> ... then shift 'addition_c', go to state 244
Parser(B) >> Reduce 210 [concatenation ::= concatenation addition_c], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_EOC instruction_list TK_SAY concatenation TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 61.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 61.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 61.
Parser(B) >> ... then shift 'bracket', go to state 216
Parser(B) >> Reduce 196 [prefix_expression_c ::= bracket], pop back to state 61.
Parser(B) >> ... then shift 'prefix_expression_c', go to state 214
Parser(B) >> Reduce 198 [power_expression_c ::= prefix_expression_c], pop back to state 61.
Parser(B) >> ... then shift 'power_expression_c', go to state 213
Parser(B) >> Reduce 200 [multiplication_c ::= power_expression_c], pop back to state 61.
Parser(B) >> ... then shift 'multiplication_c', go to state 238
Parser(B) >> Reduce 205 [addition_c ::= multiplication_c], pop back to state 61.
Parser(B) >> ... then shift 'addition_c', go to state 244
Parser(B) >> Reduce 210 [concatenation ::= concatenation addition_c], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_EOC instruction_list TK_SAY concatenation TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 61.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 61.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 61.
Parser(B) >> ... then shift 'bracket', go to state 216
Parser(B) >> Reduce 196 [prefix_expression_c ::= bracket], pop back to state 61.
Parser(B) >> ... then shift 'prefix_expression_c', go to state 214
Parser(B) >> Reduce 198 [power_expression_c ::= prefix_expression_c], pop back to state 61.
Parser(B) >> ... then shift 'power_expression_c', go to state 213
Parser(B) >> Reduce 200 [multiplication_c ::= power_expression_c], pop back to state 61.
Parser(B) >> ... then shift 'multiplication_c', go to state 238
Parser(B) >> Reduce 205 [addition_c ::= multiplication_c], pop back to state 61.
Parser(B) >> ... then shift 'addition_c', go to state 244
Parser(B) >> Reduce 210 [concatenation ::= concatenation addition_c], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_EOC instruction_list TK_SAY concatenation TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 61.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 61.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 61.
Parser(B) >> ... then shift 'bracket', go to state 216
Parser(B) >> Reduce 196 [prefix_expression_c ::= bracket], pop back to state 61.
Parser(B) >> ... then shift 'prefix_expression_c', go to state 214
Parser(B) >> Reduce 198 [power_expression_c ::= prefix_expression_c], pop back to state 61.
Parser(B) >> ... then shift 'power_expression_c', go to state 213
Parser(B) >> Reduce 200 [multiplication_c ::= power_expression_c], pop back to state 61.
Parser(B) >> ... then shift 'multiplication_c', go to state 238
Parser(B) >> Reduce 205 [addition_c ::= multiplication_c], pop back to state 61.
Parser(B) >> ... then shift 'addition_c', go to state 244
Parser(B) >> Reduce 210 [concatenation ::= concatenation addition_c], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_EOC instruction_list TK_SAY concatenation TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_MINUS' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 61.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 61.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 61.
Parser(B) >> ... then shift 'bracket', go to state 216
Parser(B) >> Reduce 196 [prefix_expression_c ::= bracket], pop back to state 61.
Parser(B) >> ... then shift 'prefix_expression_c', go to state 214
Parser(B) >> Reduce 198 [power_expression_c ::= prefix_expression_c], pop back to state 61.
Parser(B) >> ... then shift 'power_expression_c', go to state 213
Parser(B) >> Reduce 200 [multiplication_c ::= power_expression_c], pop back to state 61.
Parser(B) >> ... then shift 'multiplication_c', go to state 238
Parser(B) >> Reduce 205 [addition_c ::= multiplication_c], pop back to state 61.
Parser(B) >> ... then shift 'addition_c', go to state 244
Parser(B) >> Shift 'TK_MINUS', go to state 65
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_EOC instruction_list TK_SAY concatenation addition_c TK_MINUS]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 65
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_EOC instruction_list TK_SAY concatenation addition_c TK_MINUS TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EOC' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 65.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 65.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 65.
Parser(B) >> ... then shift 'bracket', go to state 216
Parser(B) >> Reduce 196 [prefix_expression_c ::= bracket], pop back to state 65.
Parser(B) >> ... then shift 'prefix_expression_c', go to state 214
Parser(B) >> Reduce 198 [power_expression_c ::= prefix_expression_c], pop back to state 65.
Parser(B) >> ... then shift 'power_expression_c', go to state 213
Parser(B) >> Reduce 200 [multiplication_c ::= power_expression_c], pop back to state 65.
Parser(B) >> ... then shift 'multiplication_c', go to state 236
Parser(B) >> Reduce 207 [addition_c ::= addition_c TK_MINUS multiplication_c], pop back to state 61.
Parser(B) >> ... then shift 'addition_c', go to state 244
Parser(B) >> Reduce 210 [concatenation ::= concatenation addition_c], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 22.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 22.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 22.
Parser(B) >> ... then shift 'expression', go to state 331
Parser(B) >> Reduce 160 [say ::= TK_SAY expression], pop back to state 9.
Parser(B) >> ... then shift 'say', go to state 365
Parser(B) >> Reduce 60 [keyword_instruction ::= say], pop back to state 9.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 9.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_EOC instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 9.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 3.
Parser(B) >> ... then shift 'instruction_list', go to state 9
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_EOC instruction_list TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 9.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_EOC instruction_list var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 33
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_EOC instruction_list var_symbol TK_EQUAL TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_PLUS' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 33.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Shift 'TK_PLUS', go to state 64
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_EOC instruction_list var_symbol TK_EQUAL addition TK_PLUS]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 64
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_EOC instruction_list var_symbol TK_EQUAL addition TK_PLUS TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EOC' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 64.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 64.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 64.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 64.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 64.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 64.
Parser(B) >> ... then shift 'multiplication', go to state 240
Parser(B) >> Reduce 194 [addition ::= addition TK_PLUS multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 9.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 9.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_EOC instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 9.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 3.
Parser(B) >> ... then shift 'instruction_list', go to state 9
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_EOC instruction_list TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 9.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_EOC instruction_list var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 33
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_EOC instruction_list var_symbol TK_EQUAL TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_MINUS' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 33.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Shift 'TK_MINUS', go to state 63
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_EOC instruction_list var_symbol TK_EQUAL addition TK_MINUS]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 63
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_EOC instruction_list var_symbol TK_EQUAL addition TK_MINUS TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EOC' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 63.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 63.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 63.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 63.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 63.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 63.
Parser(B) >> ... then shift 'multiplication', go to state 239
Parser(B) >> Reduce 195 [addition ::= addition TK_MINUS multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 9.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 9.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_EOC instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_END' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 9.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 3.
Parser(B) >> ... then shift 'instruction_list', go to state 9
Parser(B) >> Shift 'TK_END', go to state 128
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_EOC instruction_list TK_END]
Parser(B) >> Input 'TK_EOC' in state 128
Parser(B) >> Reduce 82 [do ::= tk_doloop dorep TK_EOC instruction_list TK_END], pop back to state 8.
Parser(B) >> ... then shift 'do', go to state 101
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 405
Parser(B) >> Shift 'TK_EOC', go to state 186
Parser(B) >> Return. Stack=[rexx_options instruction_list do junk TK_EOC]
Parser(B) >> Input 'TK_EOS' in state 186
Parser(B) >> Reduce 71 [group ::= do junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'group', go to state 193
Parser(B) >> Reduce 35 [labeled_instruction ::= group], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_EOS', go to state 388
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_EOS]
Parser(B) >> Input '$' in state 388
Parser(B) >> Reduce 1 [program ::= rexx_options instruction_list TK_EOS], pop back to state 0.
Parser(B) >> ... then shift 'program', pending reduce -2
Parser(B) >> Accept!
Options parser >> Input 'TK_OPTIONS' in state 0
Options parser >> Shift 'TK_OPTIONS', go to state 1
Options parser >> Return. Stack=[TK_OPTIONS]
Options parser >> Input 'TK_LEVELB' in state 1
Options parser >> Shift 'TK_LEVELB', go to state 16
Options parser >> Return. Stack=[TK_OPTIONS TK_LEVELB]
Options parser >> Input 'TK_EOC' in state 16
Options parser >> Reduce 4 [option ::= TK_LEVELB], pop back to state 1.
Options parser >> ... then shift 'option', go to state 4
Options parser >> Reduce 18 [option_list ::= option] without external action, pop back to state 1.
Options parser >> ... then shift 'option_list', go to state 2
Options parser >> Shift 'TK_EOC', go to state 23
Options parser >> Return. Stack=[TK_OPTIONS option_list TK_EOC]
Options parser >> Input 'TK_SYMBOL' in state 23
Options parser >> WILDCARD TK_SYMBOL => ANYTHING
Options parser >> Reduce 2 [rexx_options ::= TK_OPTIONS option_list TK_EOC], pop back to state 0.
Options parser >> ... then shift 'rexx_options', go to state 3
Options parser >> WILDCARD TK_SYMBOL => ANYTHING
Options parser >> Shift 'TK_SYMBOL', go to state 20
Options parser >> Return. Stack=[rexx_options TK_SYMBOL]
Options parser >> Popping TK_SYMBOL
Options parser >> Popping rexx_options
Parser(B) >> Stack grows from 0 to 100 entries.
Parser(B) >> Input 'TK_OPTIONS' in state 0
Parser(B) >> Shift 'TK_OPTIONS', go to state 81
Parser(B) >> Return. Stack=[TK_OPTIONS]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 81
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 301
Parser(B) >> Return. Stack=[TK_OPTIONS TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EOC' in state 301
Parser(B) >> Reduce 18 [option ::= TK_VAR_SYMBOL], pop back to state 81.
Parser(B) >> ... then shift 'option', go to state 300
Parser(B) >> Reduce 16 [option_list ::= option], pop back to state 81.
Parser(B) >> ... then shift 'option_list', go to state 90
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 130
Parser(B) >> Shift 'TK_EOC', go to state 195
Parser(B) >> Return. Stack=[TK_OPTIONS option_list junk TK_EOC]
Parser(B) >> Input 'TK_NAMESPACE' in state 195
Parser(B) >> Reduce 15 [rexx_options ::= TK_OPTIONS option_list junk TK_EOC], pop back to state 0.
Parser(B) >> ... then shift 'rexx_options', go to state 1
Parser(B) >> Shift 'TK_NAMESPACE', go to state 92
Parser(B) >> Return. Stack=[rexx_options TK_NAMESPACE]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 92
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 290
Parser(B) >> Return. Stack=[rexx_options TK_NAMESPACE TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EXPOSE' in state 290
Parser(B) >> Reduce 20 [literal ::= TK_VAR_SYMBOL], pop back to state 92.
Parser(B) >> ... then shift 'literal', go to state 83
Parser(B) >> Shift 'TK_EXPOSE', go to state 104
Parser(B) >> Return. Stack=[rexx_options TK_NAMESPACE literal TK_EXPOSE]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 104
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 290
Parser(B) >> Return. Stack=[rexx_options TK_NAMESPACE literal TK_EXPOSE TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EOC' in state 290
Parser(B) >> Reduce 20 [literal ::= TK_VAR_SYMBOL], pop back to state 104.
Parser(B) >> ... then shift 'literal', go to state 293
Parser(B) >> Reduce 31 [expose_list ::= literal], pop back to state 104.
Parser(B) >> ... then shift 'expose_list', go to state 115
Parser(B) >> Reduce 30 [expose ::= TK_EXPOSE expose_list], pop back to state 83.
Parser(B) >> ... then shift 'expose', go to state 98
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 390
Parser(B) >> Shift 'TK_EOC', go to state 203
Parser(B) >> Return. Stack=[rexx_options TK_NAMESPACE literal expose junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 203
Parser(B) >> Reduce 24 [namespace_instruction ::= TK_NAMESPACE literal expose junk TK_EOC], pop back to state 1.
Parser(B) >> ... then shift 'namespace_instruction', go to state 197
Parser(B) >> Reduce 21 [namespace_list ::= namespace_instruction], pop back to state 1.
Parser(B) >> ... then shift 'namespace_list', go to state 2
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options namespace_list TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 2.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options namespace_list var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_INTEGER' in state 33
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options namespace_list var_symbol TK_EQUAL TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 2.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 2.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options namespace_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_SAY' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 2.
Parser(B) >> ... then shift 'labeled_instruction', go to state 184
Parser(B) >> Reduce 33 [instruction_list ::= labeled_instruction], pop back to state 2.
Parser(B) >> ... then shift 'instruction_list', go to state 11
Parser(B) >> Shift 'TK_SAY', go to state 22
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_SAY]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 22
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_SAY TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EOC' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 22.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 22.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 22.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 22.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 22.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 22.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 22.
Parser(B) >> ... then shift 'expression', go to state 331
Parser(B) >> Reduce 160 [say ::= TK_SAY expression], pop back to state 11.
Parser(B) >> ... then shift 'say', go to state 365
Parser(B) >> Reduce 60 [keyword_instruction ::= say], pop back to state 11.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 11.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_LABEL' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 11.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 2.
Parser(B) >> ... then shift 'instruction_list', go to state 11
Parser(B) >> Shift 'TK_LABEL', go to state 173
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_LABEL]
Parser(B) >> Input 'TK_PROCEDURE' in state 173
Parser(B) >> Shift 'TK_PROCEDURE', go to state 319
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_LABEL TK_PROCEDURE]
Parser(B) >> Input 'TK_EQUAL' in state 319
Parser(B) >> Shift 'TK_EQUAL', go to state 132
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_LABEL TK_PROCEDURE TK_EQUAL]
Parser(B) >> Input 'TK_CLASS' in state 132
Parser(B) >> Shift 'TK_CLASS', go to state 318
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_LABEL TK_PROCEDURE TK_EQUAL TK_CLASS]
Parser(B) >> Input 'TK_EOC' in state 318
Parser(B) >> Reduce 120 [class ::= TK_CLASS], pop back to state 132.
Parser(B) >> ... then shift 'class', go to state 379
Parser(B) >> Reduce 116 [procedure ::= TK_LABEL TK_PROCEDURE TK_EQUAL class], pop back to state 11.
Parser(B) >> ... then shift 'procedure', go to state 367
Parser(B) >> Reduce 58 [keyword_instruction ::= procedure], pop back to state 11.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 11.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_ARG' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 11.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 2.
Parser(B) >> ... then shift 'instruction_list', go to state 11
Parser(B) >> Shift 'TK_ARG', go to state 82
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_ARG]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 82
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 297
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_ARG TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 297
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 82.
Parser(B) >> ... then shift 'var_symbol', go to state 401
Parser(B) >> Shift 'TK_EQUAL', go to state 19
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_ARG var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_CLASS' in state 19
Parser(B) >> Shift 'TK_CLASS', go to state 318
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_ARG var_symbol TK_EQUAL TK_CLASS]
Parser(B) >> Input 'TK_EOC' in state 318
Parser(B) >> Reduce 120 [class ::= TK_CLASS], pop back to state 19.
Parser(B) >> ... then shift 'class', go to state 313
Parser(B) >> Reduce 125 [argument ::= var_symbol TK_EQUAL class], pop back to state 82.
Parser(B) >> ... then shift 'argument', go to state 311
Parser(B) >> Reduce 122 [arg_list ::= argument], pop back to state 82.
Parser(B) >> ... then shift 'arg_list', go to state 317
Parser(B) >> Reduce 119 [arg ::= TK_ARG arg_list], pop back to state 11.
Parser(B) >> ... then shift 'arg', go to state 372
Parser(B) >> Reduce 53 [keyword_instruction ::= arg], pop back to state 11.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 11.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_RETURN' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 11.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 2.
Parser(B) >> ... then shift 'instruction_list', go to state 11
Parser(B) >> Shift 'TK_RETURN', go to state 23
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_RETURN]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 23
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_RETURN TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_MULT' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 23.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 23.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 23.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 23.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 23.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 23.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Shift 'TK_MULT', go to state 70
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_RETURN multiplication TK_MULT]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 70
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_RETURN multiplication TK_MULT TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EOC' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 70.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 70.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 70.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 70.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 70.
Parser(B) >> ... then shift 'power_expression', go to state 220
Parser(B) >> Reduce 189 [multiplication ::= multiplication TK_MULT power_expression], pop back to state 23.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 23.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 23.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 23.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 23.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 23.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 23.
Parser(B) >> ... then shift 'expression', go to state 332
Parser(B) >> Reduce 158 [return ::= TK_RETURN expression], pop back to state 11.
Parser(B) >> ... then shift 'return', go to state 366
Parser(B) >> Reduce 59 [keyword_instruction ::= return], pop back to state 11.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 11.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_EOS' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 11.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 2.
Parser(B) >> ... then shift 'instruction_list', go to state 11
Parser(B) >> Shift 'TK_EOS', go to state 409
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_EOS]
Parser(B) >> Input '$' in state 409
Parser(B) >> Reduce 0 [program ::= rexx_options namespace_list instruction_list TK_EOS], pop back to state 0.
Parser(B) >> ... then shift 'program', pending reduce -2
Parser(B) >> Accept!
Parser(B) >> Stack grows from 0 to 100 entries.
Options parser >> Input 'TK_OPTIONS' in state 0
Options parser >> Shift 'TK_OPTIONS', go to state 1
Options parser >> Return. Stack=[TK_OPTIONS]
Options parser >> Input 'TK_LEVELB' in state 1
Options parser >> Shift 'TK_LEVELB', go to state 16
Options parser >> Return. Stack=[TK_OPTIONS TK_LEVELB]
Options parser >> Input 'TK_EOC' in state 16
Options parser >> Reduce 4 [option ::= TK_LEVELB], pop back to state 1.
Options parser >> ... then shift 'option', go to state 4
Options parser >> Reduce 18 [option_list ::= option] without external action, pop back to state 1.
Options parser >> ... then shift 'option_list', go to state 2
Options parser >> Shift 'TK_EOC', go to state 23
Options parser >> Return. Stack=[TK_OPTIONS option_list TK_EOC]
Options parser >> Input 'TK_SYMBOL' in state 23
Options parser >> WILDCARD TK_SYMBOL => ANYTHING
Options parser >> Reduce 2 [rexx_options ::= TK_OPTIONS option_list TK_EOC], pop back to state 0.
Options parser >> ... then shift 'rexx_options', go to state 3
Options parser >> WILDCARD TK_SYMBOL => ANYTHING
Options parser >> Shift 'TK_SYMBOL', go to state 20
Options parser >> Return. Stack=[rexx_options TK_SYMBOL]
Options parser >> Popping TK_SYMBOL
Options parser >> Popping rexx_options
Parser(B) >> Input 'TK_OPTIONS' in state 0
Parser(B) >> Shift 'TK_OPTIONS', go to state 81
Parser(B) >> Return. Stack=[TK_OPTIONS]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 81
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 301
Parser(B) >> Return. Stack=[TK_OPTIONS TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EOC' in state 301
Parser(B) >> Reduce 18 [option ::= TK_VAR_SYMBOL], pop back to state 81.
Parser(B) >> ... then shift 'option', go to state 300
Parser(B) >> Reduce 16 [option_list ::= option], pop back to state 81.
Parser(B) >> ... then shift 'option_list', go to state 90
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 130
Parser(B) >> Shift 'TK_EOC', go to state 195
Parser(B) >> Return. Stack=[TK_OPTIONS option_list junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 195
Parser(B) >> Reduce 15 [rexx_options ::= TK_OPTIONS option_list junk TK_EOC], pop back to state 0.
Parser(B) >> ... then shift 'rexx_options', go to state 1
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 1.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_STRING' in state 33
Parser(B) >> Shift 'TK_STRING', go to state 111
Parser(B) >> Return. Stack=[rexx_options var_symbol TK_EQUAL TK_STRING]
Parser(B) >> Input 'TK_EOC' in state 111
Parser(B) >> Reduce 179 [term ::= TK_STRING], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 1.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 1.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 1.
Parser(B) >> ... then shift 'labeled_instruction', go to state 184
Parser(B) >> Reduce 33 [instruction_list ::= labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 8.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 33
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_CONCAT' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 33.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Shift 'TK_CONCAT', go to state 62
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL concatenation TK_CONCAT]
Parser(B) >> Input 'TK_STRING' in state 62
Parser(B) >> Shift 'TK_STRING', go to state 111
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL concatenation TK_CONCAT TK_STRING]
Parser(B) >> Input 'TK_EOC' in state 111
Parser(B) >> Reduce 179 [term ::= TK_STRING], pop back to state 62.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 62.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 62.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 62.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 62.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 62.
Parser(B) >> ... then shift 'addition', go to state 243
Parser(B) >> Reduce 209 [concatenation ::= concatenation TK_CONCAT addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 8.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 8.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 33
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_CONCAT' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 33.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Shift 'TK_CONCAT', go to state 62
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL concatenation TK_CONCAT]
Parser(B) >> Input 'TK_STRING' in state 62
Parser(B) >> Shift 'TK_STRING', go to state 111
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL concatenation TK_CONCAT TK_STRING]
Parser(B) >> Input 'TK_EOC' in state 111
Parser(B) >> Reduce 179 [term ::= TK_STRING], pop back to state 62.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 62.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 62.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 62.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 62.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 62.
Parser(B) >> ... then shift 'addition', go to state 243
Parser(B) >> Reduce 209 [concatenation ::= concatenation TK_CONCAT addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 8.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_SAY' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_SAY', go to state 22
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY]
Parser(B) >> Input 'TK_STRING' in state 22
Parser(B) >> Shift 'TK_STRING', go to state 111
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY TK_STRING]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 111
Parser(B) >> Reduce 179 [term ::= TK_STRING], pop back to state 22.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 22.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 22.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY concatenation TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EOC' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 61.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 61.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 61.
Parser(B) >> ... then shift 'bracket', go to state 216
Parser(B) >> Reduce 196 [prefix_expression_c ::= bracket], pop back to state 61.
Parser(B) >> ... then shift 'prefix_expression_c', go to state 214
Parser(B) >> Reduce 198 [power_expression_c ::= prefix_expression_c], pop back to state 61.
Parser(B) >> ... then shift 'power_expression_c', go to state 213
Parser(B) >> Reduce 200 [multiplication_c ::= power_expression_c], pop back to state 61.
Parser(B) >> ... then shift 'multiplication_c', go to state 238
Parser(B) >> Reduce 205 [addition_c ::= multiplication_c], pop back to state 61.
Parser(B) >> ... then shift 'addition_c', go to state 244
Parser(B) >> Reduce 210 [concatenation ::= concatenation addition_c], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 22.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 22.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 22.
Parser(B) >> ... then shift 'expression', go to state 331
Parser(B) >> Reduce 160 [say ::= TK_SAY expression], pop back to state 8.
Parser(B) >> ... then shift 'say', go to state 365
Parser(B) >> Reduce 60 [keyword_instruction ::= say], pop back to state 8.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 8.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_STRING' in state 33
Parser(B) >> Shift 'TK_STRING', go to state 111
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL TK_STRING]
Parser(B) >> Input 'TK_EOC' in state 111
Parser(B) >> Reduce 179 [term ::= TK_STRING], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 8.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_SAY' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_SAY', go to state 22
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 22
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EOC' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 22.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 22.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 22.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 22.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 22.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 22.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 22.
Parser(B) >> ... then shift 'expression', go to state 331
Parser(B) >> Reduce 160 [say ::= TK_SAY expression], pop back to state 8.
Parser(B) >> ... then shift 'say', go to state 365
Parser(B) >> Reduce 60 [keyword_instruction ::= say], pop back to state 8.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 8.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_INTEGER' in state 33
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 8.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 8.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_INTEGER' in state 33
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 8.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 8.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_INTEGER' in state 33
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 8.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 8.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_INTEGER' in state 33
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 8.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_SAY' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_SAY', go to state 22
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 22
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EOC' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 22.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 22.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 22.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 22.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 22.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 22.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 22.
Parser(B) >> ... then shift 'expression', go to state 331
Parser(B) >> Reduce 160 [say ::= TK_SAY expression], pop back to state 8.
Parser(B) >> ... then shift 'say', go to state 365
Parser(B) >> Reduce 60 [keyword_instruction ::= say], pop back to state 8.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_SAY' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_SAY', go to state 22
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 22
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EOC' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 22.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 22.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 22.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 22.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 22.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 22.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 22.
Parser(B) >> ... then shift 'expression', go to state 331
Parser(B) >> Reduce 160 [say ::= TK_SAY expression], pop back to state 8.
Parser(B) >> ... then shift 'say', go to state 365
Parser(B) >> Reduce 60 [keyword_instruction ::= say], pop back to state 8.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_SAY' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_SAY', go to state 22
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 22
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EOC' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 22.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 22.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 22.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 22.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 22.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 22.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 22.
Parser(B) >> ... then shift 'expression', go to state 331
Parser(B) >> Reduce 160 [say ::= TK_SAY expression], pop back to state 8.
Parser(B) >> ... then shift 'say', go to state 365
Parser(B) >> Reduce 60 [keyword_instruction ::= say], pop back to state 8.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_SAY' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_SAY', go to state 22
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 22
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EOC' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 22.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 22.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 22.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 22.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 22.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 22.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 22.
Parser(B) >> ... then shift 'expression', go to state 331
Parser(B) >> Reduce 160 [say ::= TK_SAY expression], pop back to state 8.
Parser(B) >> ... then shift 'say', go to state 365
Parser(B) >> Reduce 60 [keyword_instruction ::= say], pop back to state 8.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_EOS' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_EOS', go to state 388
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_EOS]
Parser(B) >> Input '$' in state 388
Parser(B) >> Reduce 1 [program ::= rexx_options instruction_list TK_EOS], pop back to state 0.
Parser(B) >> ... then shift 'program', pending reduce -2
Parser(B) >> Accept!
Options parser >> Input 'TK_OPTIONS' in state 0
Options parser >> Shift 'TK_OPTIONS', go to state 1
Options parser >> Return. Stack=[TK_OPTIONS]
Options parser >> Input 'TK_LEVELB' in state 1
Options parser >> Shift 'TK_LEVELB', go to state 16
Options parser >> Return. Stack=[TK_OPTIONS TK_LEVELB]
Options parser >> Input 'TK_EOC' in state 16
Options parser >> Reduce 4 [option ::= TK_LEVELB], pop back to state 1.
Options parser >> ... then shift 'option', go to state 4
Options parser >> Reduce 18 [option_list ::= option] without external action, pop back to state 1.
Options parser >> ... then shift 'option_list', go to state 2
Options parser >> Shift 'TK_EOC', go to state 23
Options parser >> Return. Stack=[TK_OPTIONS option_list TK_EOC]
Options parser >> Input 'TK_SYMBOL' in state 23
Options parser >> WILDCARD TK_SYMBOL => ANYTHING
Options parser >> Reduce 2 [rexx_options ::= TK_OPTIONS option_list TK_EOC], pop back to state 0.
Options parser >> ... then shift 'rexx_options', go to state 3
Options parser >> WILDCARD TK_SYMBOL => ANYTHING
Options parser >> Shift 'TK_SYMBOL', go to state 20
Options parser >> Return. Stack=[rexx_options TK_SYMBOL]
Options parser >> Popping TK_SYMBOL
Options parser >> Popping rexx_options
Parser(B) >> Stack grows from 0 to 100 entries.
Parser(B) >> Input 'TK_OPTIONS' in state 0
Parser(B) >> Shift 'TK_OPTIONS', go to state 81
Parser(B) >> Return. Stack=[TK_OPTIONS]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 81
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 301
Parser(B) >> Return. Stack=[TK_OPTIONS TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EOC' in state 301
Parser(B) >> Reduce 18 [option ::= TK_VAR_SYMBOL], pop back to state 81.
Parser(B) >> ... then shift 'option', go to state 300
Parser(B) >> Reduce 16 [option_list ::= option], pop back to state 81.
Parser(B) >> ... then shift 'option_list', go to state 90
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 130
Parser(B) >> Shift 'TK_EOC', go to state 195
Parser(B) >> Return. Stack=[TK_OPTIONS option_list junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 195
Parser(B) >> Reduce 15 [rexx_options ::= TK_OPTIONS option_list junk TK_EOC], pop back to state 0.
Parser(B) >> ... then shift 'rexx_options', go to state 1
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 1.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_INTEGER' in state 33
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options var_symbol TK_EQUAL TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 1.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 1.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 1.
Parser(B) >> ... then shift 'labeled_instruction', go to state 184
Parser(B) >> Reduce 33 [instruction_list ::= labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 8.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_STRING' in state 33
Parser(B) >> Shift 'TK_STRING', go to state 111
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL TK_STRING]
Parser(B) >> Input 'TK_EOC' in state 111
Parser(B) >> Reduce 179 [term ::= TK_STRING], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 8.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_SAY' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_SAY', go to state 22
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY]
Parser(B) >> Input 'TK_STRING' in state 22
Parser(B) >> Shift 'TK_STRING', go to state 111
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY TK_STRING]
Parser(B) >> Input 'TK_EOC' in state 111
Parser(B) >> Reduce 179 [term ::= TK_STRING], pop back to state 22.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 22.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 22.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 22.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 22.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 22.
Parser(B) >> ... then shift 'expression', go to state 331
Parser(B) >> Reduce 160 [say ::= TK_SAY expression], pop back to state 8.
Parser(B) >> ... then shift 'say', go to state 365
Parser(B) >> Reduce 60 [keyword_instruction ::= say], pop back to state 8.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_IF' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_IF', go to state 30
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF]
Parser(B) >> Input 'TK_MINUS' in state 30
Parser(B) >> Shift 'TK_MINUS', go to state 76
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_MINUS]
Parser(B) >> Input 'TK_INTEGER' in state 76
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_MINUS TK_INTEGER]
Parser(B) >> Input 'TK_POWER' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 76.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 76.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 76.
Parser(B) >> ... then shift 'prefix_expression', go to state 224
Parser(B) >> Reduce 185 [prefix_expression ::= TK_MINUS prefix_expression], pop back to state 30.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 30.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Shift 'TK_POWER', go to state 75
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF power_expression TK_POWER]
Parser(B) >> Input 'TK_INTEGER' in state 75
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF power_expression TK_POWER TK_INTEGER]
Parser(B) >> Input 'TK_NEQ' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 75.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 75.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 75.
Parser(B) >> ... then shift 'prefix_expression', go to state 221
Parser(B) >> Reduce 187 [power_expression ::= power_expression TK_POWER prefix_expression], pop back to state 30.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 30.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 30.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 30.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Shift 'TK_NEQ', go to state 47
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ]
Parser(B) >> Input 'TK_INTEGER' in state 47
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ TK_INTEGER]
Parser(B) >> Input 'TK_THEN' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 47.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 47.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 47.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 47.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 47.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 47.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 47.
Parser(B) >> ... then shift 'concatenation', go to state 59
Parser(B) >> Reduce 213 [comparison ::= comparison TK_NEQ concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 30.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 30.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 30.
Parser(B) >> ... then shift 'expression', go to state 127
Parser(B) >> Reduce 254 [ncl0 ::=] without external action.
Parser(B) >> ... then shift 'ncl0', go to state 131
Parser(B) >> Shift 'TK_THEN', go to state 109
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN]
Parser(B) >> Input 'TK_DO' in state 109
Parser(B) >> Reduce 254 [ncl0 ::=] without external action.
Parser(B) >> ... then shift 'ncl0', go to state 15
Parser(B) >> Shift 'TK_DO', go to state 113
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO]
Parser(B) >> Input 'TK_EOC' in state 113
Parser(B) >> Shift 'TK_EOC', go to state 7
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC]
Parser(B) >> Input 'TK_SAY' in state 7
Parser(B) >> Shift 'TK_SAY', go to state 22
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC TK_SAY]
Parser(B) >> Input 'TK_STRING' in state 22
Parser(B) >> Shift 'TK_STRING', go to state 111
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC TK_SAY TK_STRING]
Parser(B) >> Input 'TK_EOC' in state 111
Parser(B) >> Reduce 179 [term ::= TK_STRING], pop back to state 22.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 22.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 22.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 22.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 22.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 22.
Parser(B) >> ... then shift 'expression', go to state 331
Parser(B) >> Reduce 160 [say ::= TK_SAY expression], pop back to state 7.
Parser(B) >> ... then shift 'say', go to state 365
Parser(B) >> Reduce 60 [keyword_instruction ::= say], pop back to state 7.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 7.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 7.
Parser(B) >> ... then shift 'labeled_instruction', go to state 184
Parser(B) >> Reduce 33 [instruction_list ::= labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 10.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 33
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list var_symbol TK_EQUAL TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_PLUS' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 33.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Shift 'TK_PLUS', go to state 64
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list var_symbol TK_EQUAL addition TK_PLUS]
Parser(B) >> Input 'TK_INTEGER' in state 64
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list var_symbol TK_EQUAL addition TK_PLUS TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 64.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 64.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 64.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 64.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 64.
Parser(B) >> ... then shift 'multiplication', go to state 240
Parser(B) >> Reduce 194 [addition ::= addition TK_PLUS multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 10.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 10.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_END' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 10.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_END', go to state 129
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_END]
Parser(B) >> Input 'TK_EOC' in state 129
Parser(B) >> Reduce 73 [simple_do ::= TK_DO TK_EOC instruction_list TK_END], pop back to state 15.
Parser(B) >> ... then shift 'simple_do', go to state 102
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 406
Parser(B) >> Shift 'TK_EOC', go to state 187
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 simple_do junk TK_EOC]
Parser(B) >> Input 'TK_SAY' in state 187
Parser(B) >> Reduce 70 [group ::= simple_do junk TK_EOC], pop back to state 15.
Parser(B) >> ... then shift 'group', go to state 182
Parser(B) >> Reduce 41 [instruction ::= group], pop back to state 15.
Parser(B) >> ... then shift 'instruction', go to state 175
Parser(B) >> Reduce 110 [then ::= TK_THEN ncl0 instruction], pop back to state 131.
Parser(B) >> ... then shift 'then', go to state 108
Parser(B) >> Reduce 108 [if ::= TK_IF expression ncl0 then], pop back to state 8.
Parser(B) >> ... then shift 'if', go to state 185
Parser(B) >> Reduce 72 [group ::= if], pop back to state 8.
Parser(B) >> ... then shift 'group', go to state 193
Parser(B) >> Reduce 35 [labeled_instruction ::= group], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_SAY', go to state 22
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 22
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_PLUS' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 22.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 22.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 22.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 22.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Shift 'TK_PLUS', go to state 64
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY addition TK_PLUS]
Parser(B) >> Input 'TK_INTEGER' in state 64
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY addition TK_PLUS TK_INTEGER]
Parser(B) >> Input 'TK_STRING' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 64.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 64.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 64.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 64.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 64.
Parser(B) >> ... then shift 'multiplication', go to state 240
Parser(B) >> Reduce 194 [addition ::= addition TK_PLUS multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Shift 'TK_STRING', go to state 111
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY concatenation TK_STRING]
Parser(B) >> Input 'TK_EOC' in state 111
Parser(B) >> Reduce 179 [term ::= TK_STRING], pop back to state 61.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 61.
Parser(B) >> ... then shift 'bracket', go to state 216
Parser(B) >> Reduce 196 [prefix_expression_c ::= bracket], pop back to state 61.
Parser(B) >> ... then shift 'prefix_expression_c', go to state 214
Parser(B) >> Reduce 198 [power_expression_c ::= prefix_expression_c], pop back to state 61.
Parser(B) >> ... then shift 'power_expression_c', go to state 213
Parser(B) >> Reduce 200 [multiplication_c ::= power_expression_c], pop back to state 61.
Parser(B) >> ... then shift 'multiplication_c', go to state 238
Parser(B) >> Reduce 205 [addition_c ::= multiplication_c], pop back to state 61.
Parser(B) >> ... then shift 'addition_c', go to state 244
Parser(B) >> Reduce 210 [concatenation ::= concatenation addition_c], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 22.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 22.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 22.
Parser(B) >> ... then shift 'expression', go to state 331
Parser(B) >> Reduce 160 [say ::= TK_SAY expression], pop back to state 8.
Parser(B) >> ... then shift 'say', go to state 365
Parser(B) >> Reduce 60 [keyword_instruction ::= say], pop back to state 8.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_SAY' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_SAY', go to state 22
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 22
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_MINUS' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 22.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 22.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 22.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 22.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Shift 'TK_MINUS', go to state 63
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY addition TK_MINUS]
Parser(B) >> Input 'TK_INTEGER' in state 63
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY addition TK_MINUS TK_INTEGER]
Parser(B) >> Input 'TK_MULT' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 63.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 63.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 63.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 63.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 63.
Parser(B) >> ... then shift 'multiplication', go to state 239
Parser(B) >> Shift 'TK_MULT', go to state 70
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY addition TK_MINUS multiplication TK_MULT]
Parser(B) >> Input 'TK_INTEGER' in state 70
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY addition TK_MINUS multiplication TK_MULT TK_INTEGER]
Parser(B) >> Input 'TK_STRING' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 70.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 70.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 70.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 70.
Parser(B) >> ... then shift 'power_expression', go to state 220
Parser(B) >> Reduce 189 [multiplication ::= multiplication TK_MULT power_expression], pop back to state 63.
Parser(B) >> ... then shift 'multiplication', go to state 239
Parser(B) >> Reduce 195 [addition ::= addition TK_MINUS multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Shift 'TK_STRING', go to state 111
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY concatenation TK_STRING]
Parser(B) >> Input 'TK_EOC' in state 111
Parser(B) >> Reduce 179 [term ::= TK_STRING], pop back to state 61.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 61.
Parser(B) >> ... then shift 'bracket', go to state 216
Parser(B) >> Reduce 196 [prefix_expression_c ::= bracket], pop back to state 61.
Parser(B) >> ... then shift 'prefix_expression_c', go to state 214
Parser(B) >> Reduce 198 [power_expression_c ::= prefix_expression_c], pop back to state 61.
Parser(B) >> ... then shift 'power_expression_c', go to state 213
Parser(B) >> Reduce 200 [multiplication_c ::= power_expression_c], pop back to state 61.
Parser(B) >> ... then shift 'multiplication_c', go to state 238
Parser(B) >> Reduce 205 [addition_c ::= multiplication_c], pop back to state 61.
Parser(B) >> ... then shift 'addition_c', go to state 244
Parser(B) >> Reduce 210 [concatenation ::= concatenation addition_c], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 22.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 22.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 22.
Parser(B) >> ... then shift 'expression', go to state 331
Parser(B) >> Reduce 160 [say ::= TK_SAY expression], pop back to state 8.
Parser(B) >> ... then shift 'say', go to state 365
Parser(B) >> Reduce 60 [keyword_instruction ::= say], pop back to state 8.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_SAY' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_SAY', go to state 22
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 22
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_DIV' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 22.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 22.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 22.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 22.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Shift 'TK_DIV', go to state 69
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY multiplication TK_DIV]
Parser(B) >> Input 'TK_INTEGER' in state 69
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY multiplication TK_DIV TK_INTEGER]
Parser(B) >> Input 'TK_STRING' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 69.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 69.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 69.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 69.
Parser(B) >> ... then shift 'power_expression', go to state 219
Parser(B) >> Reduce 190 [multiplication ::= multiplication TK_DIV power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Shift 'TK_STRING', go to state 111
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY concatenation TK_STRING]
Parser(B) >> Input 'TK_EOC' in state 111
Parser(B) >> Reduce 179 [term ::= TK_STRING], pop back to state 61.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 61.
Parser(B) >> ... then shift 'bracket', go to state 216
Parser(B) >> Reduce 196 [prefix_expression_c ::= bracket], pop back to state 61.
Parser(B) >> ... then shift 'prefix_expression_c', go to state 214
Parser(B) >> Reduce 198 [power_expression_c ::= prefix_expression_c], pop back to state 61.
Parser(B) >> ... then shift 'power_expression_c', go to state 213
Parser(B) >> Reduce 200 [multiplication_c ::= power_expression_c], pop back to state 61.
Parser(B) >> ... then shift 'multiplication_c', go to state 238
Parser(B) >> Reduce 205 [addition_c ::= multiplication_c], pop back to state 61.
Parser(B) >> ... then shift 'addition_c', go to state 244
Parser(B) >> Reduce 210 [concatenation ::= concatenation addition_c], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 22.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 22.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 22.
Parser(B) >> ... then shift 'expression', go to state 331
Parser(B) >> Reduce 160 [say ::= TK_SAY expression], pop back to state 8.
Parser(B) >> ... then shift 'say', go to state 365
Parser(B) >> Reduce 60 [keyword_instruction ::= say], pop back to state 8.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_SAY' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_SAY', go to state 22
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY]
Parser(B) >> Input 'TK_FLOAT' in state 22
Parser(B) >> Shift 'TK_FLOAT', go to state 231
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY TK_FLOAT]
Parser(B) >> Input 'TK_POWER' in state 231
Parser(B) >> Reduce 177 [term ::= TK_FLOAT], pop back to state 22.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 22.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 22.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Shift 'TK_POWER', go to state 75
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY power_expression TK_POWER]
Parser(B) >> Input 'TK_INTEGER' in state 75
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY power_expression TK_POWER TK_INTEGER]
Parser(B) >> Input 'TK_STRING' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 75.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 75.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 75.
Parser(B) >> ... then shift 'prefix_expression', go to state 221
Parser(B) >> Reduce 187 [power_expression ::= power_expression TK_POWER prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Shift 'TK_STRING', go to state 111
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY concatenation TK_STRING]
Parser(B) >> Input 'TK_EOC' in state 111
Parser(B) >> Reduce 179 [term ::= TK_STRING], pop back to state 61.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 61.
Parser(B) >> ... then shift 'bracket', go to state 216
Parser(B) >> Reduce 196 [prefix_expression_c ::= bracket], pop back to state 61.
Parser(B) >> ... then shift 'prefix_expression_c', go to state 214
Parser(B) >> Reduce 198 [power_expression_c ::= prefix_expression_c], pop back to state 61.
Parser(B) >> ... then shift 'power_expression_c', go to state 213
Parser(B) >> Reduce 200 [multiplication_c ::= power_expression_c], pop back to state 61.
Parser(B) >> ... then shift 'multiplication_c', go to state 238
Parser(B) >> Reduce 205 [addition_c ::= multiplication_c], pop back to state 61.
Parser(B) >> ... then shift 'addition_c', go to state 244
Parser(B) >> Reduce 210 [concatenation ::= concatenation addition_c], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 22.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 22.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 22.
Parser(B) >> ... then shift 'expression', go to state 331
Parser(B) >> Reduce 160 [say ::= TK_SAY expression], pop back to state 8.
Parser(B) >> ... then shift 'say', go to state 365
Parser(B) >> Reduce 60 [keyword_instruction ::= say], pop back to state 8.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_SAY' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_SAY', go to state 22
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY]
Parser(B) >> Input 'TK_OPEN_BRACKET' in state 22
Parser(B) >> Shift 'TK_OPEN_BRACKET', go to state 34
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY TK_OPEN_BRACKET]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 34
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY TK_OPEN_BRACKET TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_PLUS' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 34.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 34.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 34.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 34.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 34.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 34.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 34.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Shift 'TK_PLUS', go to state 64
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY TK_OPEN_BRACKET addition TK_PLUS]
Parser(B) >> Input 'TK_INTEGER' in state 64
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY TK_OPEN_BRACKET addition TK_PLUS TK_INTEGER]
Parser(B) >> Input 'TK_CLOSE_BRACKET' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 64.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 64.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 64.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 64.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 64.
Parser(B) >> ... then shift 'multiplication', go to state 240
Parser(B) >> Reduce 194 [addition ::= addition TK_PLUS multiplication], pop back to state 34.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 34.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 34.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 34.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 34.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 34.
Parser(B) >> ... then shift 'expression', go to state 408
Parser(B) >> Shift 'TK_CLOSE_BRACKET', go to state 228
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY TK_OPEN_BRACKET expression TK_CLOSE_BRACKET]
Parser(B) >> Input 'TK_GT' in state 228
Parser(B) >> Reduce 181 [bracket ::= TK_OPEN_BRACKET expression TK_CLOSE_BRACKET], pop back to state 22.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 22.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Shift 'TK_GT', go to state 46
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY comparison TK_GT]
Parser(B) >> Input 'TK_INTEGER' in state 46
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY comparison TK_GT TK_INTEGER]
Parser(B) >> Input 'TK_STRING' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 46.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 46.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 46.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 46.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 46.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 46.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 46.
Parser(B) >> ... then shift 'concatenation', go to state 58
Parser(B) >> Shift 'TK_STRING', go to state 111
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY comparison TK_GT concatenation TK_STRING]
Parser(B) >> Input 'TK_EOC' in state 111
Parser(B) >> Reduce 179 [term ::= TK_STRING], pop back to state 58.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 58.
Parser(B) >> ... then shift 'bracket', go to state 216
Parser(B) >> Reduce 196 [prefix_expression_c ::= bracket], pop back to state 58.
Parser(B) >> ... then shift 'prefix_expression_c', go to state 214
Parser(B) >> Reduce 198 [power_expression_c ::= prefix_expression_c], pop back to state 58.
Parser(B) >> ... then shift 'power_expression_c', go to state 213
Parser(B) >> Reduce 200 [multiplication_c ::= power_expression_c], pop back to state 58.
Parser(B) >> ... then shift 'multiplication_c', go to state 238
Parser(B) >> Reduce 205 [addition_c ::= multiplication_c], pop back to state 58.
Parser(B) >> ... then shift 'addition_c', go to state 244
Parser(B) >> Reduce 210 [concatenation ::= concatenation addition_c], pop back to state 46.
Parser(B) >> ... then shift 'concatenation', go to state 58
Parser(B) >> Reduce 214 [comparison ::= comparison TK_GT concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 22.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 22.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 22.
Parser(B) >> ... then shift 'expression', go to state 331
Parser(B) >> Reduce 160 [say ::= TK_SAY expression], pop back to state 8.
Parser(B) >> ... then shift 'say', go to state 365
Parser(B) >> Reduce 60 [keyword_instruction ::= say], pop back to state 8.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_SAY' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_SAY', go to state 22
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY]
Parser(B) >> Input 'TK_STRING' in state 22
Parser(B) >> Shift 'TK_STRING', go to state 111
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY TK_STRING]
Parser(B) >> Input 'TK_EQUAL' in state 111
Parser(B) >> Reduce 179 [term ::= TK_STRING], pop back to state 22.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 22.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 22.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Shift 'TK_EQUAL', go to state 48
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY comparison TK_EQUAL]
Parser(B) >> Input 'TK_STRING' in state 48
Parser(B) >> Shift 'TK_STRING', go to state 111
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY comparison TK_EQUAL TK_STRING]
Parser(B) >> Input 'TK_STRING' in state 111
Parser(B) >> Reduce 179 [term ::= TK_STRING], pop back to state 48.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 48.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 48.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 48.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 48.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 48.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 48.
Parser(B) >> ... then shift 'concatenation', go to state 60
Parser(B) >> Shift 'TK_STRING', go to state 111
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY comparison TK_EQUAL concatenation TK_STRING]
Parser(B) >> Input 'TK_EOC' in state 111
Parser(B) >> Reduce 179 [term ::= TK_STRING], pop back to state 60.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 60.
Parser(B) >> ... then shift 'bracket', go to state 216
Parser(B) >> Reduce 196 [prefix_expression_c ::= bracket], pop back to state 60.
Parser(B) >> ... then shift 'prefix_expression_c', go to state 214
Parser(B) >> Reduce 198 [power_expression_c ::= prefix_expression_c], pop back to state 60.
Parser(B) >> ... then shift 'power_expression_c', go to state 213
Parser(B) >> Reduce 200 [multiplication_c ::= power_expression_c], pop back to state 60.
Parser(B) >> ... then shift 'multiplication_c', go to state 238
Parser(B) >> Reduce 205 [addition_c ::= multiplication_c], pop back to state 60.
Parser(B) >> ... then shift 'addition_c', go to state 244
Parser(B) >> Reduce 210 [concatenation ::= concatenation addition_c], pop back to state 48.
Parser(B) >> ... then shift 'concatenation', go to state 60
Parser(B) >> Reduce 212 [comparison ::= comparison TK_EQUAL concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 22.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 22.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 22.
Parser(B) >> ... then shift 'expression', go to state 331
Parser(B) >> Reduce 160 [say ::= TK_SAY expression], pop back to state 8.
Parser(B) >> ... then shift 'say', go to state 365
Parser(B) >> Reduce 60 [keyword_instruction ::= say], pop back to state 8.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_SAY' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_SAY', go to state 22
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY]
Parser(B) >> Input 'TK_OPEN_BRACKET' in state 22
Parser(B) >> Shift 'TK_OPEN_BRACKET', go to state 34
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY TK_OPEN_BRACKET]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 34
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY TK_OPEN_BRACKET TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_PLUS' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 34.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 34.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 34.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 34.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 34.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 34.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 34.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Shift 'TK_PLUS', go to state 64
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY TK_OPEN_BRACKET addition TK_PLUS]
Parser(B) >> Input 'TK_INTEGER' in state 64
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY TK_OPEN_BRACKET addition TK_PLUS TK_INTEGER]
Parser(B) >> Input 'TK_CLOSE_BRACKET' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 64.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 64.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 64.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 64.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 64.
Parser(B) >> ... then shift 'multiplication', go to state 240
Parser(B) >> Reduce 194 [addition ::= addition TK_PLUS multiplication], pop back to state 34.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 34.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 34.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 34.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 34.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 34.
Parser(B) >> ... then shift 'expression', go to state 408
Parser(B) >> Shift 'TK_CLOSE_BRACKET', go to state 228
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY TK_OPEN_BRACKET expression TK_CLOSE_BRACKET]
Parser(B) >> Input 'TK_MULT' in state 228
Parser(B) >> Reduce 181 [bracket ::= TK_OPEN_BRACKET expression TK_CLOSE_BRACKET], pop back to state 22.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 22.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Shift 'TK_MULT', go to state 70
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY multiplication TK_MULT]
Parser(B) >> Input 'TK_INTEGER' in state 70
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY multiplication TK_MULT TK_INTEGER]
Parser(B) >> Input 'TK_STRING' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 70.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 70.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 70.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 70.
Parser(B) >> ... then shift 'power_expression', go to state 220
Parser(B) >> Reduce 189 [multiplication ::= multiplication TK_MULT power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Shift 'TK_STRING', go to state 111
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY concatenation TK_STRING]
Parser(B) >> Input 'TK_EOC' in state 111
Parser(B) >> Reduce 179 [term ::= TK_STRING], pop back to state 61.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 61.
Parser(B) >> ... then shift 'bracket', go to state 216
Parser(B) >> Reduce 196 [prefix_expression_c ::= bracket], pop back to state 61.
Parser(B) >> ... then shift 'prefix_expression_c', go to state 214
Parser(B) >> Reduce 198 [power_expression_c ::= prefix_expression_c], pop back to state 61.
Parser(B) >> ... then shift 'power_expression_c', go to state 213
Parser(B) >> Reduce 200 [multiplication_c ::= power_expression_c], pop back to state 61.
Parser(B) >> ... then shift 'multiplication_c', go to state 238
Parser(B) >> Reduce 205 [addition_c ::= multiplication_c], pop back to state 61.
Parser(B) >> ... then shift 'addition_c', go to state 244
Parser(B) >> Reduce 210 [concatenation ::= concatenation addition_c], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 22.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 22.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 22.
Parser(B) >> ... then shift 'expression', go to state 331
Parser(B) >> Reduce 160 [say ::= TK_SAY expression], pop back to state 8.
Parser(B) >> ... then shift 'say', go to state 365
Parser(B) >> Reduce 60 [keyword_instruction ::= say], pop back to state 8.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_SAY' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_SAY', go to state 22
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 22
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 22.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 22.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 22.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 22.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY concatenation TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 61.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 61.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 61.
Parser(B) >> ... then shift 'bracket', go to state 216
Parser(B) >> Reduce 196 [prefix_expression_c ::= bracket], pop back to state 61.
Parser(B) >> ... then shift 'prefix_expression_c', go to state 214
Parser(B) >> Reduce 198 [power_expression_c ::= prefix_expression_c], pop back to state 61.
Parser(B) >> ... then shift 'power_expression_c', go to state 213
Parser(B) >> Reduce 200 [multiplication_c ::= power_expression_c], pop back to state 61.
Parser(B) >> ... then shift 'multiplication_c', go to state 238
Parser(B) >> Reduce 205 [addition_c ::= multiplication_c], pop back to state 61.
Parser(B) >> ... then shift 'addition_c', go to state 244
Parser(B) >> Reduce 210 [concatenation ::= concatenation addition_c], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY concatenation TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_STRING' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 61.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 61.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 61.
Parser(B) >> ... then shift 'bracket', go to state 216
Parser(B) >> Reduce 196 [prefix_expression_c ::= bracket], pop back to state 61.
Parser(B) >> ... then shift 'prefix_expression_c', go to state 214
Parser(B) >> Reduce 198 [power_expression_c ::= prefix_expression_c], pop back to state 61.
Parser(B) >> ... then shift 'power_expression_c', go to state 213
Parser(B) >> Reduce 200 [multiplication_c ::= power_expression_c], pop back to state 61.
Parser(B) >> ... then shift 'multiplication_c', go to state 238
Parser(B) >> Reduce 205 [addition_c ::= multiplication_c], pop back to state 61.
Parser(B) >> ... then shift 'addition_c', go to state 244
Parser(B) >> Reduce 210 [concatenation ::= concatenation addition_c], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Shift 'TK_STRING', go to state 111
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY concatenation TK_STRING]
Parser(B) >> Input 'TK_EOC' in state 111
Parser(B) >> Reduce 179 [term ::= TK_STRING], pop back to state 61.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 61.
Parser(B) >> ... then shift 'bracket', go to state 216
Parser(B) >> Reduce 196 [prefix_expression_c ::= bracket], pop back to state 61.
Parser(B) >> ... then shift 'prefix_expression_c', go to state 214
Parser(B) >> Reduce 198 [power_expression_c ::= prefix_expression_c], pop back to state 61.
Parser(B) >> ... then shift 'power_expression_c', go to state 213
Parser(B) >> Reduce 200 [multiplication_c ::= power_expression_c], pop back to state 61.
Parser(B) >> ... then shift 'multiplication_c', go to state 238
Parser(B) >> Reduce 205 [addition_c ::= multiplication_c], pop back to state 61.
Parser(B) >> ... then shift 'addition_c', go to state 244
Parser(B) >> Reduce 210 [concatenation ::= concatenation addition_c], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 22.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 22.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 22.
Parser(B) >> ... then shift 'expression', go to state 331
Parser(B) >> Reduce 160 [say ::= TK_SAY expression], pop back to state 8.
Parser(B) >> ... then shift 'say', go to state 365
Parser(B) >> Reduce 60 [keyword_instruction ::= say], pop back to state 8.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_SAY' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_SAY', go to state 22
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY]
Parser(B) >> Input 'TK_STRING' in state 22
Parser(B) >> Shift 'TK_STRING', go to state 111
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY TK_STRING]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 111
Parser(B) >> Reduce 179 [term ::= TK_STRING], pop back to state 22.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 22.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 22.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY concatenation TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_STRING' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 61.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 61.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 61.
Parser(B) >> ... then shift 'bracket', go to state 216
Parser(B) >> Reduce 196 [prefix_expression_c ::= bracket], pop back to state 61.
Parser(B) >> ... then shift 'prefix_expression_c', go to state 214
Parser(B) >> Reduce 198 [power_expression_c ::= prefix_expression_c], pop back to state 61.
Parser(B) >> ... then shift 'power_expression_c', go to state 213
Parser(B) >> Reduce 200 [multiplication_c ::= power_expression_c], pop back to state 61.
Parser(B) >> ... then shift 'multiplication_c', go to state 238
Parser(B) >> Reduce 205 [addition_c ::= multiplication_c], pop back to state 61.
Parser(B) >> ... then shift 'addition_c', go to state 244
Parser(B) >> Reduce 210 [concatenation ::= concatenation addition_c], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Shift 'TK_STRING', go to state 111
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY concatenation TK_STRING]
Parser(B) >> Input 'TK_EOC' in state 111
Parser(B) >> Reduce 179 [term ::= TK_STRING], pop back to state 61.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 61.
Parser(B) >> ... then shift 'bracket', go to state 216
Parser(B) >> Reduce 196 [prefix_expression_c ::= bracket], pop back to state 61.
Parser(B) >> ... then shift 'prefix_expression_c', go to state 214
Parser(B) >> Reduce 198 [power_expression_c ::= prefix_expression_c], pop back to state 61.
Parser(B) >> ... then shift 'power_expression_c', go to state 213
Parser(B) >> Reduce 200 [multiplication_c ::= power_expression_c], pop back to state 61.
Parser(B) >> ... then shift 'multiplication_c', go to state 238
Parser(B) >> Reduce 205 [addition_c ::= multiplication_c], pop back to state 61.
Parser(B) >> ... then shift 'addition_c', go to state 244
Parser(B) >> Reduce 210 [concatenation ::= concatenation addition_c], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 22.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 22.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 22.
Parser(B) >> ... then shift 'expression', go to state 331
Parser(B) >> Reduce 160 [say ::= TK_SAY expression], pop back to state 8.
Parser(B) >> ... then shift 'say', go to state 365
Parser(B) >> Reduce 60 [keyword_instruction ::= say], pop back to state 8.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_SAY' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_SAY', go to state 22
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY]
Parser(B) >> Input 'TK_STRING' in state 22
Parser(B) >> Shift 'TK_STRING', go to state 111
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY TK_STRING]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 111
Parser(B) >> Reduce 179 [term ::= TK_STRING], pop back to state 22.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 22.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 22.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY concatenation TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_STRING' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 61.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 61.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 61.
Parser(B) >> ... then shift 'bracket', go to state 216
Parser(B) >> Reduce 196 [prefix_expression_c ::= bracket], pop back to state 61.
Parser(B) >> ... then shift 'prefix_expression_c', go to state 214
Parser(B) >> Reduce 198 [power_expression_c ::= prefix_expression_c], pop back to state 61.
Parser(B) >> ... then shift 'power_expression_c', go to state 213
Parser(B) >> Reduce 200 [multiplication_c ::= power_expression_c], pop back to state 61.
Parser(B) >> ... then shift 'multiplication_c', go to state 238
Parser(B) >> Reduce 205 [addition_c ::= multiplication_c], pop back to state 61.
Parser(B) >> ... then shift 'addition_c', go to state 244
Parser(B) >> Reduce 210 [concatenation ::= concatenation addition_c], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Shift 'TK_STRING', go to state 111
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY concatenation TK_STRING]
Parser(B) >> Input 'TK_STRING' in state 111
Parser(B) >> Reduce 179 [term ::= TK_STRING], pop back to state 61.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 61.
Parser(B) >> ... then shift 'bracket', go to state 216
Parser(B) >> Reduce 196 [prefix_expression_c ::= bracket], pop back to state 61.
Parser(B) >> ... then shift 'prefix_expression_c', go to state 214
Parser(B) >> Reduce 198 [power_expression_c ::= prefix_expression_c], pop back to state 61.
Parser(B) >> ... then shift 'power_expression_c', go to state 213
Parser(B) >> Reduce 200 [multiplication_c ::= power_expression_c], pop back to state 61.
Parser(B) >> ... then shift 'multiplication_c', go to state 238
Parser(B) >> Reduce 205 [addition_c ::= multiplication_c], pop back to state 61.
Parser(B) >> ... then shift 'addition_c', go to state 244
Parser(B) >> Reduce 210 [concatenation ::= concatenation addition_c], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Shift 'TK_STRING', go to state 111
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY concatenation TK_STRING]
Parser(B) >> Input 'TK_EOC' in state 111
Parser(B) >> Reduce 179 [term ::= TK_STRING], pop back to state 61.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 61.
Parser(B) >> ... then shift 'bracket', go to state 216
Parser(B) >> Reduce 196 [prefix_expression_c ::= bracket], pop back to state 61.
Parser(B) >> ... then shift 'prefix_expression_c', go to state 214
Parser(B) >> Reduce 198 [power_expression_c ::= prefix_expression_c], pop back to state 61.
Parser(B) >> ... then shift 'power_expression_c', go to state 213
Parser(B) >> Reduce 200 [multiplication_c ::= power_expression_c], pop back to state 61.
Parser(B) >> ... then shift 'multiplication_c', go to state 238
Parser(B) >> Reduce 205 [addition_c ::= multiplication_c], pop back to state 61.
Parser(B) >> ... then shift 'addition_c', go to state 244
Parser(B) >> Reduce 210 [concatenation ::= concatenation addition_c], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 22.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 22.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 22.
Parser(B) >> ... then shift 'expression', go to state 331
Parser(B) >> Reduce 160 [say ::= TK_SAY expression], pop back to state 8.
Parser(B) >> ... then shift 'say', go to state 365
Parser(B) >> Reduce 60 [keyword_instruction ::= say], pop back to state 8.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_SAY' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_SAY', go to state 22
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY]
Parser(B) >> Input 'TK_STRING' in state 22
Parser(B) >> Shift 'TK_STRING', go to state 111
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY TK_STRING]
Parser(B) >> Input 'TK_S_LT' in state 111
Parser(B) >> Reduce 179 [term ::= TK_STRING], pop back to state 22.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 22.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 22.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Shift 'TK_S_LT', go to state 39
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY comparison TK_S_LT]
Parser(B) >> Input 'TK_STRING' in state 39
Parser(B) >> Shift 'TK_STRING', go to state 111
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY comparison TK_S_LT TK_STRING]
Parser(B) >> Input 'TK_STRING' in state 111
Parser(B) >> Reduce 179 [term ::= TK_STRING], pop back to state 39.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 39.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 39.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 39.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 39.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 39.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 39.
Parser(B) >> ... then shift 'concatenation', go to state 51
Parser(B) >> Shift 'TK_STRING', go to state 111
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY comparison TK_S_LT concatenation TK_STRING]
Parser(B) >> Input 'TK_EOC' in state 111
Parser(B) >> Reduce 179 [term ::= TK_STRING], pop back to state 51.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 51.
Parser(B) >> ... then shift 'bracket', go to state 216
Parser(B) >> Reduce 196 [prefix_expression_c ::= bracket], pop back to state 51.
Parser(B) >> ... then shift 'prefix_expression_c', go to state 214
Parser(B) >> Reduce 198 [power_expression_c ::= prefix_expression_c], pop back to state 51.
Parser(B) >> ... then shift 'power_expression_c', go to state 213
Parser(B) >> Reduce 200 [multiplication_c ::= power_expression_c], pop back to state 51.
Parser(B) >> ... then shift 'multiplication_c', go to state 238
Parser(B) >> Reduce 205 [addition_c ::= multiplication_c], pop back to state 51.
Parser(B) >> ... then shift 'addition_c', go to state 244
Parser(B) >> Reduce 210 [concatenation ::= concatenation addition_c], pop back to state 39.
Parser(B) >> ... then shift 'concatenation', go to state 51
Parser(B) >> Reduce 221 [comparison ::= comparison TK_S_LT concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 22.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 22.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 22.
Parser(B) >> ... then shift 'expression', go to state 331
Parser(B) >> Reduce 160 [say ::= TK_SAY expression], pop back to state 8.
Parser(B) >> ... then shift 'say', go to state 365
Parser(B) >> Reduce 60 [keyword_instruction ::= say], pop back to state 8.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_SAY' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_SAY', go to state 22
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY]
Parser(B) >> Input 'TK_STRING' in state 22
Parser(B) >> Shift 'TK_STRING', go to state 111
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY TK_STRING]
Parser(B) >> Input 'TK_S_GT' in state 111
Parser(B) >> Reduce 179 [term ::= TK_STRING], pop back to state 22.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 22.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 22.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Shift 'TK_S_GT', go to state 40
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY comparison TK_S_GT]
Parser(B) >> Input 'TK_STRING' in state 40
Parser(B) >> Shift 'TK_STRING', go to state 111
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY comparison TK_S_GT TK_STRING]
Parser(B) >> Input 'TK_STRING' in state 111
Parser(B) >> Reduce 179 [term ::= TK_STRING], pop back to state 40.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 40.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 40.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 40.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 40.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 40.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 40.
Parser(B) >> ... then shift 'concatenation', go to state 52
Parser(B) >> Shift 'TK_STRING', go to state 111
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY comparison TK_S_GT concatenation TK_STRING]
Parser(B) >> Input 'TK_EOC' in state 111
Parser(B) >> Reduce 179 [term ::= TK_STRING], pop back to state 52.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 52.
Parser(B) >> ... then shift 'bracket', go to state 216
Parser(B) >> Reduce 196 [prefix_expression_c ::= bracket], pop back to state 52.
Parser(B) >> ... then shift 'prefix_expression_c', go to state 214
Parser(B) >> Reduce 198 [power_expression_c ::= prefix_expression_c], pop back to state 52.
Parser(B) >> ... then shift 'power_expression_c', go to state 213
Parser(B) >> Reduce 200 [multiplication_c ::= power_expression_c], pop back to state 52.
Parser(B) >> ... then shift 'multiplication_c', go to state 238
Parser(B) >> Reduce 205 [addition_c ::= multiplication_c], pop back to state 52.
Parser(B) >> ... then shift 'addition_c', go to state 244
Parser(B) >> Reduce 210 [concatenation ::= concatenation addition_c], pop back to state 40.
Parser(B) >> ... then shift 'concatenation', go to state 52
Parser(B) >> Reduce 220 [comparison ::= comparison TK_S_GT concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 22.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 22.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 22.
Parser(B) >> ... then shift 'expression', go to state 331
Parser(B) >> Reduce 160 [say ::= TK_SAY expression], pop back to state 8.
Parser(B) >> ... then shift 'say', go to state 365
Parser(B) >> Reduce 60 [keyword_instruction ::= say], pop back to state 8.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_SAY' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_SAY', go to state 22
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY]
Parser(B) >> Input 'TK_STRING' in state 22
Parser(B) >> Shift 'TK_STRING', go to state 111
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY TK_STRING]
Parser(B) >> Input 'TK_S_GT' in state 111
Parser(B) >> Reduce 179 [term ::= TK_STRING], pop back to state 22.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 22.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 22.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Shift 'TK_S_GT', go to state 40
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY comparison TK_S_GT]
Parser(B) >> Input 'TK_STRING' in state 40
Parser(B) >> Shift 'TK_STRING', go to state 111
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY comparison TK_S_GT TK_STRING]
Parser(B) >> Input 'TK_STRING' in state 111
Parser(B) >> Reduce 179 [term ::= TK_STRING], pop back to state 40.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 40.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 40.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 40.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 40.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 40.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 40.
Parser(B) >> ... then shift 'concatenation', go to state 52
Parser(B) >> Shift 'TK_STRING', go to state 111
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY comparison TK_S_GT concatenation TK_STRING]
Parser(B) >> Input 'TK_EOC' in state 111
Parser(B) >> Reduce 179 [term ::= TK_STRING], pop back to state 52.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 52.
Parser(B) >> ... then shift 'bracket', go to state 216
Parser(B) >> Reduce 196 [prefix_expression_c ::= bracket], pop back to state 52.
Parser(B) >> ... then shift 'prefix_expression_c', go to state 214
Parser(B) >> Reduce 198 [power_expression_c ::= prefix_expression_c], pop back to state 52.
Parser(B) >> ... then shift 'power_expression_c', go to state 213
Parser(B) >> Reduce 200 [multiplication_c ::= power_expression_c], pop back to state 52.
Parser(B) >> ... then shift 'multiplication_c', go to state 238
Parser(B) >> Reduce 205 [addition_c ::= multiplication_c], pop back to state 52.
Parser(B) >> ... then shift 'addition_c', go to state 244
Parser(B) >> Reduce 210 [concatenation ::= concatenation addition_c], pop back to state 40.
Parser(B) >> ... then shift 'concatenation', go to state 52
Parser(B) >> Reduce 220 [comparison ::= comparison TK_S_GT concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 22.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 22.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 22.
Parser(B) >> ... then shift 'expression', go to state 331
Parser(B) >> Reduce 160 [say ::= TK_SAY expression], pop back to state 8.
Parser(B) >> ... then shift 'say', go to state 365
Parser(B) >> Reduce 60 [keyword_instruction ::= say], pop back to state 8.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_SAY' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_SAY', go to state 22
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY]
Parser(B) >> Input 'TK_STRING' in state 22
Parser(B) >> Shift 'TK_STRING', go to state 111
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY TK_STRING]
Parser(B) >> Input 'TK_S_LT' in state 111
Parser(B) >> Reduce 179 [term ::= TK_STRING], pop back to state 22.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 22.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 22.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Shift 'TK_S_LT', go to state 39
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY comparison TK_S_LT]
Parser(B) >> Input 'TK_STRING' in state 39
Parser(B) >> Shift 'TK_STRING', go to state 111
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY comparison TK_S_LT TK_STRING]
Parser(B) >> Input 'TK_STRING' in state 111
Parser(B) >> Reduce 179 [term ::= TK_STRING], pop back to state 39.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 39.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 39.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 39.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 39.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 39.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 39.
Parser(B) >> ... then shift 'concatenation', go to state 51
Parser(B) >> Shift 'TK_STRING', go to state 111
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY comparison TK_S_LT concatenation TK_STRING]
Parser(B) >> Input 'TK_EOC' in state 111
Parser(B) >> Reduce 179 [term ::= TK_STRING], pop back to state 51.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 51.
Parser(B) >> ... then shift 'bracket', go to state 216
Parser(B) >> Reduce 196 [prefix_expression_c ::= bracket], pop back to state 51.
Parser(B) >> ... then shift 'prefix_expression_c', go to state 214
Parser(B) >> Reduce 198 [power_expression_c ::= prefix_expression_c], pop back to state 51.
Parser(B) >> ... then shift 'power_expression_c', go to state 213
Parser(B) >> Reduce 200 [multiplication_c ::= power_expression_c], pop back to state 51.
Parser(B) >> ... then shift 'multiplication_c', go to state 238
Parser(B) >> Reduce 205 [addition_c ::= multiplication_c], pop back to state 51.
Parser(B) >> ... then shift 'addition_c', go to state 244
Parser(B) >> Reduce 210 [concatenation ::= concatenation addition_c], pop back to state 39.
Parser(B) >> ... then shift 'concatenation', go to state 51
Parser(B) >> Reduce 221 [comparison ::= comparison TK_S_LT concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 22.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 22.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 22.
Parser(B) >> ... then shift 'expression', go to state 331
Parser(B) >> Reduce 160 [say ::= TK_SAY expression], pop back to state 8.
Parser(B) >> ... then shift 'say', go to state 365
Parser(B) >> Reduce 60 [keyword_instruction ::= say], pop back to state 8.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_SAY' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_SAY', go to state 22
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY]
Parser(B) >> Input 'TK_MINUS' in state 22
Parser(B) >> Shift 'TK_MINUS', go to state 76
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY TK_MINUS]
Parser(B) >> Input 'TK_INTEGER' in state 76
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY TK_MINUS TK_INTEGER]
Parser(B) >> Input 'TK_POWER' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 76.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 76.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 76.
Parser(B) >> ... then shift 'prefix_expression', go to state 224
Parser(B) >> Reduce 185 [prefix_expression ::= TK_MINUS prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Shift 'TK_POWER', go to state 75
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY power_expression TK_POWER]
Parser(B) >> Input 'TK_INTEGER' in state 75
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY power_expression TK_POWER TK_INTEGER]
Parser(B) >> Input 'TK_STRING' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 75.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 75.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 75.
Parser(B) >> ... then shift 'prefix_expression', go to state 221
Parser(B) >> Reduce 187 [power_expression ::= power_expression TK_POWER prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Shift 'TK_STRING', go to state 111
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY concatenation TK_STRING]
Parser(B) >> Input 'TK_EOC' in state 111
Parser(B) >> Reduce 179 [term ::= TK_STRING], pop back to state 61.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 61.
Parser(B) >> ... then shift 'bracket', go to state 216
Parser(B) >> Reduce 196 [prefix_expression_c ::= bracket], pop back to state 61.
Parser(B) >> ... then shift 'prefix_expression_c', go to state 214
Parser(B) >> Reduce 198 [power_expression_c ::= prefix_expression_c], pop back to state 61.
Parser(B) >> ... then shift 'power_expression_c', go to state 213
Parser(B) >> Reduce 200 [multiplication_c ::= power_expression_c], pop back to state 61.
Parser(B) >> ... then shift 'multiplication_c', go to state 238
Parser(B) >> Reduce 205 [addition_c ::= multiplication_c], pop back to state 61.
Parser(B) >> ... then shift 'addition_c', go to state 244
Parser(B) >> Reduce 210 [concatenation ::= concatenation addition_c], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 22.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 22.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 22.
Parser(B) >> ... then shift 'expression', go to state 331
Parser(B) >> Reduce 160 [say ::= TK_SAY expression], pop back to state 8.
Parser(B) >> ... then shift 'say', go to state 365
Parser(B) >> Reduce 60 [keyword_instruction ::= say], pop back to state 8.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_SAY' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_SAY', go to state 22
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY]
Parser(B) >> Input 'TK_MINUS' in state 22
Parser(B) >> Shift 'TK_MINUS', go to state 76
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY TK_MINUS]
Parser(B) >> Input 'TK_OPEN_BRACKET' in state 76
Parser(B) >> Shift 'TK_OPEN_BRACKET', go to state 34
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY TK_MINUS TK_OPEN_BRACKET]
Parser(B) >> Input 'TK_INTEGER' in state 34
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY TK_MINUS TK_OPEN_BRACKET TK_INTEGER]
Parser(B) >> Input 'TK_PLUS' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 34.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 34.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 34.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 34.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 34.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 34.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Shift 'TK_PLUS', go to state 64
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY TK_MINUS TK_OPEN_BRACKET addition TK_PLUS]
Parser(B) >> Input 'TK_INTEGER' in state 64
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY TK_MINUS TK_OPEN_BRACKET addition TK_PLUS TK_INTEGER]
Parser(B) >> Input 'TK_CLOSE_BRACKET' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 64.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 64.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 64.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 64.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 64.
Parser(B) >> ... then shift 'multiplication', go to state 240
Parser(B) >> Reduce 194 [addition ::= addition TK_PLUS multiplication], pop back to state 34.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 34.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 34.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 34.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 34.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 34.
Parser(B) >> ... then shift 'expression', go to state 408
Parser(B) >> Shift 'TK_CLOSE_BRACKET', go to state 228
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY TK_MINUS TK_OPEN_BRACKET expression TK_CLOSE_BRACKET]
Parser(B) >> Input 'TK_POWER' in state 228
Parser(B) >> Reduce 181 [bracket ::= TK_OPEN_BRACKET expression TK_CLOSE_BRACKET], pop back to state 76.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 76.
Parser(B) >> ... then shift 'prefix_expression', go to state 224
Parser(B) >> Reduce 185 [prefix_expression ::= TK_MINUS prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Shift 'TK_POWER', go to state 75
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY power_expression TK_POWER]
Parser(B) >> Input 'TK_INTEGER' in state 75
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY power_expression TK_POWER TK_INTEGER]
Parser(B) >> Input 'TK_STRING' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 75.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 75.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 75.
Parser(B) >> ... then shift 'prefix_expression', go to state 221
Parser(B) >> Reduce 187 [power_expression ::= power_expression TK_POWER prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Shift 'TK_STRING', go to state 111
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY concatenation TK_STRING]
Parser(B) >> Input 'TK_EOC' in state 111
Parser(B) >> Reduce 179 [term ::= TK_STRING], pop back to state 61.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 61.
Parser(B) >> ... then shift 'bracket', go to state 216
Parser(B) >> Reduce 196 [prefix_expression_c ::= bracket], pop back to state 61.
Parser(B) >> ... then shift 'prefix_expression_c', go to state 214
Parser(B) >> Reduce 198 [power_expression_c ::= prefix_expression_c], pop back to state 61.
Parser(B) >> ... then shift 'power_expression_c', go to state 213
Parser(B) >> Reduce 200 [multiplication_c ::= power_expression_c], pop back to state 61.
Parser(B) >> ... then shift 'multiplication_c', go to state 238
Parser(B) >> Reduce 205 [addition_c ::= multiplication_c], pop back to state 61.
Parser(B) >> ... then shift 'addition_c', go to state 244
Parser(B) >> Reduce 210 [concatenation ::= concatenation addition_c], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 22.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 22.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 22.
Parser(B) >> ... then shift 'expression', go to state 331
Parser(B) >> Reduce 160 [say ::= TK_SAY expression], pop back to state 8.
Parser(B) >> ... then shift 'say', go to state 365
Parser(B) >> Reduce 60 [keyword_instruction ::= say], pop back to state 8.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_SAY' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_SAY', go to state 22
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY]
Parser(B) >> Input 'TK_INTEGER' in state 22
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY TK_INTEGER]
Parser(B) >> Input 'TK_POWER' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 22.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 22.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 22.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Shift 'TK_POWER', go to state 75
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY power_expression TK_POWER]
Parser(B) >> Input 'TK_INTEGER' in state 75
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY power_expression TK_POWER TK_INTEGER]
Parser(B) >> Input 'TK_POWER' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 75.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 75.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 75.
Parser(B) >> ... then shift 'prefix_expression', go to state 221
Parser(B) >> Reduce 187 [power_expression ::= power_expression TK_POWER prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Shift 'TK_POWER', go to state 75
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY power_expression TK_POWER]
Parser(B) >> Input 'TK_INTEGER' in state 75
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY power_expression TK_POWER TK_INTEGER]
Parser(B) >> Input 'TK_STRING' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 75.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 75.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 75.
Parser(B) >> ... then shift 'prefix_expression', go to state 221
Parser(B) >> Reduce 187 [power_expression ::= power_expression TK_POWER prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Shift 'TK_STRING', go to state 111
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY concatenation TK_STRING]
Parser(B) >> Input 'TK_EOC' in state 111
Parser(B) >> Reduce 179 [term ::= TK_STRING], pop back to state 61.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 61.
Parser(B) >> ... then shift 'bracket', go to state 216
Parser(B) >> Reduce 196 [prefix_expression_c ::= bracket], pop back to state 61.
Parser(B) >> ... then shift 'prefix_expression_c', go to state 214
Parser(B) >> Reduce 198 [power_expression_c ::= prefix_expression_c], pop back to state 61.
Parser(B) >> ... then shift 'power_expression_c', go to state 213
Parser(B) >> Reduce 200 [multiplication_c ::= power_expression_c], pop back to state 61.
Parser(B) >> ... then shift 'multiplication_c', go to state 238
Parser(B) >> Reduce 205 [addition_c ::= multiplication_c], pop back to state 61.
Parser(B) >> ... then shift 'addition_c', go to state 244
Parser(B) >> Reduce 210 [concatenation ::= concatenation addition_c], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 22.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 22.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 22.
Parser(B) >> ... then shift 'expression', go to state 331
Parser(B) >> Reduce 160 [say ::= TK_SAY expression], pop back to state 8.
Parser(B) >> ... then shift 'say', go to state 365
Parser(B) >> Reduce 60 [keyword_instruction ::= say], pop back to state 8.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_EOS' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_EOS', go to state 388
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_EOS]
Parser(B) >> Input '$' in state 388
Parser(B) >> Reduce 1 [program ::= rexx_options instruction_list TK_EOS], pop back to state 0.
Parser(B) >> ... then shift 'program', pending reduce -2
Parser(B) >> Accept!
Options parser >> Input 'TK_OPTIONS' in state 0
Options parser >> Shift 'TK_OPTIONS', go to state 1
Options parser >> Return. Stack=[TK_OPTIONS]
Options parser >> Input 'TK_LEVELB' in state 1
Options parser >> Shift 'TK_LEVELB', go to state 16
Options parser >> Return. Stack=[TK_OPTIONS TK_LEVELB]
Options parser >> Input 'TK_EOC' in state 16
Options parser >> Reduce 4 [option ::= TK_LEVELB], pop back to state 1.
Options parser >> ... then shift 'option', go to state 4
Options parser >> Reduce 18 [option_list ::= option] without external action, pop back to state 1.
Options parser >> ... then shift 'option_list', go to state 2
Options parser >> Shift 'TK_EOC', go to state 23
Options parser >> Return. Stack=[TK_OPTIONS option_list TK_EOC]
Options parser >> Input 'TK_SYMBOL' in state 23
Options parser >> WILDCARD TK_SYMBOL => ANYTHING
Options parser >> Reduce 2 [rexx_options ::= TK_OPTIONS option_list TK_EOC], pop back to state 0.
Options parser >> ... then shift 'rexx_options', go to state 3
Options parser >> WILDCARD TK_SYMBOL => ANYTHING
Options parser >> Shift 'TK_SYMBOL', go to state 20
Options parser >> Return. Stack=[rexx_options TK_SYMBOL]
Options parser >> Popping TK_SYMBOL
Options parser >> Popping rexx_options
Parser(B) >> Stack grows from 0 to 100 entries.
Parser(B) >> Input 'TK_OPTIONS' in state 0
Parser(B) >> Shift 'TK_OPTIONS', go to state 81
Parser(B) >> Return. Stack=[TK_OPTIONS]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 81
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 301
Parser(B) >> Return. Stack=[TK_OPTIONS TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EOC' in state 301
Parser(B) >> Reduce 18 [option ::= TK_VAR_SYMBOL], pop back to state 81.
Parser(B) >> ... then shift 'option', go to state 300
Parser(B) >> Reduce 16 [option_list ::= option], pop back to state 81.
Parser(B) >> ... then shift 'option_list', go to state 90
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 130
Parser(B) >> Shift 'TK_EOC', go to state 195
Parser(B) >> Return. Stack=[TK_OPTIONS option_list junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 195
Parser(B) >> Reduce 15 [rexx_options ::= TK_OPTIONS option_list junk TK_EOC], pop back to state 0.
Parser(B) >> ... then shift 'rexx_options', go to state 1
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 1.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_INTEGER' in state 33
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options var_symbol TK_EQUAL TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 1.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 1.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 1.
Parser(B) >> ... then shift 'labeled_instruction', go to state 184
Parser(B) >> Reduce 33 [instruction_list ::= labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 8.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_FLOAT' in state 33
Parser(B) >> Shift 'TK_FLOAT', go to state 231
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL TK_FLOAT]
Parser(B) >> Input 'TK_EOC' in state 231
Parser(B) >> Reduce 177 [term ::= TK_FLOAT], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 8.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 8.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_MINUS' in state 33
Parser(B) >> Shift 'TK_MINUS', go to state 76
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL TK_MINUS]
Parser(B) >> Input 'TK_FLOAT' in state 76
Parser(B) >> Shift 'TK_FLOAT', go to state 231
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL TK_MINUS TK_FLOAT]
Parser(B) >> Input 'TK_EOC' in state 231
Parser(B) >> Reduce 177 [term ::= TK_FLOAT], pop back to state 76.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 76.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 76.
Parser(B) >> ... then shift 'prefix_expression', go to state 224
Parser(B) >> Reduce 185 [prefix_expression ::= TK_MINUS prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 8.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_DO' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_DO', go to state 113
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_DO]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 113
Parser(B) >> Reduce 80 [tk_doloop ::= TK_DO], pop back to state 8.
Parser(B) >> ... then shift 'tk_doloop', go to state 17
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 17.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_INTEGER' in state 33
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop var_symbol TK_EQUAL TK_INTEGER]
Parser(B) >> Input 'TK_TO' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 17.
Parser(B) >> ... then shift 'assignment', go to state 86
Parser(B) >> Shift 'TK_TO', go to state 27
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop assignment TK_TO]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 27
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop assignment TK_TO TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EOC' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 27.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 27.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 27.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 27.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 27.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 27.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 27.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 27.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 27.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 27.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 27.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 27.
Parser(B) >> ... then shift 'expression', go to state 286
Parser(B) >> Reduce 101 [dorep_item ::= TK_TO expression], pop back to state 86.
Parser(B) >> ... then shift 'dorep_item', go to state 283
Parser(B) >> Reduce 99 [dorep_list ::= dorep_item], pop back to state 86.
Parser(B) >> ... then shift 'dorep_list', go to state 114
Parser(B) >> Reduce 98 [dorep ::= assignment dorep_list], pop back to state 17.
Parser(B) >> ... then shift 'dorep', go to state 96
Parser(B) >> Shift 'TK_EOC', go to state 3
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 3
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_EOC TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 3.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_EOC var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_FLOAT' in state 33
Parser(B) >> Shift 'TK_FLOAT', go to state 231
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_EOC var_symbol TK_EQUAL TK_FLOAT]
Parser(B) >> Input 'TK_MINUS' in state 231
Parser(B) >> Reduce 177 [term ::= TK_FLOAT], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Shift 'TK_MINUS', go to state 63
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_EOC var_symbol TK_EQUAL addition TK_MINUS]
Parser(B) >> Input 'TK_FLOAT' in state 63
Parser(B) >> Shift 'TK_FLOAT', go to state 231
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_EOC var_symbol TK_EQUAL addition TK_MINUS TK_FLOAT]
Parser(B) >> Input 'TK_DIV' in state 231
Parser(B) >> Reduce 177 [term ::= TK_FLOAT], pop back to state 63.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 63.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 63.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 63.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 63.
Parser(B) >> ... then shift 'multiplication', go to state 239
Parser(B) >> Shift 'TK_DIV', go to state 69
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_EOC var_symbol TK_EQUAL addition TK_MINUS multiplication TK_DIV]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 69
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_EOC var_symbol TK_EQUAL addition TK_MINUS multiplication TK_DIV TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_PLUS' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 69.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 69.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 69.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 69.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 69.
Parser(B) >> ... then shift 'power_expression', go to state 219
Parser(B) >> Reduce 190 [multiplication ::= multiplication TK_DIV power_expression], pop back to state 63.
Parser(B) >> ... then shift 'multiplication', go to state 239
Parser(B) >> Reduce 195 [addition ::= addition TK_MINUS multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Shift 'TK_PLUS', go to state 64
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_EOC var_symbol TK_EQUAL addition TK_PLUS]
Parser(B) >> Input 'TK_FLOAT' in state 64
Parser(B) >> Shift 'TK_FLOAT', go to state 231
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_EOC var_symbol TK_EQUAL addition TK_PLUS TK_FLOAT]
Parser(B) >> Input 'TK_DIV' in state 231
Parser(B) >> Reduce 177 [term ::= TK_FLOAT], pop back to state 64.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 64.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 64.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 64.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 64.
Parser(B) >> ... then shift 'multiplication', go to state 240
Parser(B) >> Shift 'TK_DIV', go to state 69
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_EOC var_symbol TK_EQUAL addition TK_PLUS multiplication TK_DIV]
Parser(B) >> Input 'TK_OPEN_BRACKET' in state 69
Parser(B) >> Shift 'TK_OPEN_BRACKET', go to state 34
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_EOC var_symbol TK_EQUAL addition TK_PLUS multiplication TK_DIV TK_OPEN_BRACKET]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 34
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_EOC var_symbol TK_EQUAL addition TK_PLUS multiplication TK_DIV TK_OPEN_BRACKET TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_MULT' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 34.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 34.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 34.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 34.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 34.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 34.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Shift 'TK_MULT', go to state 70
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_EOC var_symbol TK_EQUAL addition TK_PLUS multiplication TK_DIV TK_OPEN_BRACKET multiplication TK_MULT]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 70
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_EOC var_symbol TK_EQUAL addition TK_PLUS multiplication TK_DIV TK_OPEN_BRACKET multiplication TK_MULT TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_CLOSE_BRACKET' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 70.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 70.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 70.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 70.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 70.
Parser(B) >> ... then shift 'power_expression', go to state 220
Parser(B) >> Reduce 189 [multiplication ::= multiplication TK_MULT power_expression], pop back to state 34.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 34.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 34.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 34.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 34.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 34.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 34.
Parser(B) >> ... then shift 'expression', go to state 408
Parser(B) >> Shift 'TK_CLOSE_BRACKET', go to state 228
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_EOC var_symbol TK_EQUAL addition TK_PLUS multiplication TK_DIV TK_OPEN_BRACKET expression TK_CLOSE_BRACKET]
Parser(B) >> Input 'TK_EOC' in state 228
Parser(B) >> Reduce 181 [bracket ::= TK_OPEN_BRACKET expression TK_CLOSE_BRACKET], pop back to state 69.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 69.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 69.
Parser(B) >> ... then shift 'power_expression', go to state 219
Parser(B) >> Reduce 190 [multiplication ::= multiplication TK_DIV power_expression], pop back to state 64.
Parser(B) >> ... then shift 'multiplication', go to state 240
Parser(B) >> Reduce 194 [addition ::= addition TK_PLUS multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 3.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 3.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_EOC single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 3.
Parser(B) >> ... then shift 'labeled_instruction', go to state 184
Parser(B) >> Reduce 33 [instruction_list ::= labeled_instruction], pop back to state 3.
Parser(B) >> ... then shift 'instruction_list', go to state 9
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_EOC instruction_list TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 9.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_EOC instruction_list var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 33
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_EOC instruction_list var_symbol TK_EQUAL TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EOC' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 33.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 9.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 9.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_EOC instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 9.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 3.
Parser(B) >> ... then shift 'instruction_list', go to state 9
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_EOC instruction_list TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 9.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_EOC instruction_list var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 33
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_EOC instruction_list var_symbol TK_EQUAL TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EOC' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 33.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 9.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 9.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_EOC instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_END' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 9.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 3.
Parser(B) >> ... then shift 'instruction_list', go to state 9
Parser(B) >> Shift 'TK_END', go to state 128
Parser(B) >> Return. Stack=[rexx_options instruction_list tk_doloop dorep TK_EOC instruction_list TK_END]
Parser(B) >> Input 'TK_EOC' in state 128
Parser(B) >> Reduce 82 [do ::= tk_doloop dorep TK_EOC instruction_list TK_END], pop back to state 8.
Parser(B) >> ... then shift 'do', go to state 101
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 405
Parser(B) >> Shift 'TK_EOC', go to state 186
Parser(B) >> Return. Stack=[rexx_options instruction_list do junk TK_EOC]
Parser(B) >> Input 'TK_SAY' in state 186
Parser(B) >> Reduce 71 [group ::= do junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'group', go to state 193
Parser(B) >> Reduce 35 [labeled_instruction ::= group], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_SAY', go to state 22
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 22
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EOC' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 22.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 22.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 22.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 22.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 22.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 22.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 22.
Parser(B) >> ... then shift 'expression', go to state 331
Parser(B) >> Reduce 160 [say ::= TK_SAY expression], pop back to state 8.
Parser(B) >> ... then shift 'say', go to state 365
Parser(B) >> Reduce 60 [keyword_instruction ::= say], pop back to state 8.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_EOS' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_EOS', go to state 388
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_EOS]
Parser(B) >> Input '$' in state 388
Parser(B) >> Reduce 1 [program ::= rexx_options instruction_list TK_EOS], pop back to state 0.
Parser(B) >> ... then shift 'program', pending reduce -2
Parser(B) >> Accept!
Options parser >> Input 'TK_OPTIONS' in state 0
Options parser >> Shift 'TK_OPTIONS', go to state 1
Options parser >> Return. Stack=[TK_OPTIONS]
Options parser >> Input 'TK_LEVELB' in state 1
Options parser >> Shift 'TK_LEVELB', go to state 16
Options parser >> Return. Stack=[TK_OPTIONS TK_LEVELB]
Options parser >> Input 'TK_EOC' in state 16
Options parser >> Reduce 4 [option ::= TK_LEVELB], pop back to state 1.
Options parser >> ... then shift 'option', go to state 4
Options parser >> Reduce 18 [option_list ::= option] without external action, pop back to state 1.
Options parser >> ... then shift 'option_list', go to state 2
Options parser >> Shift 'TK_EOC', go to state 23
Options parser >> Return. Stack=[TK_OPTIONS option_list TK_EOC]
Options parser >> Input 'TK_SYMBOL' in state 23
Options parser >> WILDCARD TK_SYMBOL => ANYTHING
Options parser >> Reduce 2 [rexx_options ::= TK_OPTIONS option_list TK_EOC], pop back to state 0.
Options parser >> ... then shift 'rexx_options', go to state 3
Options parser >> WILDCARD TK_SYMBOL => ANYTHING
Options parser >> Shift 'TK_SYMBOL', go to state 20
Options parser >> Return. Stack=[rexx_options TK_SYMBOL]
Options parser >> Popping TK_SYMBOL
Options parser >> Popping rexx_options
Parser(B) >> Stack grows from 0 to 100 entries.
Parser(B) >> Input 'TK_OPTIONS' in state 0
Parser(B) >> Shift 'TK_OPTIONS', go to state 81
Parser(B) >> Return. Stack=[TK_OPTIONS]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 81
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 301
Parser(B) >> Return. Stack=[TK_OPTIONS TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EOC' in state 301
Parser(B) >> Reduce 18 [option ::= TK_VAR_SYMBOL], pop back to state 81.
Parser(B) >> ... then shift 'option', go to state 300
Parser(B) >> Reduce 16 [option_list ::= option], pop back to state 81.
Parser(B) >> ... then shift 'option_list', go to state 90
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 130
Parser(B) >> Shift 'TK_EOC', go to state 195
Parser(B) >> Return. Stack=[TK_OPTIONS option_list junk TK_EOC]
Parser(B) >> Input 'TK_DO' in state 195
Parser(B) >> Reduce 15 [rexx_options ::= TK_OPTIONS option_list junk TK_EOC], pop back to state 0.
Parser(B) >> ... then shift 'rexx_options', go to state 1
Parser(B) >> Shift 'TK_DO', go to state 113
Parser(B) >> Return. Stack=[rexx_options TK_DO]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 113
Parser(B) >> Reduce 80 [tk_doloop ::= TK_DO], pop back to state 1.
Parser(B) >> ... then shift 'tk_doloop', go to state 17
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options tk_doloop TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 17.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options tk_doloop var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_INTEGER' in state 33
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options tk_doloop var_symbol TK_EQUAL TK_INTEGER]
Parser(B) >> Input 'TK_TO' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 17.
Parser(B) >> ... then shift 'assignment', go to state 86
Parser(B) >> Shift 'TK_TO', go to state 27
Parser(B) >> Return. Stack=[rexx_options tk_doloop assignment TK_TO]
Parser(B) >> Input 'TK_INTEGER' in state 27
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options tk_doloop assignment TK_TO TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 27.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 27.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 27.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 27.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 27.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 27.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 27.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 27.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 27.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 27.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 27.
Parser(B) >> ... then shift 'expression', go to state 286
Parser(B) >> Reduce 101 [dorep_item ::= TK_TO expression], pop back to state 86.
Parser(B) >> ... then shift 'dorep_item', go to state 283
Parser(B) >> Reduce 99 [dorep_list ::= dorep_item], pop back to state 86.
Parser(B) >> ... then shift 'dorep_list', go to state 114
Parser(B) >> Reduce 98 [dorep ::= assignment dorep_list], pop back to state 17.
Parser(B) >> ... then shift 'dorep', go to state 96
Parser(B) >> Shift 'TK_EOC', go to state 3
Parser(B) >> Return. Stack=[rexx_options tk_doloop dorep TK_EOC]
Parser(B) >> Input 'TK_CALL' in state 3
Parser(B) >> Shift 'TK_CALL', go to state 116
Parser(B) >> Return. Stack=[rexx_options tk_doloop dorep TK_EOC TK_CALL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 116
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 248
Parser(B) >> Return. Stack=[rexx_options tk_doloop dorep TK_EOC TK_CALL TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EOC' in state 248
Parser(B) >> Reduce 163 [function_name ::= TK_VAR_SYMBOL], pop back to state 116.
Parser(B) >> ... then shift 'function_name', go to state 18
Parser(B) >> Reduce 168 [expression_list ::=].
Parser(B) >> ... then shift 'expression_list', go to state 304
Parser(B) >> Reduce 166 [call ::= TK_CALL function_name expression_list], pop back to state 3.
Parser(B) >> ... then shift 'call', go to state 371
Parser(B) >> Reduce 54 [keyword_instruction ::= call], pop back to state 3.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 3.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options tk_doloop dorep TK_EOC single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_END' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 3.
Parser(B) >> ... then shift 'labeled_instruction', go to state 184
Parser(B) >> Reduce 33 [instruction_list ::= labeled_instruction], pop back to state 3.
Parser(B) >> ... then shift 'instruction_list', go to state 9
Parser(B) >> Shift 'TK_END', go to state 128
Parser(B) >> Return. Stack=[rexx_options tk_doloop dorep TK_EOC instruction_list TK_END]
Parser(B) >> Input 'TK_EOC' in state 128
Parser(B) >> Reduce 82 [do ::= tk_doloop dorep TK_EOC instruction_list TK_END], pop back to state 1.
Parser(B) >> ... then shift 'do', go to state 101
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 405
Parser(B) >> Shift 'TK_EOC', go to state 186
Parser(B) >> Return. Stack=[rexx_options do junk TK_EOC]
Parser(B) >> Input 'TK_RETURN' in state 186
Parser(B) >> Reduce 71 [group ::= do junk TK_EOC], pop back to state 1.
Parser(B) >> ... then shift 'group', go to state 193
Parser(B) >> Reduce 35 [labeled_instruction ::= group], pop back to state 1.
Parser(B) >> ... then shift 'labeled_instruction', go to state 184
Parser(B) >> Reduce 33 [instruction_list ::= labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_RETURN', go to state 23
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_RETURN]
Parser(B) >> Input 'TK_INTEGER' in state 23
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_RETURN TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 23.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 23.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 23.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 23.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 23.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 23.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 23.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 23.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 23.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 23.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 23.
Parser(B) >> ... then shift 'expression', go to state 332
Parser(B) >> Reduce 158 [return ::= TK_RETURN expression], pop back to state 8.
Parser(B) >> ... then shift 'return', go to state 366
Parser(B) >> Reduce 59 [keyword_instruction ::= return], pop back to state 8.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_LABEL' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_LABEL', go to state 173
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_LABEL]
Parser(B) >> Input 'TK_PROCEDURE' in state 173
Parser(B) >> Shift 'TK_PROCEDURE', go to state 319
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_LABEL TK_PROCEDURE]
Parser(B) >> Input 'TK_EOC' in state 319
Parser(B) >> Reduce 118 [procedure ::= TK_LABEL TK_PROCEDURE], pop back to state 8.
Parser(B) >> ... then shift 'procedure', go to state 367
Parser(B) >> Reduce 58 [keyword_instruction ::= procedure], pop back to state 8.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_SAY' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_SAY', go to state 22
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY]
Parser(B) >> Input 'TK_STRING' in state 22
Parser(B) >> Shift 'TK_STRING', go to state 111
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY TK_STRING]
Parser(B) >> Input 'TK_EOC' in state 111
Parser(B) >> Reduce 179 [term ::= TK_STRING], pop back to state 22.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 22.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 22.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 22.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 22.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 22.
Parser(B) >> ... then shift 'expression', go to state 331
Parser(B) >> Reduce 160 [say ::= TK_SAY expression], pop back to state 8.
Parser(B) >> ... then shift 'say', go to state 365
Parser(B) >> Reduce 60 [keyword_instruction ::= say], pop back to state 8.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_RETURN' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_RETURN', go to state 23
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_RETURN]
Parser(B) >> Input 'TK_EOC' in state 23
Parser(B) >> Reduce 159 [return ::= TK_RETURN], pop back to state 8.
Parser(B) >> ... then shift 'return', go to state 366
Parser(B) >> Reduce 59 [keyword_instruction ::= return], pop back to state 8.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_EOS' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_EOS', go to state 388
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_EOS]
Parser(B) >> Input '$' in state 388
Parser(B) >> Reduce 1 [program ::= rexx_options instruction_list TK_EOS], pop back to state 0.
Parser(B) >> ... then shift 'program', pending reduce -2
Parser(B) >> Accept!
Options parser >> Input 'TK_OPTIONS' in state 0
Options parser >> Shift 'TK_OPTIONS', go to state 1
Options parser >> Return. Stack=[TK_OPTIONS]
Options parser >> Input 'TK_LEVELB' in state 1
Options parser >> Shift 'TK_LEVELB', go to state 16
Options parser >> Return. Stack=[TK_OPTIONS TK_LEVELB]
Options parser >> Input 'TK_EOC' in state 16
Options parser >> Reduce 4 [option ::= TK_LEVELB], pop back to state 1.
Options parser >> ... then shift 'option', go to state 4
Options parser >> Reduce 18 [option_list ::= option] without external action, pop back to state 1.
Options parser >> ... then shift 'option_list', go to state 2
Options parser >> Shift 'TK_EOC', go to state 23
Options parser >> Return. Stack=[TK_OPTIONS option_list TK_EOC]
Options parser >> Input 'TK_SYMBOL' in state 23
Options parser >> WILDCARD TK_SYMBOL => ANYTHING
Options parser >> Reduce 2 [rexx_options ::= TK_OPTIONS option_list TK_EOC], pop back to state 0.
Options parser >> ... then shift 'rexx_options', go to state 3
Options parser >> WILDCARD TK_SYMBOL => ANYTHING
Options parser >> Shift 'TK_SYMBOL', go to state 20
Options parser >> Return. Stack=[rexx_options TK_SYMBOL]
Options parser >> Popping TK_SYMBOL
Options parser >> Popping rexx_options
Parser(B) >> Stack grows from 0 to 100 entries.
Parser(B) >> Input 'TK_OPTIONS' in state 0
Parser(B) >> Shift 'TK_OPTIONS', go to state 81
Parser(B) >> Return. Stack=[TK_OPTIONS]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 81
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 301
Parser(B) >> Return. Stack=[TK_OPTIONS TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EOC' in state 301
Parser(B) >> Reduce 18 [option ::= TK_VAR_SYMBOL], pop back to state 81.
Parser(B) >> ... then shift 'option', go to state 300
Parser(B) >> Reduce 16 [option_list ::= option], pop back to state 81.
Parser(B) >> ... then shift 'option_list', go to state 90
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 130
Parser(B) >> Shift 'TK_EOC', go to state 195
Parser(B) >> Return. Stack=[TK_OPTIONS option_list junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 195
Parser(B) >> Reduce 15 [rexx_options ::= TK_OPTIONS option_list junk TK_EOC], pop back to state 0.
Parser(B) >> ... then shift 'rexx_options', go to state 1
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 1.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_INTEGER' in state 33
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options var_symbol TK_EQUAL TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 1.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 1.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 1.
Parser(B) >> ... then shift 'labeled_instruction', go to state 184
Parser(B) >> Reduce 33 [instruction_list ::= labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 8.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_INTEGER' in state 33
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 8.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 8.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_INTEGER' in state 33
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 8.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_SAY' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_SAY', go to state 22
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY]
Parser(B) >> Input 'TK_STRING' in state 22
Parser(B) >> Shift 'TK_STRING', go to state 111
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY TK_STRING]
Parser(B) >> Input 'TK_EOC' in state 111
Parser(B) >> Reduce 179 [term ::= TK_STRING], pop back to state 22.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 22.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 22.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 22.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 22.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 22.
Parser(B) >> ... then shift 'expression', go to state 331
Parser(B) >> Reduce 160 [say ::= TK_SAY expression], pop back to state 8.
Parser(B) >> ... then shift 'say', go to state 365
Parser(B) >> Reduce 60 [keyword_instruction ::= say], pop back to state 8.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_ASSEMBLER' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_ASSEMBLER', go to state 95
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_ASSEMBLER]
Parser(B) >> Input 'TK_DO' in state 95
Parser(B) >> Shift 'TK_DO', go to state 341
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_ASSEMBLER TK_DO]
Parser(B) >> Input 'TK_EOC' in state 341
Parser(B) >> Shift 'TK_EOC', go to state 84
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_ASSEMBLER TK_DO TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 84
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 289
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_ASSEMBLER TK_DO TK_EOC TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 289
Parser(B) >> Reduce 148 [assembler_op ::= TK_VAR_SYMBOL], pop back to state 84.
Parser(B) >> ... then shift 'assembler_op', go to state 87
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 297
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_ASSEMBLER TK_DO TK_EOC assembler_op TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_COMMA' in state 297
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 87.
Parser(B) >> ... then shift 'var_symbol', go to state 308
Parser(B) >> Reduce 150 [assembler_arg ::= var_symbol], pop back to state 87.
Parser(B) >> ... then shift 'assembler_arg', go to state 310
Parser(B) >> Shift 'TK_COMMA', go to state 94
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_ASSEMBLER TK_DO TK_EOC assembler_op assembler_arg TK_COMMA]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 94
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 297
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_ASSEMBLER TK_DO TK_EOC assembler_op assembler_arg TK_COMMA TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_COMMA' in state 297
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 94.
Parser(B) >> ... then shift 'var_symbol', go to state 308
Parser(B) >> Reduce 150 [assembler_arg ::= var_symbol], pop back to state 94.
Parser(B) >> ... then shift 'assembler_arg', go to state 309
Parser(B) >> Shift 'TK_COMMA', go to state 93
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_ASSEMBLER TK_DO TK_EOC assembler_op assembler_arg TK_COMMA assembler_arg TK_COMMA]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 93
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 297
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_ASSEMBLER TK_DO TK_EOC assembler_op assembler_arg TK_COMMA assembler_arg TK_COMMA TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EOC' in state 297
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 93.
Parser(B) >> ... then shift 'var_symbol', go to state 308
Parser(B) >> Reduce 150 [assembler_arg ::= var_symbol], pop back to state 93.
Parser(B) >> ... then shift 'assembler_arg', go to state 345
Parser(B) >> Reduce 147 [assembler_instruction ::= assembler_op assembler_arg TK_COMMA assembler_arg TK_COMMA assembler_arg], pop back to state 84.
Parser(B) >> ... then shift 'assembler_instruction', go to state 399
Parser(B) >> Shift 'TK_EOC', go to state 295
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_ASSEMBLER TK_DO TK_EOC assembler_instruction TK_EOC]
Parser(B) >> Input 'TK_END' in state 295
Parser(B) >> Reduce 142 [assembler_list ::= assembler_instruction TK_EOC], pop back to state 84.
Parser(B) >> ... then shift 'assembler_list', go to state 88
Parser(B) >> Shift 'TK_END', go to state 340
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_ASSEMBLER TK_DO TK_EOC assembler_list TK_END]
Parser(B) >> Input 'TK_EOC' in state 340
Parser(B) >> Reduce 130 [assembler ::= TK_ASSEMBLER TK_DO TK_EOC assembler_list TK_END], pop back to state 8.
Parser(B) >> ... then shift 'assembler', go to state 373
Parser(B) >> Reduce 52 [keyword_instruction ::= assembler], pop back to state 8.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_SAY' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_SAY', go to state 22
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY]
Parser(B) >> Input 'TK_STRING' in state 22
Parser(B) >> Shift 'TK_STRING', go to state 111
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY TK_STRING]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 111
Parser(B) >> Reduce 179 [term ::= TK_STRING], pop back to state 22.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 22.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 22.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY concatenation TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EOC' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 61.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 61.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 61.
Parser(B) >> ... then shift 'bracket', go to state 216
Parser(B) >> Reduce 196 [prefix_expression_c ::= bracket], pop back to state 61.
Parser(B) >> ... then shift 'prefix_expression_c', go to state 214
Parser(B) >> Reduce 198 [power_expression_c ::= prefix_expression_c], pop back to state 61.
Parser(B) >> ... then shift 'power_expression_c', go to state 213
Parser(B) >> Reduce 200 [multiplication_c ::= power_expression_c], pop back to state 61.
Parser(B) >> ... then shift 'multiplication_c', go to state 238
Parser(B) >> Reduce 205 [addition_c ::= multiplication_c], pop back to state 61.
Parser(B) >> ... then shift 'addition_c', go to state 244
Parser(B) >> Reduce 210 [concatenation ::= concatenation addition_c], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 22.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 22.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 22.
Parser(B) >> ... then shift 'expression', go to state 331
Parser(B) >> Reduce 160 [say ::= TK_SAY expression], pop back to state 8.
Parser(B) >> ... then shift 'say', go to state 365
Parser(B) >> Reduce 60 [keyword_instruction ::= say], pop back to state 8.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_EOS' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_EOS', go to state 388
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_EOS]
Parser(B) >> Input '$' in state 388
Parser(B) >> Reduce 1 [program ::= rexx_options instruction_list TK_EOS], pop back to state 0.
Parser(B) >> ... then shift 'program', pending reduce -2
Parser(B) >> Accept!
Options parser >> Input 'TK_OPTIONS' in state 0
Options parser >> Shift 'TK_OPTIONS', go to state 1
Options parser >> Return. Stack=[TK_OPTIONS]
Options parser >> Input 'TK_LEVELB' in state 1
Options parser >> Shift 'TK_LEVELB', go to state 16
Options parser >> Return. Stack=[TK_OPTIONS TK_LEVELB]
Options parser >> Input 'TK_EOC' in state 16
Options parser >> Reduce 4 [option ::= TK_LEVELB], pop back to state 1.
Options parser >> ... then shift 'option', go to state 4
Options parser >> Reduce 18 [option_list ::= option] without external action, pop back to state 1.
Options parser >> ... then shift 'option_list', go to state 2
Options parser >> Shift 'TK_EOC', go to state 23
Options parser >> Return. Stack=[TK_OPTIONS option_list TK_EOC]
Options parser >> Input 'TK_SYMBOL' in state 23
Options parser >> WILDCARD TK_SYMBOL => ANYTHING
Options parser >> Reduce 2 [rexx_options ::= TK_OPTIONS option_list TK_EOC], pop back to state 0.
Options parser >> ... then shift 'rexx_options', go to state 3
Options parser >> WILDCARD TK_SYMBOL => ANYTHING
Options parser >> Shift 'TK_SYMBOL', go to state 20
Options parser >> Return. Stack=[rexx_options TK_SYMBOL]
Options parser >> Popping TK_SYMBOL
Options parser >> Popping rexx_options
Parser(B) >> Stack grows from 0 to 100 entries.
Parser(B) >> Input 'TK_OPTIONS' in state 0
Parser(B) >> Shift 'TK_OPTIONS', go to state 81
Parser(B) >> Return. Stack=[TK_OPTIONS]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 81
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 301
Parser(B) >> Return. Stack=[TK_OPTIONS TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EOC' in state 301
Parser(B) >> Reduce 18 [option ::= TK_VAR_SYMBOL], pop back to state 81.
Parser(B) >> ... then shift 'option', go to state 300
Parser(B) >> Reduce 16 [option_list ::= option], pop back to state 81.
Parser(B) >> ... then shift 'option_list', go to state 90
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 130
Parser(B) >> Shift 'TK_EOC', go to state 195
Parser(B) >> Return. Stack=[TK_OPTIONS option_list junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 195
Parser(B) >> Reduce 15 [rexx_options ::= TK_OPTIONS option_list junk TK_EOC], pop back to state 0.
Parser(B) >> ... then shift 'rexx_options', go to state 1
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 1.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_INTEGER' in state 33
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options var_symbol TK_EQUAL TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 1.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 1.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 1.
Parser(B) >> ... then shift 'labeled_instruction', go to state 184
Parser(B) >> Reduce 33 [instruction_list ::= labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 8.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_INTEGER' in state 33
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 8.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 8.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_INTEGER' in state 33
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 8.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_IF' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_IF', go to state 30
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 30
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_OPEN_BRACKET' in state 112
Parser(B) >> Shift 'TK_OPEN_BRACKET', go to state 21
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL TK_OPEN_BRACKET]
Parser(B) >> Input 'TK_COMMA' in state 21
Parser(B) >> Reduce 168 [expression_list ::=].
Parser(B) >> ... then shift 'expression_list', go to state 383
Parser(B) >> Shift 'TK_COMMA', go to state 24
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL TK_OPEN_BRACKET expression_list TK_COMMA]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 24
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL TK_OPEN_BRACKET expression_list TK_COMMA TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_COMMA' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 24.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 24.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 24.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 24.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 24.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 24.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 24.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 24.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 24.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 24.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 24.
Parser(B) >> ... then shift 'and_expression', go to state 292
Parser(B) >> Reduce 252 [expression_in_list ::= and_expression], pop back to state 24.
Parser(B) >> ... then shift 'expression_in_list', go to state 298
Parser(B) >> Reduce 170 [expression_list ::= expression_list TK_COMMA expression_in_list], pop back to state 21.
Parser(B) >> ... then shift 'expression_list', go to state 383
Parser(B) >> Shift 'TK_COMMA', go to state 24
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL TK_OPEN_BRACKET expression_list TK_COMMA]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 24
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL TK_OPEN_BRACKET expression_list TK_COMMA TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_CLOSE_BRACKET' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 24.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 24.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 24.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 24.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 24.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 24.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 24.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 24.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 24.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 24.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 24.
Parser(B) >> ... then shift 'and_expression', go to state 292
Parser(B) >> Reduce 252 [expression_in_list ::= and_expression], pop back to state 24.
Parser(B) >> ... then shift 'expression_in_list', go to state 298
Parser(B) >> Reduce 170 [expression_list ::= expression_list TK_COMMA expression_in_list], pop back to state 21.
Parser(B) >> ... then shift 'expression_list', go to state 383
Parser(B) >> Shift 'TK_CLOSE_BRACKET', go to state 207
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL TK_OPEN_BRACKET expression_list TK_CLOSE_BRACKET]
Parser(B) >> Input 'TK_NEQ' in state 207
Parser(B) >> Reduce 175 [function_parameters ::= TK_OPEN_BRACKET expression_list TK_CLOSE_BRACKET], pop back to state 112.
Parser(B) >> ... then shift 'function_parameters', go to state 235
Parser(B) >> Reduce 172 [term ::= TK_VAR_SYMBOL function_parameters], pop back to state 30.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 30.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 30.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 30.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 30.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 30.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 30.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Shift 'TK_NEQ', go to state 47
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ]
Parser(B) >> Input 'TK_INTEGER' in state 47
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 47.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 47.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 47.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 47.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 47.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 47.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 47.
Parser(B) >> ... then shift 'concatenation', go to state 59
Parser(B) >> Reduce 213 [comparison ::= comparison TK_NEQ concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 30.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 30.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 30.
Parser(B) >> ... then shift 'expression', go to state 127
Parser(B) >> Shift 'TK_EOC', go to state 206
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression TK_EOC]
Parser(B) >> Input 'TK_THEN' in state 206
Parser(B) >> Reduce 253 [ncl0 ::= TK_EOC] without external action, pop back to state 127.
Parser(B) >> ... then shift 'ncl0', go to state 131
Parser(B) >> Shift 'TK_THEN', go to state 109
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN]
Parser(B) >> Input 'TK_DO' in state 109
Parser(B) >> Reduce 254 [ncl0 ::=] without external action.
Parser(B) >> ... then shift 'ncl0', go to state 15
Parser(B) >> Shift 'TK_DO', go to state 113
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO]
Parser(B) >> Input 'TK_EOC' in state 113
Parser(B) >> Shift 'TK_EOC', go to state 7
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 7
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 7.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 33
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_PLUS' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 33.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Shift 'TK_PLUS', go to state 64
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL addition TK_PLUS]
Parser(B) >> Input 'TK_INTEGER' in state 64
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL addition TK_PLUS TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 64.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 64.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 64.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 64.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 64.
Parser(B) >> ... then shift 'multiplication', go to state 240
Parser(B) >> Reduce 194 [addition ::= addition TK_PLUS multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 7.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 7.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_SAY' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 7.
Parser(B) >> ... then shift 'labeled_instruction', go to state 184
Parser(B) >> Reduce 33 [instruction_list ::= labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_SAY', go to state 22
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_SAY]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 22
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_SAY TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EOC' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 22.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 22.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 22.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 22.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 22.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 22.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 22.
Parser(B) >> ... then shift 'expression', go to state 331
Parser(B) >> Reduce 160 [say ::= TK_SAY expression], pop back to state 10.
Parser(B) >> ... then shift 'say', go to state 365
Parser(B) >> Reduce 60 [keyword_instruction ::= say], pop back to state 10.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 10.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_END' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 10.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_END', go to state 129
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_END]
Parser(B) >> Input 'TK_EOC' in state 129
Parser(B) >> Reduce 73 [simple_do ::= TK_DO TK_EOC instruction_list TK_END], pop back to state 15.
Parser(B) >> ... then shift 'simple_do', go to state 102
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 406
Parser(B) >> Shift 'TK_EOC', go to state 187
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 simple_do junk TK_EOC]
Parser(B) >> Input 'TK_IF' in state 187
Parser(B) >> Reduce 70 [group ::= simple_do junk TK_EOC], pop back to state 15.
Parser(B) >> ... then shift 'group', go to state 182
Parser(B) >> Reduce 41 [instruction ::= group], pop back to state 15.
Parser(B) >> ... then shift 'instruction', go to state 175
Parser(B) >> Reduce 110 [then ::= TK_THEN ncl0 instruction], pop back to state 131.
Parser(B) >> ... then shift 'then', go to state 108
Parser(B) >> Reduce 108 [if ::= TK_IF expression ncl0 then], pop back to state 8.
Parser(B) >> ... then shift 'if', go to state 185
Parser(B) >> Reduce 72 [group ::= if], pop back to state 8.
Parser(B) >> ... then shift 'group', go to state 193
Parser(B) >> Reduce 35 [labeled_instruction ::= group], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_IF', go to state 30
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 30
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_NEQ' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 30.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 30.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 30.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 30.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 30.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 30.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 30.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 30.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Shift 'TK_NEQ', go to state 47
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ]
Parser(B) >> Input 'TK_INTEGER' in state 47
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 47.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 47.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 47.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 47.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 47.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 47.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 47.
Parser(B) >> ... then shift 'concatenation', go to state 59
Parser(B) >> Reduce 213 [comparison ::= comparison TK_NEQ concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 30.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 30.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 30.
Parser(B) >> ... then shift 'expression', go to state 127
Parser(B) >> Shift 'TK_EOC', go to state 206
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression TK_EOC]
Parser(B) >> Input 'TK_THEN' in state 206
Parser(B) >> Reduce 253 [ncl0 ::= TK_EOC] without external action, pop back to state 127.
Parser(B) >> ... then shift 'ncl0', go to state 131
Parser(B) >> Shift 'TK_THEN', go to state 109
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN]
Parser(B) >> Input 'TK_DO' in state 109
Parser(B) >> Reduce 254 [ncl0 ::=] without external action.
Parser(B) >> ... then shift 'ncl0', go to state 15
Parser(B) >> Shift 'TK_DO', go to state 113
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO]
Parser(B) >> Input 'TK_EOC' in state 113
Parser(B) >> Shift 'TK_EOC', go to state 7
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 7
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 7.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 33
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_PLUS' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 33.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Shift 'TK_PLUS', go to state 64
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL addition TK_PLUS]
Parser(B) >> Input 'TK_INTEGER' in state 64
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL addition TK_PLUS TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 64.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 64.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 64.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 64.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 64.
Parser(B) >> ... then shift 'multiplication', go to state 240
Parser(B) >> Reduce 194 [addition ::= addition TK_PLUS multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 7.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 7.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_SAY' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 7.
Parser(B) >> ... then shift 'labeled_instruction', go to state 184
Parser(B) >> Reduce 33 [instruction_list ::= labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_SAY', go to state 22
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_SAY]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 22
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_SAY TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EOC' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 22.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 22.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 22.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 22.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 22.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 22.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 22.
Parser(B) >> ... then shift 'expression', go to state 331
Parser(B) >> Reduce 160 [say ::= TK_SAY expression], pop back to state 10.
Parser(B) >> ... then shift 'say', go to state 365
Parser(B) >> Reduce 60 [keyword_instruction ::= say], pop back to state 10.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 10.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_END' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 10.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_END', go to state 129
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_END]
Parser(B) >> Input 'TK_EOC' in state 129
Parser(B) >> Reduce 73 [simple_do ::= TK_DO TK_EOC instruction_list TK_END], pop back to state 15.
Parser(B) >> ... then shift 'simple_do', go to state 102
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 406
Parser(B) >> Shift 'TK_EOC', go to state 187
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 simple_do junk TK_EOC]
Parser(B) >> Input 'TK_IF' in state 187
Parser(B) >> Reduce 70 [group ::= simple_do junk TK_EOC], pop back to state 15.
Parser(B) >> ... then shift 'group', go to state 182
Parser(B) >> Reduce 41 [instruction ::= group], pop back to state 15.
Parser(B) >> ... then shift 'instruction', go to state 175
Parser(B) >> Reduce 110 [then ::= TK_THEN ncl0 instruction], pop back to state 131.
Parser(B) >> ... then shift 'then', go to state 108
Parser(B) >> Reduce 108 [if ::= TK_IF expression ncl0 then], pop back to state 8.
Parser(B) >> ... then shift 'if', go to state 185
Parser(B) >> Reduce 72 [group ::= if], pop back to state 8.
Parser(B) >> ... then shift 'group', go to state 193
Parser(B) >> Reduce 35 [labeled_instruction ::= group], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_IF', go to state 30
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 30
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_NEQ' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 30.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 30.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 30.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 30.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 30.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 30.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 30.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 30.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Shift 'TK_NEQ', go to state 47
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ]
Parser(B) >> Input 'TK_INTEGER' in state 47
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 47.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 47.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 47.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 47.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 47.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 47.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 47.
Parser(B) >> ... then shift 'concatenation', go to state 59
Parser(B) >> Reduce 213 [comparison ::= comparison TK_NEQ concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 30.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 30.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 30.
Parser(B) >> ... then shift 'expression', go to state 127
Parser(B) >> Shift 'TK_EOC', go to state 206
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression TK_EOC]
Parser(B) >> Input 'TK_THEN' in state 206
Parser(B) >> Reduce 253 [ncl0 ::= TK_EOC] without external action, pop back to state 127.
Parser(B) >> ... then shift 'ncl0', go to state 131
Parser(B) >> Shift 'TK_THEN', go to state 109
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN]
Parser(B) >> Input 'TK_DO' in state 109
Parser(B) >> Reduce 254 [ncl0 ::=] without external action.
Parser(B) >> ... then shift 'ncl0', go to state 15
Parser(B) >> Shift 'TK_DO', go to state 113
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO]
Parser(B) >> Input 'TK_EOC' in state 113
Parser(B) >> Shift 'TK_EOC', go to state 7
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 7
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 7.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 33
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_PLUS' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 33.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Shift 'TK_PLUS', go to state 64
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL addition TK_PLUS]
Parser(B) >> Input 'TK_INTEGER' in state 64
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL addition TK_PLUS TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 64.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 64.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 64.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 64.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 64.
Parser(B) >> ... then shift 'multiplication', go to state 240
Parser(B) >> Reduce 194 [addition ::= addition TK_PLUS multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 7.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 7.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_SAY' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 7.
Parser(B) >> ... then shift 'labeled_instruction', go to state 184
Parser(B) >> Reduce 33 [instruction_list ::= labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_SAY', go to state 22
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_SAY]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 22
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_SAY TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EOC' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 22.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 22.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 22.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 22.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 22.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 22.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 22.
Parser(B) >> ... then shift 'expression', go to state 331
Parser(B) >> Reduce 160 [say ::= TK_SAY expression], pop back to state 10.
Parser(B) >> ... then shift 'say', go to state 365
Parser(B) >> Reduce 60 [keyword_instruction ::= say], pop back to state 10.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 10.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_END' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 10.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_END', go to state 129
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_END]
Parser(B) >> Input 'TK_EOC' in state 129
Parser(B) >> Reduce 73 [simple_do ::= TK_DO TK_EOC instruction_list TK_END], pop back to state 15.
Parser(B) >> ... then shift 'simple_do', go to state 102
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 406
Parser(B) >> Shift 'TK_EOC', go to state 187
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 simple_do junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 187
Parser(B) >> Reduce 70 [group ::= simple_do junk TK_EOC], pop back to state 15.
Parser(B) >> ... then shift 'group', go to state 182
Parser(B) >> Reduce 41 [instruction ::= group], pop back to state 15.
Parser(B) >> ... then shift 'instruction', go to state 175
Parser(B) >> Reduce 110 [then ::= TK_THEN ncl0 instruction], pop back to state 131.
Parser(B) >> ... then shift 'then', go to state 108
Parser(B) >> Reduce 108 [if ::= TK_IF expression ncl0 then], pop back to state 8.
Parser(B) >> ... then shift 'if', go to state 185
Parser(B) >> Reduce 72 [group ::= if], pop back to state 8.
Parser(B) >> ... then shift 'group', go to state 193
Parser(B) >> Reduce 35 [labeled_instruction ::= group], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 8.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_STRING' in state 33
Parser(B) >> Shift 'TK_STRING', go to state 111
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL TK_STRING]
Parser(B) >> Input 'TK_EOC' in state 111
Parser(B) >> Reduce 179 [term ::= TK_STRING], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 8.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 8.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_INTEGER' in state 33
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 8.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 8.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_INTEGER' in state 33
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 8.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_IF' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_IF', go to state 30
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 30
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_OPEN_BRACKET' in state 112
Parser(B) >> Shift 'TK_OPEN_BRACKET', go to state 21
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL TK_OPEN_BRACKET]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 21
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL TK_OPEN_BRACKET TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_COMMA' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 21.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 21.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 21.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 21.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 21.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 21.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 21.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 21.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 21.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 21.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 21.
Parser(B) >> ... then shift 'and_expression', go to state 292
Parser(B) >> Reduce 252 [expression_in_list ::= and_expression], pop back to state 21.
Parser(B) >> ... then shift 'expression_in_list', go to state 299
Parser(B) >> Reduce 169 [expression_list ::= expression_in_list], pop back to state 21.
Parser(B) >> ... then shift 'expression_list', go to state 383
Parser(B) >> Shift 'TK_COMMA', go to state 24
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL TK_OPEN_BRACKET expression_list TK_COMMA]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 24
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL TK_OPEN_BRACKET expression_list TK_COMMA TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_COMMA' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 24.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 24.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 24.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 24.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 24.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 24.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 24.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 24.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 24.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 24.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 24.
Parser(B) >> ... then shift 'and_expression', go to state 292
Parser(B) >> Reduce 252 [expression_in_list ::= and_expression], pop back to state 24.
Parser(B) >> ... then shift 'expression_in_list', go to state 298
Parser(B) >> Reduce 170 [expression_list ::= expression_list TK_COMMA expression_in_list], pop back to state 21.
Parser(B) >> ... then shift 'expression_list', go to state 383
Parser(B) >> Shift 'TK_COMMA', go to state 24
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL TK_OPEN_BRACKET expression_list TK_COMMA]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 24
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL TK_OPEN_BRACKET expression_list TK_COMMA TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_CLOSE_BRACKET' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 24.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 24.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 24.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 24.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 24.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 24.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 24.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 24.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 24.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 24.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 24.
Parser(B) >> ... then shift 'and_expression', go to state 292
Parser(B) >> Reduce 252 [expression_in_list ::= and_expression], pop back to state 24.
Parser(B) >> ... then shift 'expression_in_list', go to state 298
Parser(B) >> Reduce 170 [expression_list ::= expression_list TK_COMMA expression_in_list], pop back to state 21.
Parser(B) >> ... then shift 'expression_list', go to state 383
Parser(B) >> Shift 'TK_CLOSE_BRACKET', go to state 207
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL TK_OPEN_BRACKET expression_list TK_CLOSE_BRACKET]
Parser(B) >> Input 'TK_NEQ' in state 207
Parser(B) >> Reduce 175 [function_parameters ::= TK_OPEN_BRACKET expression_list TK_CLOSE_BRACKET], pop back to state 112.
Parser(B) >> ... then shift 'function_parameters', go to state 235
Parser(B) >> Reduce 172 [term ::= TK_VAR_SYMBOL function_parameters], pop back to state 30.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 30.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 30.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 30.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 30.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 30.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 30.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Shift 'TK_NEQ', go to state 47
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ]
Parser(B) >> Input 'TK_INTEGER' in state 47
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 47.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 47.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 47.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 47.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 47.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 47.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 47.
Parser(B) >> ... then shift 'concatenation', go to state 59
Parser(B) >> Reduce 213 [comparison ::= comparison TK_NEQ concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 30.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 30.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 30.
Parser(B) >> ... then shift 'expression', go to state 127
Parser(B) >> Shift 'TK_EOC', go to state 206
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression TK_EOC]
Parser(B) >> Input 'TK_THEN' in state 206
Parser(B) >> Reduce 253 [ncl0 ::= TK_EOC] without external action, pop back to state 127.
Parser(B) >> ... then shift 'ncl0', go to state 131
Parser(B) >> Shift 'TK_THEN', go to state 109
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN]
Parser(B) >> Input 'TK_DO' in state 109
Parser(B) >> Reduce 254 [ncl0 ::=] without external action.
Parser(B) >> ... then shift 'ncl0', go to state 15
Parser(B) >> Shift 'TK_DO', go to state 113
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO]
Parser(B) >> Input 'TK_EOC' in state 113
Parser(B) >> Shift 'TK_EOC', go to state 7
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 7
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 7.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 33
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_PLUS' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 33.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Shift 'TK_PLUS', go to state 64
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL addition TK_PLUS]
Parser(B) >> Input 'TK_INTEGER' in state 64
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL addition TK_PLUS TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 64.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 64.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 64.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 64.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 64.
Parser(B) >> ... then shift 'multiplication', go to state 240
Parser(B) >> Reduce 194 [addition ::= addition TK_PLUS multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 7.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 7.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_SAY' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 7.
Parser(B) >> ... then shift 'labeled_instruction', go to state 184
Parser(B) >> Reduce 33 [instruction_list ::= labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_SAY', go to state 22
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_SAY]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 22
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_SAY TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EOC' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 22.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 22.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 22.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 22.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 22.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 22.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 22.
Parser(B) >> ... then shift 'expression', go to state 331
Parser(B) >> Reduce 160 [say ::= TK_SAY expression], pop back to state 10.
Parser(B) >> ... then shift 'say', go to state 365
Parser(B) >> Reduce 60 [keyword_instruction ::= say], pop back to state 10.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 10.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_END' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 10.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_END', go to state 129
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_END]
Parser(B) >> Input 'TK_EOC' in state 129
Parser(B) >> Reduce 73 [simple_do ::= TK_DO TK_EOC instruction_list TK_END], pop back to state 15.
Parser(B) >> ... then shift 'simple_do', go to state 102
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 406
Parser(B) >> Shift 'TK_EOC', go to state 187
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 simple_do junk TK_EOC]
Parser(B) >> Input 'TK_IF' in state 187
Parser(B) >> Reduce 70 [group ::= simple_do junk TK_EOC], pop back to state 15.
Parser(B) >> ... then shift 'group', go to state 182
Parser(B) >> Reduce 41 [instruction ::= group], pop back to state 15.
Parser(B) >> ... then shift 'instruction', go to state 175
Parser(B) >> Reduce 110 [then ::= TK_THEN ncl0 instruction], pop back to state 131.
Parser(B) >> ... then shift 'then', go to state 108
Parser(B) >> Reduce 108 [if ::= TK_IF expression ncl0 then], pop back to state 8.
Parser(B) >> ... then shift 'if', go to state 185
Parser(B) >> Reduce 72 [group ::= if], pop back to state 8.
Parser(B) >> ... then shift 'group', go to state 193
Parser(B) >> Reduce 35 [labeled_instruction ::= group], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_IF', go to state 30
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 30
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_NEQ' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 30.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 30.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 30.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 30.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 30.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 30.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 30.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 30.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Shift 'TK_NEQ', go to state 47
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ]
Parser(B) >> Input 'TK_INTEGER' in state 47
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 47.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 47.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 47.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 47.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 47.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 47.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 47.
Parser(B) >> ... then shift 'concatenation', go to state 59
Parser(B) >> Reduce 213 [comparison ::= comparison TK_NEQ concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 30.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 30.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 30.
Parser(B) >> ... then shift 'expression', go to state 127
Parser(B) >> Shift 'TK_EOC', go to state 206
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression TK_EOC]
Parser(B) >> Input 'TK_THEN' in state 206
Parser(B) >> Reduce 253 [ncl0 ::= TK_EOC] without external action, pop back to state 127.
Parser(B) >> ... then shift 'ncl0', go to state 131
Parser(B) >> Shift 'TK_THEN', go to state 109
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN]
Parser(B) >> Input 'TK_DO' in state 109
Parser(B) >> Reduce 254 [ncl0 ::=] without external action.
Parser(B) >> ... then shift 'ncl0', go to state 15
Parser(B) >> Shift 'TK_DO', go to state 113
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO]
Parser(B) >> Input 'TK_EOC' in state 113
Parser(B) >> Shift 'TK_EOC', go to state 7
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 7
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 7.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 33
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_PLUS' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 33.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Shift 'TK_PLUS', go to state 64
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL addition TK_PLUS]
Parser(B) >> Input 'TK_INTEGER' in state 64
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL addition TK_PLUS TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 64.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 64.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 64.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 64.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 64.
Parser(B) >> ... then shift 'multiplication', go to state 240
Parser(B) >> Reduce 194 [addition ::= addition TK_PLUS multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 7.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 7.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_SAY' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 7.
Parser(B) >> ... then shift 'labeled_instruction', go to state 184
Parser(B) >> Reduce 33 [instruction_list ::= labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_SAY', go to state 22
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_SAY]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 22
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_SAY TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EOC' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 22.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 22.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 22.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 22.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 22.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 22.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 22.
Parser(B) >> ... then shift 'expression', go to state 331
Parser(B) >> Reduce 160 [say ::= TK_SAY expression], pop back to state 10.
Parser(B) >> ... then shift 'say', go to state 365
Parser(B) >> Reduce 60 [keyword_instruction ::= say], pop back to state 10.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 10.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_END' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 10.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_END', go to state 129
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_END]
Parser(B) >> Input 'TK_EOC' in state 129
Parser(B) >> Reduce 73 [simple_do ::= TK_DO TK_EOC instruction_list TK_END], pop back to state 15.
Parser(B) >> ... then shift 'simple_do', go to state 102
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 406
Parser(B) >> Shift 'TK_EOC', go to state 187
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 simple_do junk TK_EOC]
Parser(B) >> Input 'TK_IF' in state 187
Parser(B) >> Reduce 70 [group ::= simple_do junk TK_EOC], pop back to state 15.
Parser(B) >> ... then shift 'group', go to state 182
Parser(B) >> Reduce 41 [instruction ::= group], pop back to state 15.
Parser(B) >> ... then shift 'instruction', go to state 175
Parser(B) >> Reduce 110 [then ::= TK_THEN ncl0 instruction], pop back to state 131.
Parser(B) >> ... then shift 'then', go to state 108
Parser(B) >> Reduce 108 [if ::= TK_IF expression ncl0 then], pop back to state 8.
Parser(B) >> ... then shift 'if', go to state 185
Parser(B) >> Reduce 72 [group ::= if], pop back to state 8.
Parser(B) >> ... then shift 'group', go to state 193
Parser(B) >> Reduce 35 [labeled_instruction ::= group], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_IF', go to state 30
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 30
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_NEQ' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 30.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 30.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 30.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 30.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 30.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 30.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 30.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 30.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Shift 'TK_NEQ', go to state 47
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ]
Parser(B) >> Input 'TK_INTEGER' in state 47
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 47.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 47.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 47.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 47.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 47.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 47.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 47.
Parser(B) >> ... then shift 'concatenation', go to state 59
Parser(B) >> Reduce 213 [comparison ::= comparison TK_NEQ concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 30.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 30.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 30.
Parser(B) >> ... then shift 'expression', go to state 127
Parser(B) >> Shift 'TK_EOC', go to state 206
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression TK_EOC]
Parser(B) >> Input 'TK_THEN' in state 206
Parser(B) >> Reduce 253 [ncl0 ::= TK_EOC] without external action, pop back to state 127.
Parser(B) >> ... then shift 'ncl0', go to state 131
Parser(B) >> Shift 'TK_THEN', go to state 109
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN]
Parser(B) >> Input 'TK_DO' in state 109
Parser(B) >> Reduce 254 [ncl0 ::=] without external action.
Parser(B) >> ... then shift 'ncl0', go to state 15
Parser(B) >> Shift 'TK_DO', go to state 113
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO]
Parser(B) >> Input 'TK_EOC' in state 113
Parser(B) >> Shift 'TK_EOC', go to state 7
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 7
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 7.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 33
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_PLUS' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 33.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Shift 'TK_PLUS', go to state 64
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL addition TK_PLUS]
Parser(B) >> Input 'TK_INTEGER' in state 64
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL addition TK_PLUS TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 64.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 64.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 64.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 64.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 64.
Parser(B) >> ... then shift 'multiplication', go to state 240
Parser(B) >> Reduce 194 [addition ::= addition TK_PLUS multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 7.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 7.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_SAY' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 7.
Parser(B) >> ... then shift 'labeled_instruction', go to state 184
Parser(B) >> Reduce 33 [instruction_list ::= labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_SAY', go to state 22
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_SAY]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 22
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_SAY TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EOC' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 22.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 22.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 22.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 22.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 22.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 22.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 22.
Parser(B) >> ... then shift 'expression', go to state 331
Parser(B) >> Reduce 160 [say ::= TK_SAY expression], pop back to state 10.
Parser(B) >> ... then shift 'say', go to state 365
Parser(B) >> Reduce 60 [keyword_instruction ::= say], pop back to state 10.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 10.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_END' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 10.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_END', go to state 129
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_END]
Parser(B) >> Input 'TK_EOC' in state 129
Parser(B) >> Reduce 73 [simple_do ::= TK_DO TK_EOC instruction_list TK_END], pop back to state 15.
Parser(B) >> ... then shift 'simple_do', go to state 102
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 406
Parser(B) >> Shift 'TK_EOC', go to state 187
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 simple_do junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 187
Parser(B) >> Reduce 70 [group ::= simple_do junk TK_EOC], pop back to state 15.
Parser(B) >> ... then shift 'group', go to state 182
Parser(B) >> Reduce 41 [instruction ::= group], pop back to state 15.
Parser(B) >> ... then shift 'instruction', go to state 175
Parser(B) >> Reduce 110 [then ::= TK_THEN ncl0 instruction], pop back to state 131.
Parser(B) >> ... then shift 'then', go to state 108
Parser(B) >> Reduce 108 [if ::= TK_IF expression ncl0 then], pop back to state 8.
Parser(B) >> ... then shift 'if', go to state 185
Parser(B) >> Reduce 72 [group ::= if], pop back to state 8.
Parser(B) >> ... then shift 'group', go to state 193
Parser(B) >> Reduce 35 [labeled_instruction ::= group], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 8.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_STRING' in state 33
Parser(B) >> Shift 'TK_STRING', go to state 111
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL TK_STRING]
Parser(B) >> Input 'TK_EOC' in state 111
Parser(B) >> Reduce 179 [term ::= TK_STRING], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 8.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 8.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_INTEGER' in state 33
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 8.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_IF' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_IF', go to state 30
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 30
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_OPEN_BRACKET' in state 112
Parser(B) >> Shift 'TK_OPEN_BRACKET', go to state 21
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL TK_OPEN_BRACKET]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 21
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL TK_OPEN_BRACKET TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_COMMA' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 21.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 21.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 21.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 21.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 21.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 21.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 21.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 21.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 21.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 21.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 21.
Parser(B) >> ... then shift 'and_expression', go to state 292
Parser(B) >> Reduce 252 [expression_in_list ::= and_expression], pop back to state 21.
Parser(B) >> ... then shift 'expression_in_list', go to state 299
Parser(B) >> Reduce 169 [expression_list ::= expression_in_list], pop back to state 21.
Parser(B) >> ... then shift 'expression_list', go to state 383
Parser(B) >> Shift 'TK_COMMA', go to state 24
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL TK_OPEN_BRACKET expression_list TK_COMMA]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 24
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL TK_OPEN_BRACKET expression_list TK_COMMA TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_CLOSE_BRACKET' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 24.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 24.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 24.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 24.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 24.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 24.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 24.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 24.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 24.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 24.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 24.
Parser(B) >> ... then shift 'and_expression', go to state 292
Parser(B) >> Reduce 252 [expression_in_list ::= and_expression], pop back to state 24.
Parser(B) >> ... then shift 'expression_in_list', go to state 298
Parser(B) >> Reduce 170 [expression_list ::= expression_list TK_COMMA expression_in_list], pop back to state 21.
Parser(B) >> ... then shift 'expression_list', go to state 383
Parser(B) >> Shift 'TK_CLOSE_BRACKET', go to state 207
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL TK_OPEN_BRACKET expression_list TK_CLOSE_BRACKET]
Parser(B) >> Input 'TK_NEQ' in state 207
Parser(B) >> Reduce 175 [function_parameters ::= TK_OPEN_BRACKET expression_list TK_CLOSE_BRACKET], pop back to state 112.
Parser(B) >> ... then shift 'function_parameters', go to state 235
Parser(B) >> Reduce 172 [term ::= TK_VAR_SYMBOL function_parameters], pop back to state 30.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 30.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 30.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 30.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 30.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 30.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 30.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Shift 'TK_NEQ', go to state 47
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ]
Parser(B) >> Input 'TK_INTEGER' in state 47
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 47.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 47.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 47.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 47.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 47.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 47.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 47.
Parser(B) >> ... then shift 'concatenation', go to state 59
Parser(B) >> Reduce 213 [comparison ::= comparison TK_NEQ concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 30.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 30.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 30.
Parser(B) >> ... then shift 'expression', go to state 127
Parser(B) >> Shift 'TK_EOC', go to state 206
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression TK_EOC]
Parser(B) >> Input 'TK_THEN' in state 206
Parser(B) >> Reduce 253 [ncl0 ::= TK_EOC] without external action, pop back to state 127.
Parser(B) >> ... then shift 'ncl0', go to state 131
Parser(B) >> Shift 'TK_THEN', go to state 109
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN]
Parser(B) >> Input 'TK_DO' in state 109
Parser(B) >> Reduce 254 [ncl0 ::=] without external action.
Parser(B) >> ... then shift 'ncl0', go to state 15
Parser(B) >> Shift 'TK_DO', go to state 113
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO]
Parser(B) >> Input 'TK_EOC' in state 113
Parser(B) >> Shift 'TK_EOC', go to state 7
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 7
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 7.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 33
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_PLUS' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 33.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Shift 'TK_PLUS', go to state 64
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL addition TK_PLUS]
Parser(B) >> Input 'TK_INTEGER' in state 64
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL addition TK_PLUS TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 64.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 64.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 64.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 64.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 64.
Parser(B) >> ... then shift 'multiplication', go to state 240
Parser(B) >> Reduce 194 [addition ::= addition TK_PLUS multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 7.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 7.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_SAY' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 7.
Parser(B) >> ... then shift 'labeled_instruction', go to state 184
Parser(B) >> Reduce 33 [instruction_list ::= labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_SAY', go to state 22
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_SAY]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 22
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_SAY TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EOC' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 22.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 22.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 22.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 22.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 22.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 22.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 22.
Parser(B) >> ... then shift 'expression', go to state 331
Parser(B) >> Reduce 160 [say ::= TK_SAY expression], pop back to state 10.
Parser(B) >> ... then shift 'say', go to state 365
Parser(B) >> Reduce 60 [keyword_instruction ::= say], pop back to state 10.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 10.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_END' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 10.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_END', go to state 129
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_END]
Parser(B) >> Input 'TK_EOC' in state 129
Parser(B) >> Reduce 73 [simple_do ::= TK_DO TK_EOC instruction_list TK_END], pop back to state 15.
Parser(B) >> ... then shift 'simple_do', go to state 102
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 406
Parser(B) >> Shift 'TK_EOC', go to state 187
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 simple_do junk TK_EOC]
Parser(B) >> Input 'TK_IF' in state 187
Parser(B) >> Reduce 70 [group ::= simple_do junk TK_EOC], pop back to state 15.
Parser(B) >> ... then shift 'group', go to state 182
Parser(B) >> Reduce 41 [instruction ::= group], pop back to state 15.
Parser(B) >> ... then shift 'instruction', go to state 175
Parser(B) >> Reduce 110 [then ::= TK_THEN ncl0 instruction], pop back to state 131.
Parser(B) >> ... then shift 'then', go to state 108
Parser(B) >> Reduce 108 [if ::= TK_IF expression ncl0 then], pop back to state 8.
Parser(B) >> ... then shift 'if', go to state 185
Parser(B) >> Reduce 72 [group ::= if], pop back to state 8.
Parser(B) >> ... then shift 'group', go to state 193
Parser(B) >> Reduce 35 [labeled_instruction ::= group], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_IF', go to state 30
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 30
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_NEQ' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 30.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 30.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 30.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 30.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 30.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 30.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 30.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 30.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Shift 'TK_NEQ', go to state 47
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ]
Parser(B) >> Input 'TK_INTEGER' in state 47
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 47.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 47.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 47.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 47.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 47.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 47.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 47.
Parser(B) >> ... then shift 'concatenation', go to state 59
Parser(B) >> Reduce 213 [comparison ::= comparison TK_NEQ concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 30.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 30.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 30.
Parser(B) >> ... then shift 'expression', go to state 127
Parser(B) >> Shift 'TK_EOC', go to state 206
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression TK_EOC]
Parser(B) >> Input 'TK_THEN' in state 206
Parser(B) >> Reduce 253 [ncl0 ::= TK_EOC] without external action, pop back to state 127.
Parser(B) >> ... then shift 'ncl0', go to state 131
Parser(B) >> Shift 'TK_THEN', go to state 109
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN]
Parser(B) >> Input 'TK_DO' in state 109
Parser(B) >> Reduce 254 [ncl0 ::=] without external action.
Parser(B) >> ... then shift 'ncl0', go to state 15
Parser(B) >> Shift 'TK_DO', go to state 113
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO]
Parser(B) >> Input 'TK_EOC' in state 113
Parser(B) >> Shift 'TK_EOC', go to state 7
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 7
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 7.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 33
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_PLUS' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 33.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Shift 'TK_PLUS', go to state 64
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL addition TK_PLUS]
Parser(B) >> Input 'TK_INTEGER' in state 64
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL addition TK_PLUS TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 64.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 64.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 64.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 64.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 64.
Parser(B) >> ... then shift 'multiplication', go to state 240
Parser(B) >> Reduce 194 [addition ::= addition TK_PLUS multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 7.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 7.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_SAY' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 7.
Parser(B) >> ... then shift 'labeled_instruction', go to state 184
Parser(B) >> Reduce 33 [instruction_list ::= labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_SAY', go to state 22
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_SAY]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 22
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_SAY TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EOC' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 22.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 22.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 22.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 22.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 22.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 22.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 22.
Parser(B) >> ... then shift 'expression', go to state 331
Parser(B) >> Reduce 160 [say ::= TK_SAY expression], pop back to state 10.
Parser(B) >> ... then shift 'say', go to state 365
Parser(B) >> Reduce 60 [keyword_instruction ::= say], pop back to state 10.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 10.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_END' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 10.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_END', go to state 129
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_END]
Parser(B) >> Input 'TK_EOC' in state 129
Parser(B) >> Reduce 73 [simple_do ::= TK_DO TK_EOC instruction_list TK_END], pop back to state 15.
Parser(B) >> ... then shift 'simple_do', go to state 102
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 406
Parser(B) >> Shift 'TK_EOC', go to state 187
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 simple_do junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 187
Parser(B) >> Reduce 70 [group ::= simple_do junk TK_EOC], pop back to state 15.
Parser(B) >> ... then shift 'group', go to state 182
Parser(B) >> Reduce 41 [instruction ::= group], pop back to state 15.
Parser(B) >> ... then shift 'instruction', go to state 175
Parser(B) >> Reduce 110 [then ::= TK_THEN ncl0 instruction], pop back to state 131.
Parser(B) >> ... then shift 'then', go to state 108
Parser(B) >> Reduce 108 [if ::= TK_IF expression ncl0 then], pop back to state 8.
Parser(B) >> ... then shift 'if', go to state 185
Parser(B) >> Reduce 72 [group ::= if], pop back to state 8.
Parser(B) >> ... then shift 'group', go to state 193
Parser(B) >> Reduce 35 [labeled_instruction ::= group], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 8.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_STRING' in state 33
Parser(B) >> Shift 'TK_STRING', go to state 111
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL TK_STRING]
Parser(B) >> Input 'TK_EOC' in state 111
Parser(B) >> Reduce 179 [term ::= TK_STRING], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 8.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 8.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_INTEGER' in state 33
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 8.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 8.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_INTEGER' in state 33
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 8.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_IF' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_IF', go to state 30
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 30
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_OPEN_BRACKET' in state 112
Parser(B) >> Shift 'TK_OPEN_BRACKET', go to state 21
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL TK_OPEN_BRACKET]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 21
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL TK_OPEN_BRACKET TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_COMMA' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 21.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 21.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 21.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 21.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 21.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 21.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 21.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 21.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 21.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 21.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 21.
Parser(B) >> ... then shift 'and_expression', go to state 292
Parser(B) >> Reduce 252 [expression_in_list ::= and_expression], pop back to state 21.
Parser(B) >> ... then shift 'expression_in_list', go to state 299
Parser(B) >> Reduce 169 [expression_list ::= expression_in_list], pop back to state 21.
Parser(B) >> ... then shift 'expression_list', go to state 383
Parser(B) >> Shift 'TK_COMMA', go to state 24
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL TK_OPEN_BRACKET expression_list TK_COMMA]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 24
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL TK_OPEN_BRACKET expression_list TK_COMMA TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_COMMA' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 24.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 24.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 24.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 24.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 24.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 24.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 24.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 24.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 24.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 24.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 24.
Parser(B) >> ... then shift 'and_expression', go to state 292
Parser(B) >> Reduce 252 [expression_in_list ::= and_expression], pop back to state 24.
Parser(B) >> ... then shift 'expression_in_list', go to state 298
Parser(B) >> Reduce 170 [expression_list ::= expression_list TK_COMMA expression_in_list], pop back to state 21.
Parser(B) >> ... then shift 'expression_list', go to state 383
Parser(B) >> Shift 'TK_COMMA', go to state 24
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL TK_OPEN_BRACKET expression_list TK_COMMA]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 24
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL TK_OPEN_BRACKET expression_list TK_COMMA TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_CLOSE_BRACKET' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 24.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 24.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 24.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 24.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 24.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 24.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 24.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 24.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 24.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 24.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 24.
Parser(B) >> ... then shift 'and_expression', go to state 292
Parser(B) >> Reduce 252 [expression_in_list ::= and_expression], pop back to state 24.
Parser(B) >> ... then shift 'expression_in_list', go to state 298
Parser(B) >> Reduce 170 [expression_list ::= expression_list TK_COMMA expression_in_list], pop back to state 21.
Parser(B) >> ... then shift 'expression_list', go to state 383
Parser(B) >> Shift 'TK_CLOSE_BRACKET', go to state 207
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL TK_OPEN_BRACKET expression_list TK_CLOSE_BRACKET]
Parser(B) >> Input 'TK_NEQ' in state 207
Parser(B) >> Reduce 175 [function_parameters ::= TK_OPEN_BRACKET expression_list TK_CLOSE_BRACKET], pop back to state 112.
Parser(B) >> ... then shift 'function_parameters', go to state 235
Parser(B) >> Reduce 172 [term ::= TK_VAR_SYMBOL function_parameters], pop back to state 30.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 30.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 30.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 30.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 30.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 30.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 30.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Shift 'TK_NEQ', go to state 47
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ]
Parser(B) >> Input 'TK_INTEGER' in state 47
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 47.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 47.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 47.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 47.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 47.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 47.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 47.
Parser(B) >> ... then shift 'concatenation', go to state 59
Parser(B) >> Reduce 213 [comparison ::= comparison TK_NEQ concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 30.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 30.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 30.
Parser(B) >> ... then shift 'expression', go to state 127
Parser(B) >> Shift 'TK_EOC', go to state 206
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression TK_EOC]
Parser(B) >> Input 'TK_THEN' in state 206
Parser(B) >> Reduce 253 [ncl0 ::= TK_EOC] without external action, pop back to state 127.
Parser(B) >> ... then shift 'ncl0', go to state 131
Parser(B) >> Shift 'TK_THEN', go to state 109
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN]
Parser(B) >> Input 'TK_DO' in state 109
Parser(B) >> Reduce 254 [ncl0 ::=] without external action.
Parser(B) >> ... then shift 'ncl0', go to state 15
Parser(B) >> Shift 'TK_DO', go to state 113
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO]
Parser(B) >> Input 'TK_EOC' in state 113
Parser(B) >> Shift 'TK_EOC', go to state 7
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 7
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 7.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 33
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_PLUS' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 33.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Shift 'TK_PLUS', go to state 64
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL addition TK_PLUS]
Parser(B) >> Input 'TK_INTEGER' in state 64
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL addition TK_PLUS TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 64.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 64.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 64.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 64.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 64.
Parser(B) >> ... then shift 'multiplication', go to state 240
Parser(B) >> Reduce 194 [addition ::= addition TK_PLUS multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 7.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 7.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_SAY' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 7.
Parser(B) >> ... then shift 'labeled_instruction', go to state 184
Parser(B) >> Reduce 33 [instruction_list ::= labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_SAY', go to state 22
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_SAY]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 22
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_SAY TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EOC' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 22.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 22.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 22.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 22.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 22.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 22.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 22.
Parser(B) >> ... then shift 'expression', go to state 331
Parser(B) >> Reduce 160 [say ::= TK_SAY expression], pop back to state 10.
Parser(B) >> ... then shift 'say', go to state 365
Parser(B) >> Reduce 60 [keyword_instruction ::= say], pop back to state 10.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 10.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_END' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 10.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_END', go to state 129
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_END]
Parser(B) >> Input 'TK_EOC' in state 129
Parser(B) >> Reduce 73 [simple_do ::= TK_DO TK_EOC instruction_list TK_END], pop back to state 15.
Parser(B) >> ... then shift 'simple_do', go to state 102
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 406
Parser(B) >> Shift 'TK_EOC', go to state 187
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 simple_do junk TK_EOC]
Parser(B) >> Input 'TK_IF' in state 187
Parser(B) >> Reduce 70 [group ::= simple_do junk TK_EOC], pop back to state 15.
Parser(B) >> ... then shift 'group', go to state 182
Parser(B) >> Reduce 41 [instruction ::= group], pop back to state 15.
Parser(B) >> ... then shift 'instruction', go to state 175
Parser(B) >> Reduce 110 [then ::= TK_THEN ncl0 instruction], pop back to state 131.
Parser(B) >> ... then shift 'then', go to state 108
Parser(B) >> Reduce 108 [if ::= TK_IF expression ncl0 then], pop back to state 8.
Parser(B) >> ... then shift 'if', go to state 185
Parser(B) >> Reduce 72 [group ::= if], pop back to state 8.
Parser(B) >> ... then shift 'group', go to state 193
Parser(B) >> Reduce 35 [labeled_instruction ::= group], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_IF', go to state 30
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 30
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_NEQ' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 30.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 30.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 30.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 30.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 30.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 30.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 30.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 30.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Shift 'TK_NEQ', go to state 47
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ]
Parser(B) >> Input 'TK_INTEGER' in state 47
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 47.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 47.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 47.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 47.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 47.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 47.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 47.
Parser(B) >> ... then shift 'concatenation', go to state 59
Parser(B) >> Reduce 213 [comparison ::= comparison TK_NEQ concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 30.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 30.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 30.
Parser(B) >> ... then shift 'expression', go to state 127
Parser(B) >> Shift 'TK_EOC', go to state 206
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression TK_EOC]
Parser(B) >> Input 'TK_THEN' in state 206
Parser(B) >> Reduce 253 [ncl0 ::= TK_EOC] without external action, pop back to state 127.
Parser(B) >> ... then shift 'ncl0', go to state 131
Parser(B) >> Shift 'TK_THEN', go to state 109
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN]
Parser(B) >> Input 'TK_DO' in state 109
Parser(B) >> Reduce 254 [ncl0 ::=] without external action.
Parser(B) >> ... then shift 'ncl0', go to state 15
Parser(B) >> Shift 'TK_DO', go to state 113
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO]
Parser(B) >> Input 'TK_EOC' in state 113
Parser(B) >> Shift 'TK_EOC', go to state 7
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 7
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 7.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 33
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_PLUS' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 33.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Shift 'TK_PLUS', go to state 64
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL addition TK_PLUS]
Parser(B) >> Input 'TK_INTEGER' in state 64
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL addition TK_PLUS TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 64.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 64.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 64.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 64.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 64.
Parser(B) >> ... then shift 'multiplication', go to state 240
Parser(B) >> Reduce 194 [addition ::= addition TK_PLUS multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 7.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 7.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_SAY' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 7.
Parser(B) >> ... then shift 'labeled_instruction', go to state 184
Parser(B) >> Reduce 33 [instruction_list ::= labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_SAY', go to state 22
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_SAY]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 22
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_SAY TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EOC' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 22.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 22.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 22.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 22.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 22.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 22.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 22.
Parser(B) >> ... then shift 'expression', go to state 331
Parser(B) >> Reduce 160 [say ::= TK_SAY expression], pop back to state 10.
Parser(B) >> ... then shift 'say', go to state 365
Parser(B) >> Reduce 60 [keyword_instruction ::= say], pop back to state 10.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 10.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_END' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 10.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_END', go to state 129
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_END]
Parser(B) >> Input 'TK_EOC' in state 129
Parser(B) >> Reduce 73 [simple_do ::= TK_DO TK_EOC instruction_list TK_END], pop back to state 15.
Parser(B) >> ... then shift 'simple_do', go to state 102
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 406
Parser(B) >> Shift 'TK_EOC', go to state 187
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 simple_do junk TK_EOC]
Parser(B) >> Input 'TK_IF' in state 187
Parser(B) >> Reduce 70 [group ::= simple_do junk TK_EOC], pop back to state 15.
Parser(B) >> ... then shift 'group', go to state 182
Parser(B) >> Reduce 41 [instruction ::= group], pop back to state 15.
Parser(B) >> ... then shift 'instruction', go to state 175
Parser(B) >> Reduce 110 [then ::= TK_THEN ncl0 instruction], pop back to state 131.
Parser(B) >> ... then shift 'then', go to state 108
Parser(B) >> Reduce 108 [if ::= TK_IF expression ncl0 then], pop back to state 8.
Parser(B) >> ... then shift 'if', go to state 185
Parser(B) >> Reduce 72 [group ::= if], pop back to state 8.
Parser(B) >> ... then shift 'group', go to state 193
Parser(B) >> Reduce 35 [labeled_instruction ::= group], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_IF', go to state 30
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 30
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_NEQ' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 30.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 30.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 30.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 30.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 30.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 30.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 30.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 30.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Shift 'TK_NEQ', go to state 47
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ]
Parser(B) >> Input 'TK_INTEGER' in state 47
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 47.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 47.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 47.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 47.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 47.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 47.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 47.
Parser(B) >> ... then shift 'concatenation', go to state 59
Parser(B) >> Reduce 213 [comparison ::= comparison TK_NEQ concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 30.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 30.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 30.
Parser(B) >> ... then shift 'expression', go to state 127
Parser(B) >> Shift 'TK_EOC', go to state 206
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression TK_EOC]
Parser(B) >> Input 'TK_THEN' in state 206
Parser(B) >> Reduce 253 [ncl0 ::= TK_EOC] without external action, pop back to state 127.
Parser(B) >> ... then shift 'ncl0', go to state 131
Parser(B) >> Shift 'TK_THEN', go to state 109
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN]
Parser(B) >> Input 'TK_DO' in state 109
Parser(B) >> Reduce 254 [ncl0 ::=] without external action.
Parser(B) >> ... then shift 'ncl0', go to state 15
Parser(B) >> Shift 'TK_DO', go to state 113
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO]
Parser(B) >> Input 'TK_EOC' in state 113
Parser(B) >> Shift 'TK_EOC', go to state 7
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 7
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 7.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 33
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_PLUS' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 33.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Shift 'TK_PLUS', go to state 64
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL addition TK_PLUS]
Parser(B) >> Input 'TK_INTEGER' in state 64
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL addition TK_PLUS TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 64.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 64.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 64.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 64.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 64.
Parser(B) >> ... then shift 'multiplication', go to state 240
Parser(B) >> Reduce 194 [addition ::= addition TK_PLUS multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 7.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 7.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_SAY' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 7.
Parser(B) >> ... then shift 'labeled_instruction', go to state 184
Parser(B) >> Reduce 33 [instruction_list ::= labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_SAY', go to state 22
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_SAY]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 22
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_SAY TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EOC' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 22.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 22.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 22.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 22.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 22.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 22.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 22.
Parser(B) >> ... then shift 'expression', go to state 331
Parser(B) >> Reduce 160 [say ::= TK_SAY expression], pop back to state 10.
Parser(B) >> ... then shift 'say', go to state 365
Parser(B) >> Reduce 60 [keyword_instruction ::= say], pop back to state 10.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 10.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_END' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 10.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_END', go to state 129
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_END]
Parser(B) >> Input 'TK_EOC' in state 129
Parser(B) >> Reduce 73 [simple_do ::= TK_DO TK_EOC instruction_list TK_END], pop back to state 15.
Parser(B) >> ... then shift 'simple_do', go to state 102
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 406
Parser(B) >> Shift 'TK_EOC', go to state 187
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 simple_do junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 187
Parser(B) >> Reduce 70 [group ::= simple_do junk TK_EOC], pop back to state 15.
Parser(B) >> ... then shift 'group', go to state 182
Parser(B) >> Reduce 41 [instruction ::= group], pop back to state 15.
Parser(B) >> ... then shift 'instruction', go to state 175
Parser(B) >> Reduce 110 [then ::= TK_THEN ncl0 instruction], pop back to state 131.
Parser(B) >> ... then shift 'then', go to state 108
Parser(B) >> Reduce 108 [if ::= TK_IF expression ncl0 then], pop back to state 8.
Parser(B) >> ... then shift 'if', go to state 185
Parser(B) >> Reduce 72 [group ::= if], pop back to state 8.
Parser(B) >> ... then shift 'group', go to state 193
Parser(B) >> Reduce 35 [labeled_instruction ::= group], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 8.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_STRING' in state 33
Parser(B) >> Shift 'TK_STRING', go to state 111
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL TK_STRING]
Parser(B) >> Input 'TK_EOC' in state 111
Parser(B) >> Reduce 179 [term ::= TK_STRING], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 8.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 8.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_FLOAT' in state 33
Parser(B) >> Shift 'TK_FLOAT', go to state 231
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL TK_FLOAT]
Parser(B) >> Input 'TK_EOC' in state 231
Parser(B) >> Reduce 177 [term ::= TK_FLOAT], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 8.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 8.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_INTEGER' in state 33
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 8.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_IF' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_IF', go to state 30
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 30
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_OPEN_BRACKET' in state 112
Parser(B) >> Shift 'TK_OPEN_BRACKET', go to state 21
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL TK_OPEN_BRACKET]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 21
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL TK_OPEN_BRACKET TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_COMMA' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 21.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 21.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 21.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 21.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 21.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 21.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 21.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 21.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 21.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 21.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 21.
Parser(B) >> ... then shift 'and_expression', go to state 292
Parser(B) >> Reduce 252 [expression_in_list ::= and_expression], pop back to state 21.
Parser(B) >> ... then shift 'expression_in_list', go to state 299
Parser(B) >> Reduce 169 [expression_list ::= expression_in_list], pop back to state 21.
Parser(B) >> ... then shift 'expression_list', go to state 383
Parser(B) >> Shift 'TK_COMMA', go to state 24
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL TK_OPEN_BRACKET expression_list TK_COMMA]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 24
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL TK_OPEN_BRACKET expression_list TK_COMMA TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_COMMA' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 24.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 24.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 24.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 24.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 24.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 24.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 24.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 24.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 24.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 24.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 24.
Parser(B) >> ... then shift 'and_expression', go to state 292
Parser(B) >> Reduce 252 [expression_in_list ::= and_expression], pop back to state 24.
Parser(B) >> ... then shift 'expression_in_list', go to state 298
Parser(B) >> Reduce 170 [expression_list ::= expression_list TK_COMMA expression_in_list], pop back to state 21.
Parser(B) >> ... then shift 'expression_list', go to state 383
Parser(B) >> Shift 'TK_COMMA', go to state 24
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL TK_OPEN_BRACKET expression_list TK_COMMA]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 24
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL TK_OPEN_BRACKET expression_list TK_COMMA TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_CLOSE_BRACKET' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 24.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 24.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 24.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 24.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 24.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 24.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 24.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 24.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 24.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 24.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 24.
Parser(B) >> ... then shift 'and_expression', go to state 292
Parser(B) >> Reduce 252 [expression_in_list ::= and_expression], pop back to state 24.
Parser(B) >> ... then shift 'expression_in_list', go to state 298
Parser(B) >> Reduce 170 [expression_list ::= expression_list TK_COMMA expression_in_list], pop back to state 21.
Parser(B) >> ... then shift 'expression_list', go to state 383
Parser(B) >> Shift 'TK_CLOSE_BRACKET', go to state 207
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL TK_OPEN_BRACKET expression_list TK_CLOSE_BRACKET]
Parser(B) >> Input 'TK_NEQ' in state 207
Parser(B) >> Reduce 175 [function_parameters ::= TK_OPEN_BRACKET expression_list TK_CLOSE_BRACKET], pop back to state 112.
Parser(B) >> ... then shift 'function_parameters', go to state 235
Parser(B) >> Reduce 172 [term ::= TK_VAR_SYMBOL function_parameters], pop back to state 30.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 30.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 30.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 30.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 30.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 30.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 30.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Shift 'TK_NEQ', go to state 47
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ]
Parser(B) >> Input 'TK_INTEGER' in state 47
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 47.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 47.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 47.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 47.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 47.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 47.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 47.
Parser(B) >> ... then shift 'concatenation', go to state 59
Parser(B) >> Reduce 213 [comparison ::= comparison TK_NEQ concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 30.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 30.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 30.
Parser(B) >> ... then shift 'expression', go to state 127
Parser(B) >> Shift 'TK_EOC', go to state 206
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression TK_EOC]
Parser(B) >> Input 'TK_THEN' in state 206
Parser(B) >> Reduce 253 [ncl0 ::= TK_EOC] without external action, pop back to state 127.
Parser(B) >> ... then shift 'ncl0', go to state 131
Parser(B) >> Shift 'TK_THEN', go to state 109
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN]
Parser(B) >> Input 'TK_DO' in state 109
Parser(B) >> Reduce 254 [ncl0 ::=] without external action.
Parser(B) >> ... then shift 'ncl0', go to state 15
Parser(B) >> Shift 'TK_DO', go to state 113
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO]
Parser(B) >> Input 'TK_EOC' in state 113
Parser(B) >> Shift 'TK_EOC', go to state 7
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 7
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 7.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 33
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_PLUS' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 33.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Shift 'TK_PLUS', go to state 64
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL addition TK_PLUS]
Parser(B) >> Input 'TK_INTEGER' in state 64
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL addition TK_PLUS TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 64.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 64.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 64.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 64.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 64.
Parser(B) >> ... then shift 'multiplication', go to state 240
Parser(B) >> Reduce 194 [addition ::= addition TK_PLUS multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 7.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 7.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_SAY' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 7.
Parser(B) >> ... then shift 'labeled_instruction', go to state 184
Parser(B) >> Reduce 33 [instruction_list ::= labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_SAY', go to state 22
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_SAY]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 22
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_SAY TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EOC' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 22.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 22.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 22.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 22.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 22.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 22.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 22.
Parser(B) >> ... then shift 'expression', go to state 331
Parser(B) >> Reduce 160 [say ::= TK_SAY expression], pop back to state 10.
Parser(B) >> ... then shift 'say', go to state 365
Parser(B) >> Reduce 60 [keyword_instruction ::= say], pop back to state 10.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 10.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_END' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 10.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_END', go to state 129
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_END]
Parser(B) >> Input 'TK_EOC' in state 129
Parser(B) >> Reduce 73 [simple_do ::= TK_DO TK_EOC instruction_list TK_END], pop back to state 15.
Parser(B) >> ... then shift 'simple_do', go to state 102
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 406
Parser(B) >> Shift 'TK_EOC', go to state 187
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 simple_do junk TK_EOC]
Parser(B) >> Input 'TK_IF' in state 187
Parser(B) >> Reduce 70 [group ::= simple_do junk TK_EOC], pop back to state 15.
Parser(B) >> ... then shift 'group', go to state 182
Parser(B) >> Reduce 41 [instruction ::= group], pop back to state 15.
Parser(B) >> ... then shift 'instruction', go to state 175
Parser(B) >> Reduce 110 [then ::= TK_THEN ncl0 instruction], pop back to state 131.
Parser(B) >> ... then shift 'then', go to state 108
Parser(B) >> Reduce 108 [if ::= TK_IF expression ncl0 then], pop back to state 8.
Parser(B) >> ... then shift 'if', go to state 185
Parser(B) >> Reduce 72 [group ::= if], pop back to state 8.
Parser(B) >> ... then shift 'group', go to state 193
Parser(B) >> Reduce 35 [labeled_instruction ::= group], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_IF', go to state 30
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 30
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_NEQ' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 30.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 30.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 30.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 30.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 30.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 30.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 30.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 30.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Shift 'TK_NEQ', go to state 47
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ]
Parser(B) >> Input 'TK_INTEGER' in state 47
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 47.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 47.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 47.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 47.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 47.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 47.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 47.
Parser(B) >> ... then shift 'concatenation', go to state 59
Parser(B) >> Reduce 213 [comparison ::= comparison TK_NEQ concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 30.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 30.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 30.
Parser(B) >> ... then shift 'expression', go to state 127
Parser(B) >> Shift 'TK_EOC', go to state 206
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression TK_EOC]
Parser(B) >> Input 'TK_THEN' in state 206
Parser(B) >> Reduce 253 [ncl0 ::= TK_EOC] without external action, pop back to state 127.
Parser(B) >> ... then shift 'ncl0', go to state 131
Parser(B) >> Shift 'TK_THEN', go to state 109
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN]
Parser(B) >> Input 'TK_DO' in state 109
Parser(B) >> Reduce 254 [ncl0 ::=] without external action.
Parser(B) >> ... then shift 'ncl0', go to state 15
Parser(B) >> Shift 'TK_DO', go to state 113
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO]
Parser(B) >> Input 'TK_EOC' in state 113
Parser(B) >> Shift 'TK_EOC', go to state 7
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 7
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 7.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 33
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_PLUS' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 33.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Shift 'TK_PLUS', go to state 64
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL addition TK_PLUS]
Parser(B) >> Input 'TK_INTEGER' in state 64
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL addition TK_PLUS TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 64.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 64.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 64.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 64.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 64.
Parser(B) >> ... then shift 'multiplication', go to state 240
Parser(B) >> Reduce 194 [addition ::= addition TK_PLUS multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 7.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 7.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_SAY' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 7.
Parser(B) >> ... then shift 'labeled_instruction', go to state 184
Parser(B) >> Reduce 33 [instruction_list ::= labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_SAY', go to state 22
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_SAY]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 22
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_SAY TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EOC' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 22.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 22.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 22.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 22.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 22.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 22.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 22.
Parser(B) >> ... then shift 'expression', go to state 331
Parser(B) >> Reduce 160 [say ::= TK_SAY expression], pop back to state 10.
Parser(B) >> ... then shift 'say', go to state 365
Parser(B) >> Reduce 60 [keyword_instruction ::= say], pop back to state 10.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 10.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_END' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 10.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_END', go to state 129
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_END]
Parser(B) >> Input 'TK_EOC' in state 129
Parser(B) >> Reduce 73 [simple_do ::= TK_DO TK_EOC instruction_list TK_END], pop back to state 15.
Parser(B) >> ... then shift 'simple_do', go to state 102
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 406
Parser(B) >> Shift 'TK_EOC', go to state 187
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 simple_do junk TK_EOC]
Parser(B) >> Input 'TK_IF' in state 187
Parser(B) >> Reduce 70 [group ::= simple_do junk TK_EOC], pop back to state 15.
Parser(B) >> ... then shift 'group', go to state 182
Parser(B) >> Reduce 41 [instruction ::= group], pop back to state 15.
Parser(B) >> ... then shift 'instruction', go to state 175
Parser(B) >> Reduce 110 [then ::= TK_THEN ncl0 instruction], pop back to state 131.
Parser(B) >> ... then shift 'then', go to state 108
Parser(B) >> Reduce 108 [if ::= TK_IF expression ncl0 then], pop back to state 8.
Parser(B) >> ... then shift 'if', go to state 185
Parser(B) >> Reduce 72 [group ::= if], pop back to state 8.
Parser(B) >> ... then shift 'group', go to state 193
Parser(B) >> Reduce 35 [labeled_instruction ::= group], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_IF', go to state 30
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 30
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_NEQ' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 30.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 30.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 30.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 30.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 30.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 30.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 30.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 30.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Shift 'TK_NEQ', go to state 47
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ]
Parser(B) >> Input 'TK_INTEGER' in state 47
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 47.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 47.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 47.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 47.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 47.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 47.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 47.
Parser(B) >> ... then shift 'concatenation', go to state 59
Parser(B) >> Reduce 213 [comparison ::= comparison TK_NEQ concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 30.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 30.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 30.
Parser(B) >> ... then shift 'expression', go to state 127
Parser(B) >> Shift 'TK_EOC', go to state 206
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression TK_EOC]
Parser(B) >> Input 'TK_THEN' in state 206
Parser(B) >> Reduce 253 [ncl0 ::= TK_EOC] without external action, pop back to state 127.
Parser(B) >> ... then shift 'ncl0', go to state 131
Parser(B) >> Shift 'TK_THEN', go to state 109
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN]
Parser(B) >> Input 'TK_DO' in state 109
Parser(B) >> Reduce 254 [ncl0 ::=] without external action.
Parser(B) >> ... then shift 'ncl0', go to state 15
Parser(B) >> Shift 'TK_DO', go to state 113
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO]
Parser(B) >> Input 'TK_EOC' in state 113
Parser(B) >> Shift 'TK_EOC', go to state 7
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 7
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 7.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 33
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_PLUS' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 33.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Shift 'TK_PLUS', go to state 64
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL addition TK_PLUS]
Parser(B) >> Input 'TK_INTEGER' in state 64
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL addition TK_PLUS TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 64.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 64.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 64.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 64.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 64.
Parser(B) >> ... then shift 'multiplication', go to state 240
Parser(B) >> Reduce 194 [addition ::= addition TK_PLUS multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 7.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 7.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_SAY' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 7.
Parser(B) >> ... then shift 'labeled_instruction', go to state 184
Parser(B) >> Reduce 33 [instruction_list ::= labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_SAY', go to state 22
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_SAY]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 22
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_SAY TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EOC' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 22.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 22.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 22.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 22.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 22.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 22.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 22.
Parser(B) >> ... then shift 'expression', go to state 331
Parser(B) >> Reduce 160 [say ::= TK_SAY expression], pop back to state 10.
Parser(B) >> ... then shift 'say', go to state 365
Parser(B) >> Reduce 60 [keyword_instruction ::= say], pop back to state 10.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 10.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_END' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 10.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_END', go to state 129
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_END]
Parser(B) >> Input 'TK_EOC' in state 129
Parser(B) >> Reduce 73 [simple_do ::= TK_DO TK_EOC instruction_list TK_END], pop back to state 15.
Parser(B) >> ... then shift 'simple_do', go to state 102
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 406
Parser(B) >> Shift 'TK_EOC', go to state 187
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 simple_do junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 187
Parser(B) >> Reduce 70 [group ::= simple_do junk TK_EOC], pop back to state 15.
Parser(B) >> ... then shift 'group', go to state 182
Parser(B) >> Reduce 41 [instruction ::= group], pop back to state 15.
Parser(B) >> ... then shift 'instruction', go to state 175
Parser(B) >> Reduce 110 [then ::= TK_THEN ncl0 instruction], pop back to state 131.
Parser(B) >> ... then shift 'then', go to state 108
Parser(B) >> Reduce 108 [if ::= TK_IF expression ncl0 then], pop back to state 8.
Parser(B) >> ... then shift 'if', go to state 185
Parser(B) >> Reduce 72 [group ::= if], pop back to state 8.
Parser(B) >> ... then shift 'group', go to state 193
Parser(B) >> Reduce 35 [labeled_instruction ::= group], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 8.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_INTEGER' in state 33
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 8.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 8.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_INTEGER' in state 33
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 8.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_IF' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_IF', go to state 30
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 30
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_OPEN_BRACKET' in state 112
Parser(B) >> Shift 'TK_OPEN_BRACKET', go to state 21
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL TK_OPEN_BRACKET]
Parser(B) >> Input 'TK_STRING' in state 21
Parser(B) >> Shift 'TK_STRING', go to state 111
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL TK_OPEN_BRACKET TK_STRING]
Parser(B) >> Input 'TK_COMMA' in state 111
Parser(B) >> Reduce 179 [term ::= TK_STRING], pop back to state 21.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 21.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 21.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 21.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 21.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 21.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 21.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 21.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 21.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 21.
Parser(B) >> ... then shift 'and_expression', go to state 292
Parser(B) >> Reduce 252 [expression_in_list ::= and_expression], pop back to state 21.
Parser(B) >> ... then shift 'expression_in_list', go to state 299
Parser(B) >> Reduce 169 [expression_list ::= expression_in_list], pop back to state 21.
Parser(B) >> ... then shift 'expression_list', go to state 383
Parser(B) >> Shift 'TK_COMMA', go to state 24
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL TK_OPEN_BRACKET expression_list TK_COMMA]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 24
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL TK_OPEN_BRACKET expression_list TK_COMMA TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_COMMA' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 24.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 24.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 24.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 24.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 24.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 24.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 24.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 24.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 24.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 24.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 24.
Parser(B) >> ... then shift 'and_expression', go to state 292
Parser(B) >> Reduce 252 [expression_in_list ::= and_expression], pop back to state 24.
Parser(B) >> ... then shift 'expression_in_list', go to state 298
Parser(B) >> Reduce 170 [expression_list ::= expression_list TK_COMMA expression_in_list], pop back to state 21.
Parser(B) >> ... then shift 'expression_list', go to state 383
Parser(B) >> Shift 'TK_COMMA', go to state 24
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL TK_OPEN_BRACKET expression_list TK_COMMA]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 24
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL TK_OPEN_BRACKET expression_list TK_COMMA TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_CLOSE_BRACKET' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 24.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 24.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 24.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 24.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 24.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 24.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 24.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 24.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 24.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 24.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 24.
Parser(B) >> ... then shift 'and_expression', go to state 292
Parser(B) >> Reduce 252 [expression_in_list ::= and_expression], pop back to state 24.
Parser(B) >> ... then shift 'expression_in_list', go to state 298
Parser(B) >> Reduce 170 [expression_list ::= expression_list TK_COMMA expression_in_list], pop back to state 21.
Parser(B) >> ... then shift 'expression_list', go to state 383
Parser(B) >> Shift 'TK_CLOSE_BRACKET', go to state 207
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL TK_OPEN_BRACKET expression_list TK_CLOSE_BRACKET]
Parser(B) >> Input 'TK_NEQ' in state 207
Parser(B) >> Reduce 175 [function_parameters ::= TK_OPEN_BRACKET expression_list TK_CLOSE_BRACKET], pop back to state 112.
Parser(B) >> ... then shift 'function_parameters', go to state 235
Parser(B) >> Reduce 172 [term ::= TK_VAR_SYMBOL function_parameters], pop back to state 30.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 30.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 30.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 30.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 30.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 30.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 30.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Shift 'TK_NEQ', go to state 47
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ]
Parser(B) >> Input 'TK_INTEGER' in state 47
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 47.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 47.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 47.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 47.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 47.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 47.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 47.
Parser(B) >> ... then shift 'concatenation', go to state 59
Parser(B) >> Reduce 213 [comparison ::= comparison TK_NEQ concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 30.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 30.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 30.
Parser(B) >> ... then shift 'expression', go to state 127
Parser(B) >> Shift 'TK_EOC', go to state 206
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression TK_EOC]
Parser(B) >> Input 'TK_THEN' in state 206
Parser(B) >> Reduce 253 [ncl0 ::= TK_EOC] without external action, pop back to state 127.
Parser(B) >> ... then shift 'ncl0', go to state 131
Parser(B) >> Shift 'TK_THEN', go to state 109
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN]
Parser(B) >> Input 'TK_DO' in state 109
Parser(B) >> Reduce 254 [ncl0 ::=] without external action.
Parser(B) >> ... then shift 'ncl0', go to state 15
Parser(B) >> Shift 'TK_DO', go to state 113
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO]
Parser(B) >> Input 'TK_EOC' in state 113
Parser(B) >> Shift 'TK_EOC', go to state 7
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 7
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 7.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 33
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_PLUS' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 33.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Shift 'TK_PLUS', go to state 64
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL addition TK_PLUS]
Parser(B) >> Input 'TK_INTEGER' in state 64
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL addition TK_PLUS TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 64.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 64.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 64.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 64.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 64.
Parser(B) >> ... then shift 'multiplication', go to state 240
Parser(B) >> Reduce 194 [addition ::= addition TK_PLUS multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 7.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 7.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_SAY' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 7.
Parser(B) >> ... then shift 'labeled_instruction', go to state 184
Parser(B) >> Reduce 33 [instruction_list ::= labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_SAY', go to state 22
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_SAY]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 22
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_SAY TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EOC' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 22.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 22.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 22.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 22.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 22.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 22.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 22.
Parser(B) >> ... then shift 'expression', go to state 331
Parser(B) >> Reduce 160 [say ::= TK_SAY expression], pop back to state 10.
Parser(B) >> ... then shift 'say', go to state 365
Parser(B) >> Reduce 60 [keyword_instruction ::= say], pop back to state 10.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 10.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_END' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 10.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_END', go to state 129
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_END]
Parser(B) >> Input 'TK_EOC' in state 129
Parser(B) >> Reduce 73 [simple_do ::= TK_DO TK_EOC instruction_list TK_END], pop back to state 15.
Parser(B) >> ... then shift 'simple_do', go to state 102
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 406
Parser(B) >> Shift 'TK_EOC', go to state 187
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 simple_do junk TK_EOC]
Parser(B) >> Input 'TK_IF' in state 187
Parser(B) >> Reduce 70 [group ::= simple_do junk TK_EOC], pop back to state 15.
Parser(B) >> ... then shift 'group', go to state 182
Parser(B) >> Reduce 41 [instruction ::= group], pop back to state 15.
Parser(B) >> ... then shift 'instruction', go to state 175
Parser(B) >> Reduce 110 [then ::= TK_THEN ncl0 instruction], pop back to state 131.
Parser(B) >> ... then shift 'then', go to state 108
Parser(B) >> Reduce 108 [if ::= TK_IF expression ncl0 then], pop back to state 8.
Parser(B) >> ... then shift 'if', go to state 185
Parser(B) >> Reduce 72 [group ::= if], pop back to state 8.
Parser(B) >> ... then shift 'group', go to state 193
Parser(B) >> Reduce 35 [labeled_instruction ::= group], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_IF', go to state 30
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 30
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_NEQ' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 30.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 30.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 30.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 30.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 30.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 30.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 30.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 30.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Shift 'TK_NEQ', go to state 47
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ]
Parser(B) >> Input 'TK_INTEGER' in state 47
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 47.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 47.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 47.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 47.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 47.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 47.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 47.
Parser(B) >> ... then shift 'concatenation', go to state 59
Parser(B) >> Reduce 213 [comparison ::= comparison TK_NEQ concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 30.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 30.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 30.
Parser(B) >> ... then shift 'expression', go to state 127
Parser(B) >> Shift 'TK_EOC', go to state 206
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression TK_EOC]
Parser(B) >> Input 'TK_THEN' in state 206
Parser(B) >> Reduce 253 [ncl0 ::= TK_EOC] without external action, pop back to state 127.
Parser(B) >> ... then shift 'ncl0', go to state 131
Parser(B) >> Shift 'TK_THEN', go to state 109
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN]
Parser(B) >> Input 'TK_DO' in state 109
Parser(B) >> Reduce 254 [ncl0 ::=] without external action.
Parser(B) >> ... then shift 'ncl0', go to state 15
Parser(B) >> Shift 'TK_DO', go to state 113
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO]
Parser(B) >> Input 'TK_EOC' in state 113
Parser(B) >> Shift 'TK_EOC', go to state 7
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 7
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 7.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 33
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_PLUS' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 33.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Shift 'TK_PLUS', go to state 64
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL addition TK_PLUS]
Parser(B) >> Input 'TK_INTEGER' in state 64
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL addition TK_PLUS TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 64.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 64.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 64.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 64.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 64.
Parser(B) >> ... then shift 'multiplication', go to state 240
Parser(B) >> Reduce 194 [addition ::= addition TK_PLUS multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 7.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 7.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_SAY' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 7.
Parser(B) >> ... then shift 'labeled_instruction', go to state 184
Parser(B) >> Reduce 33 [instruction_list ::= labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_SAY', go to state 22
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_SAY]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 22
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_SAY TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EOC' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 22.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 22.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 22.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 22.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 22.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 22.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 22.
Parser(B) >> ... then shift 'expression', go to state 331
Parser(B) >> Reduce 160 [say ::= TK_SAY expression], pop back to state 10.
Parser(B) >> ... then shift 'say', go to state 365
Parser(B) >> Reduce 60 [keyword_instruction ::= say], pop back to state 10.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 10.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_END' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 10.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_END', go to state 129
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_END]
Parser(B) >> Input 'TK_EOC' in state 129
Parser(B) >> Reduce 73 [simple_do ::= TK_DO TK_EOC instruction_list TK_END], pop back to state 15.
Parser(B) >> ... then shift 'simple_do', go to state 102
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 406
Parser(B) >> Shift 'TK_EOC', go to state 187
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 simple_do junk TK_EOC]
Parser(B) >> Input 'TK_IF' in state 187
Parser(B) >> Reduce 70 [group ::= simple_do junk TK_EOC], pop back to state 15.
Parser(B) >> ... then shift 'group', go to state 182
Parser(B) >> Reduce 41 [instruction ::= group], pop back to state 15.
Parser(B) >> ... then shift 'instruction', go to state 175
Parser(B) >> Reduce 110 [then ::= TK_THEN ncl0 instruction], pop back to state 131.
Parser(B) >> ... then shift 'then', go to state 108
Parser(B) >> Reduce 108 [if ::= TK_IF expression ncl0 then], pop back to state 8.
Parser(B) >> ... then shift 'if', go to state 185
Parser(B) >> Reduce 72 [group ::= if], pop back to state 8.
Parser(B) >> ... then shift 'group', go to state 193
Parser(B) >> Reduce 35 [labeled_instruction ::= group], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_IF', go to state 30
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 30
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_NEQ' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 30.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 30.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 30.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 30.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 30.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 30.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 30.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 30.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Shift 'TK_NEQ', go to state 47
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ]
Parser(B) >> Input 'TK_INTEGER' in state 47
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 47.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 47.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 47.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 47.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 47.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 47.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 47.
Parser(B) >> ... then shift 'concatenation', go to state 59
Parser(B) >> Reduce 213 [comparison ::= comparison TK_NEQ concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 30.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 30.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 30.
Parser(B) >> ... then shift 'expression', go to state 127
Parser(B) >> Shift 'TK_EOC', go to state 206
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression TK_EOC]
Parser(B) >> Input 'TK_THEN' in state 206
Parser(B) >> Reduce 253 [ncl0 ::= TK_EOC] without external action, pop back to state 127.
Parser(B) >> ... then shift 'ncl0', go to state 131
Parser(B) >> Shift 'TK_THEN', go to state 109
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN]
Parser(B) >> Input 'TK_DO' in state 109
Parser(B) >> Reduce 254 [ncl0 ::=] without external action.
Parser(B) >> ... then shift 'ncl0', go to state 15
Parser(B) >> Shift 'TK_DO', go to state 113
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO]
Parser(B) >> Input 'TK_EOC' in state 113
Parser(B) >> Shift 'TK_EOC', go to state 7
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 7
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 7.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 33
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_PLUS' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 33.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Shift 'TK_PLUS', go to state 64
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL addition TK_PLUS]
Parser(B) >> Input 'TK_INTEGER' in state 64
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL addition TK_PLUS TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 64.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 64.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 64.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 64.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 64.
Parser(B) >> ... then shift 'multiplication', go to state 240
Parser(B) >> Reduce 194 [addition ::= addition TK_PLUS multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 7.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 7.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_SAY' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 7.
Parser(B) >> ... then shift 'labeled_instruction', go to state 184
Parser(B) >> Reduce 33 [instruction_list ::= labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_SAY', go to state 22
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_SAY]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 22
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_SAY TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EOC' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 22.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 22.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 22.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 22.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 22.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 22.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 22.
Parser(B) >> ... then shift 'expression', go to state 331
Parser(B) >> Reduce 160 [say ::= TK_SAY expression], pop back to state 10.
Parser(B) >> ... then shift 'say', go to state 365
Parser(B) >> Reduce 60 [keyword_instruction ::= say], pop back to state 10.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 10.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_END' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 10.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_END', go to state 129
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_END]
Parser(B) >> Input 'TK_EOC' in state 129
Parser(B) >> Reduce 73 [simple_do ::= TK_DO TK_EOC instruction_list TK_END], pop back to state 15.
Parser(B) >> ... then shift 'simple_do', go to state 102
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 406
Parser(B) >> Shift 'TK_EOC', go to state 187
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 simple_do junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 187
Parser(B) >> Reduce 70 [group ::= simple_do junk TK_EOC], pop back to state 15.
Parser(B) >> ... then shift 'group', go to state 182
Parser(B) >> Reduce 41 [instruction ::= group], pop back to state 15.
Parser(B) >> ... then shift 'instruction', go to state 175
Parser(B) >> Reduce 110 [then ::= TK_THEN ncl0 instruction], pop back to state 131.
Parser(B) >> ... then shift 'then', go to state 108
Parser(B) >> Reduce 108 [if ::= TK_IF expression ncl0 then], pop back to state 8.
Parser(B) >> ... then shift 'if', go to state 185
Parser(B) >> Reduce 72 [group ::= if], pop back to state 8.
Parser(B) >> ... then shift 'group', go to state 193
Parser(B) >> Reduce 35 [labeled_instruction ::= group], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 8.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_INTEGER' in state 33
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 8.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 8.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_INTEGER' in state 33
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 8.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_IF' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_IF', go to state 30
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 30
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_OPEN_BRACKET' in state 112
Parser(B) >> Shift 'TK_OPEN_BRACKET', go to state 21
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL TK_OPEN_BRACKET]
Parser(B) >> Input 'TK_STRING' in state 21
Parser(B) >> Shift 'TK_STRING', go to state 111
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL TK_OPEN_BRACKET TK_STRING]
Parser(B) >> Input 'TK_COMMA' in state 111
Parser(B) >> Reduce 179 [term ::= TK_STRING], pop back to state 21.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 21.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 21.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 21.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 21.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 21.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 21.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 21.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 21.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 21.
Parser(B) >> ... then shift 'and_expression', go to state 292
Parser(B) >> Reduce 252 [expression_in_list ::= and_expression], pop back to state 21.
Parser(B) >> ... then shift 'expression_in_list', go to state 299
Parser(B) >> Reduce 169 [expression_list ::= expression_in_list], pop back to state 21.
Parser(B) >> ... then shift 'expression_list', go to state 383
Parser(B) >> Shift 'TK_COMMA', go to state 24
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL TK_OPEN_BRACKET expression_list TK_COMMA]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 24
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL TK_OPEN_BRACKET expression_list TK_COMMA TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_COMMA' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 24.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 24.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 24.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 24.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 24.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 24.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 24.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 24.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 24.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 24.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 24.
Parser(B) >> ... then shift 'and_expression', go to state 292
Parser(B) >> Reduce 252 [expression_in_list ::= and_expression], pop back to state 24.
Parser(B) >> ... then shift 'expression_in_list', go to state 298
Parser(B) >> Reduce 170 [expression_list ::= expression_list TK_COMMA expression_in_list], pop back to state 21.
Parser(B) >> ... then shift 'expression_list', go to state 383
Parser(B) >> Shift 'TK_COMMA', go to state 24
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL TK_OPEN_BRACKET expression_list TK_COMMA]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 24
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL TK_OPEN_BRACKET expression_list TK_COMMA TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_CLOSE_BRACKET' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 24.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 24.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 24.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 24.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 24.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 24.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 24.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 24.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 24.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 24.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 24.
Parser(B) >> ... then shift 'and_expression', go to state 292
Parser(B) >> Reduce 252 [expression_in_list ::= and_expression], pop back to state 24.
Parser(B) >> ... then shift 'expression_in_list', go to state 298
Parser(B) >> Reduce 170 [expression_list ::= expression_list TK_COMMA expression_in_list], pop back to state 21.
Parser(B) >> ... then shift 'expression_list', go to state 383
Parser(B) >> Shift 'TK_CLOSE_BRACKET', go to state 207
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL TK_OPEN_BRACKET expression_list TK_CLOSE_BRACKET]
Parser(B) >> Input 'TK_NEQ' in state 207
Parser(B) >> Reduce 175 [function_parameters ::= TK_OPEN_BRACKET expression_list TK_CLOSE_BRACKET], pop back to state 112.
Parser(B) >> ... then shift 'function_parameters', go to state 235
Parser(B) >> Reduce 172 [term ::= TK_VAR_SYMBOL function_parameters], pop back to state 30.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 30.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 30.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 30.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 30.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 30.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 30.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Shift 'TK_NEQ', go to state 47
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ]
Parser(B) >> Input 'TK_INTEGER' in state 47
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 47.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 47.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 47.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 47.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 47.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 47.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 47.
Parser(B) >> ... then shift 'concatenation', go to state 59
Parser(B) >> Reduce 213 [comparison ::= comparison TK_NEQ concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 30.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 30.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 30.
Parser(B) >> ... then shift 'expression', go to state 127
Parser(B) >> Shift 'TK_EOC', go to state 206
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression TK_EOC]
Parser(B) >> Input 'TK_THEN' in state 206
Parser(B) >> Reduce 253 [ncl0 ::= TK_EOC] without external action, pop back to state 127.
Parser(B) >> ... then shift 'ncl0', go to state 131
Parser(B) >> Shift 'TK_THEN', go to state 109
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN]
Parser(B) >> Input 'TK_DO' in state 109
Parser(B) >> Reduce 254 [ncl0 ::=] without external action.
Parser(B) >> ... then shift 'ncl0', go to state 15
Parser(B) >> Shift 'TK_DO', go to state 113
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO]
Parser(B) >> Input 'TK_EOC' in state 113
Parser(B) >> Shift 'TK_EOC', go to state 7
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 7
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 7.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 33
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_PLUS' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 33.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Shift 'TK_PLUS', go to state 64
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL addition TK_PLUS]
Parser(B) >> Input 'TK_INTEGER' in state 64
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL addition TK_PLUS TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 64.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 64.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 64.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 64.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 64.
Parser(B) >> ... then shift 'multiplication', go to state 240
Parser(B) >> Reduce 194 [addition ::= addition TK_PLUS multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 7.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 7.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_SAY' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 7.
Parser(B) >> ... then shift 'labeled_instruction', go to state 184
Parser(B) >> Reduce 33 [instruction_list ::= labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_SAY', go to state 22
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_SAY]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 22
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_SAY TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EOC' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 22.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 22.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 22.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 22.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 22.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 22.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 22.
Parser(B) >> ... then shift 'expression', go to state 331
Parser(B) >> Reduce 160 [say ::= TK_SAY expression], pop back to state 10.
Parser(B) >> ... then shift 'say', go to state 365
Parser(B) >> Reduce 60 [keyword_instruction ::= say], pop back to state 10.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 10.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_END' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 10.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_END', go to state 129
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_END]
Parser(B) >> Input 'TK_EOC' in state 129
Parser(B) >> Reduce 73 [simple_do ::= TK_DO TK_EOC instruction_list TK_END], pop back to state 15.
Parser(B) >> ... then shift 'simple_do', go to state 102
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 406
Parser(B) >> Shift 'TK_EOC', go to state 187
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 simple_do junk TK_EOC]
Parser(B) >> Input 'TK_IF' in state 187
Parser(B) >> Reduce 70 [group ::= simple_do junk TK_EOC], pop back to state 15.
Parser(B) >> ... then shift 'group', go to state 182
Parser(B) >> Reduce 41 [instruction ::= group], pop back to state 15.
Parser(B) >> ... then shift 'instruction', go to state 175
Parser(B) >> Reduce 110 [then ::= TK_THEN ncl0 instruction], pop back to state 131.
Parser(B) >> ... then shift 'then', go to state 108
Parser(B) >> Reduce 108 [if ::= TK_IF expression ncl0 then], pop back to state 8.
Parser(B) >> ... then shift 'if', go to state 185
Parser(B) >> Reduce 72 [group ::= if], pop back to state 8.
Parser(B) >> ... then shift 'group', go to state 193
Parser(B) >> Reduce 35 [labeled_instruction ::= group], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_IF', go to state 30
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 30
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_NEQ' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 30.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 30.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 30.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 30.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 30.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 30.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 30.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 30.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Shift 'TK_NEQ', go to state 47
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ]
Parser(B) >> Input 'TK_INTEGER' in state 47
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 47.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 47.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 47.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 47.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 47.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 47.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 47.
Parser(B) >> ... then shift 'concatenation', go to state 59
Parser(B) >> Reduce 213 [comparison ::= comparison TK_NEQ concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 30.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 30.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 30.
Parser(B) >> ... then shift 'expression', go to state 127
Parser(B) >> Shift 'TK_EOC', go to state 206
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression TK_EOC]
Parser(B) >> Input 'TK_THEN' in state 206
Parser(B) >> Reduce 253 [ncl0 ::= TK_EOC] without external action, pop back to state 127.
Parser(B) >> ... then shift 'ncl0', go to state 131
Parser(B) >> Shift 'TK_THEN', go to state 109
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN]
Parser(B) >> Input 'TK_DO' in state 109
Parser(B) >> Reduce 254 [ncl0 ::=] without external action.
Parser(B) >> ... then shift 'ncl0', go to state 15
Parser(B) >> Shift 'TK_DO', go to state 113
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO]
Parser(B) >> Input 'TK_EOC' in state 113
Parser(B) >> Shift 'TK_EOC', go to state 7
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 7
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 7.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 33
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_PLUS' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 33.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Shift 'TK_PLUS', go to state 64
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL addition TK_PLUS]
Parser(B) >> Input 'TK_INTEGER' in state 64
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL addition TK_PLUS TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 64.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 64.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 64.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 64.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 64.
Parser(B) >> ... then shift 'multiplication', go to state 240
Parser(B) >> Reduce 194 [addition ::= addition TK_PLUS multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 7.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 7.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_SAY' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 7.
Parser(B) >> ... then shift 'labeled_instruction', go to state 184
Parser(B) >> Reduce 33 [instruction_list ::= labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_SAY', go to state 22
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_SAY]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 22
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_SAY TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EOC' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 22.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 22.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 22.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 22.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 22.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 22.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 22.
Parser(B) >> ... then shift 'expression', go to state 331
Parser(B) >> Reduce 160 [say ::= TK_SAY expression], pop back to state 10.
Parser(B) >> ... then shift 'say', go to state 365
Parser(B) >> Reduce 60 [keyword_instruction ::= say], pop back to state 10.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 10.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_END' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 10.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_END', go to state 129
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_END]
Parser(B) >> Input 'TK_EOC' in state 129
Parser(B) >> Reduce 73 [simple_do ::= TK_DO TK_EOC instruction_list TK_END], pop back to state 15.
Parser(B) >> ... then shift 'simple_do', go to state 102
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 406
Parser(B) >> Shift 'TK_EOC', go to state 187
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 simple_do junk TK_EOC]
Parser(B) >> Input 'TK_IF' in state 187
Parser(B) >> Reduce 70 [group ::= simple_do junk TK_EOC], pop back to state 15.
Parser(B) >> ... then shift 'group', go to state 182
Parser(B) >> Reduce 41 [instruction ::= group], pop back to state 15.
Parser(B) >> ... then shift 'instruction', go to state 175
Parser(B) >> Reduce 110 [then ::= TK_THEN ncl0 instruction], pop back to state 131.
Parser(B) >> ... then shift 'then', go to state 108
Parser(B) >> Reduce 108 [if ::= TK_IF expression ncl0 then], pop back to state 8.
Parser(B) >> ... then shift 'if', go to state 185
Parser(B) >> Reduce 72 [group ::= if], pop back to state 8.
Parser(B) >> ... then shift 'group', go to state 193
Parser(B) >> Reduce 35 [labeled_instruction ::= group], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_IF', go to state 30
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 30
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_NEQ' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 30.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 30.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 30.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 30.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 30.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 30.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 30.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 30.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Shift 'TK_NEQ', go to state 47
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ]
Parser(B) >> Input 'TK_INTEGER' in state 47
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 47.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 47.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 47.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 47.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 47.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 47.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 47.
Parser(B) >> ... then shift 'concatenation', go to state 59
Parser(B) >> Reduce 213 [comparison ::= comparison TK_NEQ concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 30.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 30.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 30.
Parser(B) >> ... then shift 'expression', go to state 127
Parser(B) >> Shift 'TK_EOC', go to state 206
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression TK_EOC]
Parser(B) >> Input 'TK_THEN' in state 206
Parser(B) >> Reduce 253 [ncl0 ::= TK_EOC] without external action, pop back to state 127.
Parser(B) >> ... then shift 'ncl0', go to state 131
Parser(B) >> Shift 'TK_THEN', go to state 109
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN]
Parser(B) >> Input 'TK_DO' in state 109
Parser(B) >> Reduce 254 [ncl0 ::=] without external action.
Parser(B) >> ... then shift 'ncl0', go to state 15
Parser(B) >> Shift 'TK_DO', go to state 113
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO]
Parser(B) >> Input 'TK_EOC' in state 113
Parser(B) >> Shift 'TK_EOC', go to state 7
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 7
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 7.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 33
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_PLUS' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 33.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Shift 'TK_PLUS', go to state 64
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL addition TK_PLUS]
Parser(B) >> Input 'TK_INTEGER' in state 64
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL addition TK_PLUS TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 64.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 64.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 64.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 64.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 64.
Parser(B) >> ... then shift 'multiplication', go to state 240
Parser(B) >> Reduce 194 [addition ::= addition TK_PLUS multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 7.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 7.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_SAY' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 7.
Parser(B) >> ... then shift 'labeled_instruction', go to state 184
Parser(B) >> Reduce 33 [instruction_list ::= labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_SAY', go to state 22
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_SAY]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 22
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_SAY TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EOC' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 22.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 22.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 22.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 22.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 22.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 22.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 22.
Parser(B) >> ... then shift 'expression', go to state 331
Parser(B) >> Reduce 160 [say ::= TK_SAY expression], pop back to state 10.
Parser(B) >> ... then shift 'say', go to state 365
Parser(B) >> Reduce 60 [keyword_instruction ::= say], pop back to state 10.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 10.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_END' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 10.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_END', go to state 129
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_END]
Parser(B) >> Input 'TK_EOC' in state 129
Parser(B) >> Reduce 73 [simple_do ::= TK_DO TK_EOC instruction_list TK_END], pop back to state 15.
Parser(B) >> ... then shift 'simple_do', go to state 102
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 406
Parser(B) >> Shift 'TK_EOC', go to state 187
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 simple_do junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 187
Parser(B) >> Reduce 70 [group ::= simple_do junk TK_EOC], pop back to state 15.
Parser(B) >> ... then shift 'group', go to state 182
Parser(B) >> Reduce 41 [instruction ::= group], pop back to state 15.
Parser(B) >> ... then shift 'instruction', go to state 175
Parser(B) >> Reduce 110 [then ::= TK_THEN ncl0 instruction], pop back to state 131.
Parser(B) >> ... then shift 'then', go to state 108
Parser(B) >> Reduce 108 [if ::= TK_IF expression ncl0 then], pop back to state 8.
Parser(B) >> ... then shift 'if', go to state 185
Parser(B) >> Reduce 72 [group ::= if], pop back to state 8.
Parser(B) >> ... then shift 'group', go to state 193
Parser(B) >> Reduce 35 [labeled_instruction ::= group], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 8.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_STRING' in state 33
Parser(B) >> Shift 'TK_STRING', go to state 111
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL TK_STRING]
Parser(B) >> Input 'TK_EOC' in state 111
Parser(B) >> Reduce 179 [term ::= TK_STRING], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 8.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 8.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_INTEGER' in state 33
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 8.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 8.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_INTEGER' in state 33
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 8.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_IF' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_IF', go to state 30
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 30
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_OPEN_BRACKET' in state 112
Parser(B) >> Shift 'TK_OPEN_BRACKET', go to state 21
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL TK_OPEN_BRACKET]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 21
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL TK_OPEN_BRACKET TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_COMMA' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 21.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 21.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 21.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 21.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 21.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 21.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 21.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 21.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 21.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 21.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 21.
Parser(B) >> ... then shift 'and_expression', go to state 292
Parser(B) >> Reduce 252 [expression_in_list ::= and_expression], pop back to state 21.
Parser(B) >> ... then shift 'expression_in_list', go to state 299
Parser(B) >> Reduce 169 [expression_list ::= expression_in_list], pop back to state 21.
Parser(B) >> ... then shift 'expression_list', go to state 383
Parser(B) >> Shift 'TK_COMMA', go to state 24
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL TK_OPEN_BRACKET expression_list TK_COMMA]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 24
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL TK_OPEN_BRACKET expression_list TK_COMMA TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_COMMA' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 24.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 24.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 24.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 24.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 24.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 24.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 24.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 24.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 24.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 24.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 24.
Parser(B) >> ... then shift 'and_expression', go to state 292
Parser(B) >> Reduce 252 [expression_in_list ::= and_expression], pop back to state 24.
Parser(B) >> ... then shift 'expression_in_list', go to state 298
Parser(B) >> Reduce 170 [expression_list ::= expression_list TK_COMMA expression_in_list], pop back to state 21.
Parser(B) >> ... then shift 'expression_list', go to state 383
Parser(B) >> Shift 'TK_COMMA', go to state 24
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL TK_OPEN_BRACKET expression_list TK_COMMA]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 24
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL TK_OPEN_BRACKET expression_list TK_COMMA TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_CLOSE_BRACKET' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 24.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 24.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 24.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 24.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 24.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 24.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 24.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 24.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 24.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 24.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 24.
Parser(B) >> ... then shift 'and_expression', go to state 292
Parser(B) >> Reduce 252 [expression_in_list ::= and_expression], pop back to state 24.
Parser(B) >> ... then shift 'expression_in_list', go to state 298
Parser(B) >> Reduce 170 [expression_list ::= expression_list TK_COMMA expression_in_list], pop back to state 21.
Parser(B) >> ... then shift 'expression_list', go to state 383
Parser(B) >> Shift 'TK_CLOSE_BRACKET', go to state 207
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL TK_OPEN_BRACKET expression_list TK_CLOSE_BRACKET]
Parser(B) >> Input 'TK_NEQ' in state 207
Parser(B) >> Reduce 175 [function_parameters ::= TK_OPEN_BRACKET expression_list TK_CLOSE_BRACKET], pop back to state 112.
Parser(B) >> ... then shift 'function_parameters', go to state 235
Parser(B) >> Reduce 172 [term ::= TK_VAR_SYMBOL function_parameters], pop back to state 30.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 30.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 30.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 30.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 30.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 30.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 30.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Shift 'TK_NEQ', go to state 47
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ]
Parser(B) >> Input 'TK_INTEGER' in state 47
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 47.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 47.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 47.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 47.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 47.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 47.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 47.
Parser(B) >> ... then shift 'concatenation', go to state 59
Parser(B) >> Reduce 213 [comparison ::= comparison TK_NEQ concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 30.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 30.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 30.
Parser(B) >> ... then shift 'expression', go to state 127
Parser(B) >> Shift 'TK_EOC', go to state 206
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression TK_EOC]
Parser(B) >> Input 'TK_THEN' in state 206
Parser(B) >> Reduce 253 [ncl0 ::= TK_EOC] without external action, pop back to state 127.
Parser(B) >> ... then shift 'ncl0', go to state 131
Parser(B) >> Shift 'TK_THEN', go to state 109
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN]
Parser(B) >> Input 'TK_DO' in state 109
Parser(B) >> Reduce 254 [ncl0 ::=] without external action.
Parser(B) >> ... then shift 'ncl0', go to state 15
Parser(B) >> Shift 'TK_DO', go to state 113
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO]
Parser(B) >> Input 'TK_EOC' in state 113
Parser(B) >> Shift 'TK_EOC', go to state 7
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 7
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 7.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 33
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_PLUS' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 33.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Shift 'TK_PLUS', go to state 64
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL addition TK_PLUS]
Parser(B) >> Input 'TK_INTEGER' in state 64
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL addition TK_PLUS TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 64.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 64.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 64.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 64.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 64.
Parser(B) >> ... then shift 'multiplication', go to state 240
Parser(B) >> Reduce 194 [addition ::= addition TK_PLUS multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 7.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 7.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_SAY' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 7.
Parser(B) >> ... then shift 'labeled_instruction', go to state 184
Parser(B) >> Reduce 33 [instruction_list ::= labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_SAY', go to state 22
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_SAY]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 22
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_SAY TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EOC' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 22.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 22.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 22.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 22.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 22.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 22.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 22.
Parser(B) >> ... then shift 'expression', go to state 331
Parser(B) >> Reduce 160 [say ::= TK_SAY expression], pop back to state 10.
Parser(B) >> ... then shift 'say', go to state 365
Parser(B) >> Reduce 60 [keyword_instruction ::= say], pop back to state 10.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 10.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_END' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 10.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_END', go to state 129
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_END]
Parser(B) >> Input 'TK_EOC' in state 129
Parser(B) >> Reduce 73 [simple_do ::= TK_DO TK_EOC instruction_list TK_END], pop back to state 15.
Parser(B) >> ... then shift 'simple_do', go to state 102
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 406
Parser(B) >> Shift 'TK_EOC', go to state 187
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 simple_do junk TK_EOC]
Parser(B) >> Input 'TK_IF' in state 187
Parser(B) >> Reduce 70 [group ::= simple_do junk TK_EOC], pop back to state 15.
Parser(B) >> ... then shift 'group', go to state 182
Parser(B) >> Reduce 41 [instruction ::= group], pop back to state 15.
Parser(B) >> ... then shift 'instruction', go to state 175
Parser(B) >> Reduce 110 [then ::= TK_THEN ncl0 instruction], pop back to state 131.
Parser(B) >> ... then shift 'then', go to state 108
Parser(B) >> Reduce 108 [if ::= TK_IF expression ncl0 then], pop back to state 8.
Parser(B) >> ... then shift 'if', go to state 185
Parser(B) >> Reduce 72 [group ::= if], pop back to state 8.
Parser(B) >> ... then shift 'group', go to state 193
Parser(B) >> Reduce 35 [labeled_instruction ::= group], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_IF', go to state 30
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 30
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_NEQ' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 30.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 30.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 30.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 30.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 30.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 30.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 30.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 30.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Shift 'TK_NEQ', go to state 47
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ]
Parser(B) >> Input 'TK_INTEGER' in state 47
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 47.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 47.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 47.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 47.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 47.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 47.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 47.
Parser(B) >> ... then shift 'concatenation', go to state 59
Parser(B) >> Reduce 213 [comparison ::= comparison TK_NEQ concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 30.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 30.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 30.
Parser(B) >> ... then shift 'expression', go to state 127
Parser(B) >> Shift 'TK_EOC', go to state 206
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression TK_EOC]
Parser(B) >> Input 'TK_THEN' in state 206
Parser(B) >> Reduce 253 [ncl0 ::= TK_EOC] without external action, pop back to state 127.
Parser(B) >> ... then shift 'ncl0', go to state 131
Parser(B) >> Shift 'TK_THEN', go to state 109
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN]
Parser(B) >> Input 'TK_DO' in state 109
Parser(B) >> Reduce 254 [ncl0 ::=] without external action.
Parser(B) >> ... then shift 'ncl0', go to state 15
Parser(B) >> Shift 'TK_DO', go to state 113
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO]
Parser(B) >> Input 'TK_EOC' in state 113
Parser(B) >> Shift 'TK_EOC', go to state 7
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 7
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 7.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 33
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_PLUS' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 33.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Shift 'TK_PLUS', go to state 64
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL addition TK_PLUS]
Parser(B) >> Input 'TK_INTEGER' in state 64
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL addition TK_PLUS TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 64.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 64.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 64.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 64.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 64.
Parser(B) >> ... then shift 'multiplication', go to state 240
Parser(B) >> Reduce 194 [addition ::= addition TK_PLUS multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 7.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 7.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_SAY' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 7.
Parser(B) >> ... then shift 'labeled_instruction', go to state 184
Parser(B) >> Reduce 33 [instruction_list ::= labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_SAY', go to state 22
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_SAY]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 22
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_SAY TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EOC' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 22.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 22.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 22.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 22.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 22.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 22.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 22.
Parser(B) >> ... then shift 'expression', go to state 331
Parser(B) >> Reduce 160 [say ::= TK_SAY expression], pop back to state 10.
Parser(B) >> ... then shift 'say', go to state 365
Parser(B) >> Reduce 60 [keyword_instruction ::= say], pop back to state 10.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 10.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_END' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 10.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_END', go to state 129
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_END]
Parser(B) >> Input 'TK_EOC' in state 129
Parser(B) >> Reduce 73 [simple_do ::= TK_DO TK_EOC instruction_list TK_END], pop back to state 15.
Parser(B) >> ... then shift 'simple_do', go to state 102
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 406
Parser(B) >> Shift 'TK_EOC', go to state 187
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 simple_do junk TK_EOC]
Parser(B) >> Input 'TK_IF' in state 187
Parser(B) >> Reduce 70 [group ::= simple_do junk TK_EOC], pop back to state 15.
Parser(B) >> ... then shift 'group', go to state 182
Parser(B) >> Reduce 41 [instruction ::= group], pop back to state 15.
Parser(B) >> ... then shift 'instruction', go to state 175
Parser(B) >> Reduce 110 [then ::= TK_THEN ncl0 instruction], pop back to state 131.
Parser(B) >> ... then shift 'then', go to state 108
Parser(B) >> Reduce 108 [if ::= TK_IF expression ncl0 then], pop back to state 8.
Parser(B) >> ... then shift 'if', go to state 185
Parser(B) >> Reduce 72 [group ::= if], pop back to state 8.
Parser(B) >> ... then shift 'group', go to state 193
Parser(B) >> Reduce 35 [labeled_instruction ::= group], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_IF', go to state 30
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 30
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_NEQ' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 30.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 30.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 30.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 30.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 30.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 30.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 30.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 30.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Shift 'TK_NEQ', go to state 47
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ]
Parser(B) >> Input 'TK_INTEGER' in state 47
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 47.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 47.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 47.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 47.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 47.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 47.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 47.
Parser(B) >> ... then shift 'concatenation', go to state 59
Parser(B) >> Reduce 213 [comparison ::= comparison TK_NEQ concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 30.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 30.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 30.
Parser(B) >> ... then shift 'expression', go to state 127
Parser(B) >> Shift 'TK_EOC', go to state 206
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression TK_EOC]
Parser(B) >> Input 'TK_THEN' in state 206
Parser(B) >> Reduce 253 [ncl0 ::= TK_EOC] without external action, pop back to state 127.
Parser(B) >> ... then shift 'ncl0', go to state 131
Parser(B) >> Shift 'TK_THEN', go to state 109
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN]
Parser(B) >> Input 'TK_DO' in state 109
Parser(B) >> Reduce 254 [ncl0 ::=] without external action.
Parser(B) >> ... then shift 'ncl0', go to state 15
Parser(B) >> Shift 'TK_DO', go to state 113
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO]
Parser(B) >> Input 'TK_EOC' in state 113
Parser(B) >> Shift 'TK_EOC', go to state 7
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 7
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 7.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 33
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_PLUS' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 33.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Shift 'TK_PLUS', go to state 64
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL addition TK_PLUS]
Parser(B) >> Input 'TK_INTEGER' in state 64
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL addition TK_PLUS TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 64.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 64.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 64.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 64.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 64.
Parser(B) >> ... then shift 'multiplication', go to state 240
Parser(B) >> Reduce 194 [addition ::= addition TK_PLUS multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 7.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 7.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_SAY' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 7.
Parser(B) >> ... then shift 'labeled_instruction', go to state 184
Parser(B) >> Reduce 33 [instruction_list ::= labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_SAY', go to state 22
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_SAY]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 22
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_SAY TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EOC' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 22.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 22.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 22.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 22.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 22.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 22.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 22.
Parser(B) >> ... then shift 'expression', go to state 331
Parser(B) >> Reduce 160 [say ::= TK_SAY expression], pop back to state 10.
Parser(B) >> ... then shift 'say', go to state 365
Parser(B) >> Reduce 60 [keyword_instruction ::= say], pop back to state 10.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 10.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_END' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 10.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_END', go to state 129
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_END]
Parser(B) >> Input 'TK_EOC' in state 129
Parser(B) >> Reduce 73 [simple_do ::= TK_DO TK_EOC instruction_list TK_END], pop back to state 15.
Parser(B) >> ... then shift 'simple_do', go to state 102
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 406
Parser(B) >> Shift 'TK_EOC', go to state 187
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 simple_do junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 187
Parser(B) >> Reduce 70 [group ::= simple_do junk TK_EOC], pop back to state 15.
Parser(B) >> ... then shift 'group', go to state 182
Parser(B) >> Reduce 41 [instruction ::= group], pop back to state 15.
Parser(B) >> ... then shift 'instruction', go to state 175
Parser(B) >> Reduce 110 [then ::= TK_THEN ncl0 instruction], pop back to state 131.
Parser(B) >> ... then shift 'then', go to state 108
Parser(B) >> Reduce 108 [if ::= TK_IF expression ncl0 then], pop back to state 8.
Parser(B) >> ... then shift 'if', go to state 185
Parser(B) >> Reduce 72 [group ::= if], pop back to state 8.
Parser(B) >> ... then shift 'group', go to state 193
Parser(B) >> Reduce 35 [labeled_instruction ::= group], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 8.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_INTEGER' in state 33
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 8.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 8.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_INTEGER' in state 33
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 8.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_IF' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_IF', go to state 30
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 30
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_OPEN_BRACKET' in state 112
Parser(B) >> Shift 'TK_OPEN_BRACKET', go to state 21
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL TK_OPEN_BRACKET]
Parser(B) >> Input 'TK_STRING' in state 21
Parser(B) >> Shift 'TK_STRING', go to state 111
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL TK_OPEN_BRACKET TK_STRING]
Parser(B) >> Input 'TK_COMMA' in state 111
Parser(B) >> Reduce 179 [term ::= TK_STRING], pop back to state 21.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 21.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 21.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 21.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 21.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 21.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 21.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 21.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 21.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 21.
Parser(B) >> ... then shift 'and_expression', go to state 292
Parser(B) >> Reduce 252 [expression_in_list ::= and_expression], pop back to state 21.
Parser(B) >> ... then shift 'expression_in_list', go to state 299
Parser(B) >> Reduce 169 [expression_list ::= expression_in_list], pop back to state 21.
Parser(B) >> ... then shift 'expression_list', go to state 383
Parser(B) >> Shift 'TK_COMMA', go to state 24
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL TK_OPEN_BRACKET expression_list TK_COMMA]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 24
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL TK_OPEN_BRACKET expression_list TK_COMMA TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_COMMA' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 24.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 24.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 24.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 24.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 24.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 24.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 24.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 24.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 24.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 24.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 24.
Parser(B) >> ... then shift 'and_expression', go to state 292
Parser(B) >> Reduce 252 [expression_in_list ::= and_expression], pop back to state 24.
Parser(B) >> ... then shift 'expression_in_list', go to state 298
Parser(B) >> Reduce 170 [expression_list ::= expression_list TK_COMMA expression_in_list], pop back to state 21.
Parser(B) >> ... then shift 'expression_list', go to state 383
Parser(B) >> Shift 'TK_COMMA', go to state 24
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL TK_OPEN_BRACKET expression_list TK_COMMA]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 24
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL TK_OPEN_BRACKET expression_list TK_COMMA TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_CLOSE_BRACKET' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 24.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 24.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 24.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 24.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 24.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 24.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 24.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 24.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 24.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 24.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 24.
Parser(B) >> ... then shift 'and_expression', go to state 292
Parser(B) >> Reduce 252 [expression_in_list ::= and_expression], pop back to state 24.
Parser(B) >> ... then shift 'expression_in_list', go to state 298
Parser(B) >> Reduce 170 [expression_list ::= expression_list TK_COMMA expression_in_list], pop back to state 21.
Parser(B) >> ... then shift 'expression_list', go to state 383
Parser(B) >> Shift 'TK_CLOSE_BRACKET', go to state 207
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL TK_OPEN_BRACKET expression_list TK_CLOSE_BRACKET]
Parser(B) >> Input 'TK_NEQ' in state 207
Parser(B) >> Reduce 175 [function_parameters ::= TK_OPEN_BRACKET expression_list TK_CLOSE_BRACKET], pop back to state 112.
Parser(B) >> ... then shift 'function_parameters', go to state 235
Parser(B) >> Reduce 172 [term ::= TK_VAR_SYMBOL function_parameters], pop back to state 30.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 30.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 30.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 30.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 30.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 30.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 30.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Shift 'TK_NEQ', go to state 47
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ]
Parser(B) >> Input 'TK_INTEGER' in state 47
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 47.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 47.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 47.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 47.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 47.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 47.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 47.
Parser(B) >> ... then shift 'concatenation', go to state 59
Parser(B) >> Reduce 213 [comparison ::= comparison TK_NEQ concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 30.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 30.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 30.
Parser(B) >> ... then shift 'expression', go to state 127
Parser(B) >> Shift 'TK_EOC', go to state 206
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression TK_EOC]
Parser(B) >> Input 'TK_THEN' in state 206
Parser(B) >> Reduce 253 [ncl0 ::= TK_EOC] without external action, pop back to state 127.
Parser(B) >> ... then shift 'ncl0', go to state 131
Parser(B) >> Shift 'TK_THEN', go to state 109
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN]
Parser(B) >> Input 'TK_DO' in state 109
Parser(B) >> Reduce 254 [ncl0 ::=] without external action.
Parser(B) >> ... then shift 'ncl0', go to state 15
Parser(B) >> Shift 'TK_DO', go to state 113
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO]
Parser(B) >> Input 'TK_EOC' in state 113
Parser(B) >> Shift 'TK_EOC', go to state 7
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 7
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 7.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 33
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_PLUS' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 33.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Shift 'TK_PLUS', go to state 64
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL addition TK_PLUS]
Parser(B) >> Input 'TK_INTEGER' in state 64
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL addition TK_PLUS TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 64.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 64.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 64.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 64.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 64.
Parser(B) >> ... then shift 'multiplication', go to state 240
Parser(B) >> Reduce 194 [addition ::= addition TK_PLUS multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 7.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 7.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_SAY' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 7.
Parser(B) >> ... then shift 'labeled_instruction', go to state 184
Parser(B) >> Reduce 33 [instruction_list ::= labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_SAY', go to state 22
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_SAY]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 22
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_SAY TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EOC' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 22.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 22.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 22.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 22.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 22.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 22.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 22.
Parser(B) >> ... then shift 'expression', go to state 331
Parser(B) >> Reduce 160 [say ::= TK_SAY expression], pop back to state 10.
Parser(B) >> ... then shift 'say', go to state 365
Parser(B) >> Reduce 60 [keyword_instruction ::= say], pop back to state 10.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 10.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_END' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 10.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_END', go to state 129
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_END]
Parser(B) >> Input 'TK_EOC' in state 129
Parser(B) >> Reduce 73 [simple_do ::= TK_DO TK_EOC instruction_list TK_END], pop back to state 15.
Parser(B) >> ... then shift 'simple_do', go to state 102
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 406
Parser(B) >> Shift 'TK_EOC', go to state 187
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 simple_do junk TK_EOC]
Parser(B) >> Input 'TK_IF' in state 187
Parser(B) >> Reduce 70 [group ::= simple_do junk TK_EOC], pop back to state 15.
Parser(B) >> ... then shift 'group', go to state 182
Parser(B) >> Reduce 41 [instruction ::= group], pop back to state 15.
Parser(B) >> ... then shift 'instruction', go to state 175
Parser(B) >> Reduce 110 [then ::= TK_THEN ncl0 instruction], pop back to state 131.
Parser(B) >> ... then shift 'then', go to state 108
Parser(B) >> Reduce 108 [if ::= TK_IF expression ncl0 then], pop back to state 8.
Parser(B) >> ... then shift 'if', go to state 185
Parser(B) >> Reduce 72 [group ::= if], pop back to state 8.
Parser(B) >> ... then shift 'group', go to state 193
Parser(B) >> Reduce 35 [labeled_instruction ::= group], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_IF', go to state 30
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 30
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_NEQ' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 30.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 30.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 30.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 30.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 30.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 30.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 30.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 30.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Shift 'TK_NEQ', go to state 47
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ]
Parser(B) >> Input 'TK_INTEGER' in state 47
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 47.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 47.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 47.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 47.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 47.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 47.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 47.
Parser(B) >> ... then shift 'concatenation', go to state 59
Parser(B) >> Reduce 213 [comparison ::= comparison TK_NEQ concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 30.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 30.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 30.
Parser(B) >> ... then shift 'expression', go to state 127
Parser(B) >> Shift 'TK_EOC', go to state 206
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression TK_EOC]
Parser(B) >> Input 'TK_THEN' in state 206
Parser(B) >> Reduce 253 [ncl0 ::= TK_EOC] without external action, pop back to state 127.
Parser(B) >> ... then shift 'ncl0', go to state 131
Parser(B) >> Shift 'TK_THEN', go to state 109
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN]
Parser(B) >> Input 'TK_DO' in state 109
Parser(B) >> Reduce 254 [ncl0 ::=] without external action.
Parser(B) >> ... then shift 'ncl0', go to state 15
Parser(B) >> Shift 'TK_DO', go to state 113
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO]
Parser(B) >> Input 'TK_EOC' in state 113
Parser(B) >> Shift 'TK_EOC', go to state 7
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 7
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 7.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 33
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_PLUS' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 33.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Shift 'TK_PLUS', go to state 64
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL addition TK_PLUS]
Parser(B) >> Input 'TK_INTEGER' in state 64
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL addition TK_PLUS TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 64.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 64.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 64.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 64.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 64.
Parser(B) >> ... then shift 'multiplication', go to state 240
Parser(B) >> Reduce 194 [addition ::= addition TK_PLUS multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 7.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 7.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_SAY' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 7.
Parser(B) >> ... then shift 'labeled_instruction', go to state 184
Parser(B) >> Reduce 33 [instruction_list ::= labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_SAY', go to state 22
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_SAY]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 22
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_SAY TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EOC' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 22.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 22.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 22.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 22.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 22.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 22.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 22.
Parser(B) >> ... then shift 'expression', go to state 331
Parser(B) >> Reduce 160 [say ::= TK_SAY expression], pop back to state 10.
Parser(B) >> ... then shift 'say', go to state 365
Parser(B) >> Reduce 60 [keyword_instruction ::= say], pop back to state 10.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 10.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_END' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 10.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_END', go to state 129
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_END]
Parser(B) >> Input 'TK_EOC' in state 129
Parser(B) >> Reduce 73 [simple_do ::= TK_DO TK_EOC instruction_list TK_END], pop back to state 15.
Parser(B) >> ... then shift 'simple_do', go to state 102
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 406
Parser(B) >> Shift 'TK_EOC', go to state 187
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 simple_do junk TK_EOC]
Parser(B) >> Input 'TK_IF' in state 187
Parser(B) >> Reduce 70 [group ::= simple_do junk TK_EOC], pop back to state 15.
Parser(B) >> ... then shift 'group', go to state 182
Parser(B) >> Reduce 41 [instruction ::= group], pop back to state 15.
Parser(B) >> ... then shift 'instruction', go to state 175
Parser(B) >> Reduce 110 [then ::= TK_THEN ncl0 instruction], pop back to state 131.
Parser(B) >> ... then shift 'then', go to state 108
Parser(B) >> Reduce 108 [if ::= TK_IF expression ncl0 then], pop back to state 8.
Parser(B) >> ... then shift 'if', go to state 185
Parser(B) >> Reduce 72 [group ::= if], pop back to state 8.
Parser(B) >> ... then shift 'group', go to state 193
Parser(B) >> Reduce 35 [labeled_instruction ::= group], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_IF', go to state 30
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 30
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_NEQ' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 30.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 30.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 30.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 30.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 30.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 30.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 30.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 30.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Shift 'TK_NEQ', go to state 47
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ]
Parser(B) >> Input 'TK_INTEGER' in state 47
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 47.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 47.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 47.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 47.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 47.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 47.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 47.
Parser(B) >> ... then shift 'concatenation', go to state 59
Parser(B) >> Reduce 213 [comparison ::= comparison TK_NEQ concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 30.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 30.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 30.
Parser(B) >> ... then shift 'expression', go to state 127
Parser(B) >> Shift 'TK_EOC', go to state 206
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression TK_EOC]
Parser(B) >> Input 'TK_THEN' in state 206
Parser(B) >> Reduce 253 [ncl0 ::= TK_EOC] without external action, pop back to state 127.
Parser(B) >> ... then shift 'ncl0', go to state 131
Parser(B) >> Shift 'TK_THEN', go to state 109
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN]
Parser(B) >> Input 'TK_DO' in state 109
Parser(B) >> Reduce 254 [ncl0 ::=] without external action.
Parser(B) >> ... then shift 'ncl0', go to state 15
Parser(B) >> Shift 'TK_DO', go to state 113
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO]
Parser(B) >> Input 'TK_EOC' in state 113
Parser(B) >> Shift 'TK_EOC', go to state 7
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 7
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 7.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 33
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_PLUS' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 33.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Shift 'TK_PLUS', go to state 64
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL addition TK_PLUS]
Parser(B) >> Input 'TK_INTEGER' in state 64
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL addition TK_PLUS TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 64.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 64.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 64.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 64.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 64.
Parser(B) >> ... then shift 'multiplication', go to state 240
Parser(B) >> Reduce 194 [addition ::= addition TK_PLUS multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 7.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 7.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_SAY' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 7.
Parser(B) >> ... then shift 'labeled_instruction', go to state 184
Parser(B) >> Reduce 33 [instruction_list ::= labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_SAY', go to state 22
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_SAY]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 22
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_SAY TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EOC' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 22.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 22.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 22.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 22.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 22.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 22.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 22.
Parser(B) >> ... then shift 'expression', go to state 331
Parser(B) >> Reduce 160 [say ::= TK_SAY expression], pop back to state 10.
Parser(B) >> ... then shift 'say', go to state 365
Parser(B) >> Reduce 60 [keyword_instruction ::= say], pop back to state 10.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 10.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_END' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 10.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_END', go to state 129
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_END]
Parser(B) >> Input 'TK_EOC' in state 129
Parser(B) >> Reduce 73 [simple_do ::= TK_DO TK_EOC instruction_list TK_END], pop back to state 15.
Parser(B) >> ... then shift 'simple_do', go to state 102
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 406
Parser(B) >> Shift 'TK_EOC', go to state 187
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 simple_do junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 187
Parser(B) >> Reduce 70 [group ::= simple_do junk TK_EOC], pop back to state 15.
Parser(B) >> ... then shift 'group', go to state 182
Parser(B) >> Reduce 41 [instruction ::= group], pop back to state 15.
Parser(B) >> ... then shift 'instruction', go to state 175
Parser(B) >> Reduce 110 [then ::= TK_THEN ncl0 instruction], pop back to state 131.
Parser(B) >> ... then shift 'then', go to state 108
Parser(B) >> Reduce 108 [if ::= TK_IF expression ncl0 then], pop back to state 8.
Parser(B) >> ... then shift 'if', go to state 185
Parser(B) >> Reduce 72 [group ::= if], pop back to state 8.
Parser(B) >> ... then shift 'group', go to state 193
Parser(B) >> Reduce 35 [labeled_instruction ::= group], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 8.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_STRING' in state 33
Parser(B) >> Shift 'TK_STRING', go to state 111
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL TK_STRING]
Parser(B) >> Input 'TK_EOC' in state 111
Parser(B) >> Reduce 179 [term ::= TK_STRING], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 8.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 8.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_INTEGER' in state 33
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 8.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 8.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_INTEGER' in state 33
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 8.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_IF' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_IF', go to state 30
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 30
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_OPEN_BRACKET' in state 112
Parser(B) >> Shift 'TK_OPEN_BRACKET', go to state 21
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL TK_OPEN_BRACKET]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 21
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL TK_OPEN_BRACKET TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_COMMA' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 21.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 21.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 21.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 21.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 21.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 21.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 21.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 21.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 21.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 21.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 21.
Parser(B) >> ... then shift 'and_expression', go to state 292
Parser(B) >> Reduce 252 [expression_in_list ::= and_expression], pop back to state 21.
Parser(B) >> ... then shift 'expression_in_list', go to state 299
Parser(B) >> Reduce 169 [expression_list ::= expression_in_list], pop back to state 21.
Parser(B) >> ... then shift 'expression_list', go to state 383
Parser(B) >> Shift 'TK_COMMA', go to state 24
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL TK_OPEN_BRACKET expression_list TK_COMMA]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 24
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL TK_OPEN_BRACKET expression_list TK_COMMA TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_COMMA' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 24.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 24.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 24.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 24.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 24.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 24.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 24.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 24.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 24.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 24.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 24.
Parser(B) >> ... then shift 'and_expression', go to state 292
Parser(B) >> Reduce 252 [expression_in_list ::= and_expression], pop back to state 24.
Parser(B) >> ... then shift 'expression_in_list', go to state 298
Parser(B) >> Reduce 170 [expression_list ::= expression_list TK_COMMA expression_in_list], pop back to state 21.
Parser(B) >> ... then shift 'expression_list', go to state 383
Parser(B) >> Shift 'TK_COMMA', go to state 24
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL TK_OPEN_BRACKET expression_list TK_COMMA]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 24
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL TK_OPEN_BRACKET expression_list TK_COMMA TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_CLOSE_BRACKET' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 24.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 24.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 24.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 24.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 24.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 24.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 24.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 24.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 24.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 24.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 24.
Parser(B) >> ... then shift 'and_expression', go to state 292
Parser(B) >> Reduce 252 [expression_in_list ::= and_expression], pop back to state 24.
Parser(B) >> ... then shift 'expression_in_list', go to state 298
Parser(B) >> Reduce 170 [expression_list ::= expression_list TK_COMMA expression_in_list], pop back to state 21.
Parser(B) >> ... then shift 'expression_list', go to state 383
Parser(B) >> Shift 'TK_CLOSE_BRACKET', go to state 207
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL TK_OPEN_BRACKET expression_list TK_CLOSE_BRACKET]
Parser(B) >> Input 'TK_NEQ' in state 207
Parser(B) >> Reduce 175 [function_parameters ::= TK_OPEN_BRACKET expression_list TK_CLOSE_BRACKET], pop back to state 112.
Parser(B) >> ... then shift 'function_parameters', go to state 235
Parser(B) >> Reduce 172 [term ::= TK_VAR_SYMBOL function_parameters], pop back to state 30.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 30.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 30.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 30.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 30.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 30.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 30.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Shift 'TK_NEQ', go to state 47
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ]
Parser(B) >> Input 'TK_INTEGER' in state 47
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 47.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 47.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 47.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 47.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 47.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 47.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 47.
Parser(B) >> ... then shift 'concatenation', go to state 59
Parser(B) >> Reduce 213 [comparison ::= comparison TK_NEQ concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 30.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 30.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 30.
Parser(B) >> ... then shift 'expression', go to state 127
Parser(B) >> Shift 'TK_EOC', go to state 206
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression TK_EOC]
Parser(B) >> Input 'TK_THEN' in state 206
Parser(B) >> Reduce 253 [ncl0 ::= TK_EOC] without external action, pop back to state 127.
Parser(B) >> ... then shift 'ncl0', go to state 131
Parser(B) >> Shift 'TK_THEN', go to state 109
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN]
Parser(B) >> Input 'TK_DO' in state 109
Parser(B) >> Reduce 254 [ncl0 ::=] without external action.
Parser(B) >> ... then shift 'ncl0', go to state 15
Parser(B) >> Shift 'TK_DO', go to state 113
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO]
Parser(B) >> Input 'TK_EOC' in state 113
Parser(B) >> Shift 'TK_EOC', go to state 7
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 7
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 7.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 33
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_PLUS' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 33.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Shift 'TK_PLUS', go to state 64
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL addition TK_PLUS]
Parser(B) >> Input 'TK_INTEGER' in state 64
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL addition TK_PLUS TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 64.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 64.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 64.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 64.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 64.
Parser(B) >> ... then shift 'multiplication', go to state 240
Parser(B) >> Reduce 194 [addition ::= addition TK_PLUS multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 7.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 7.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_SAY' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 7.
Parser(B) >> ... then shift 'labeled_instruction', go to state 184
Parser(B) >> Reduce 33 [instruction_list ::= labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_SAY', go to state 22
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_SAY]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 22
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_SAY TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EOC' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 22.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 22.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 22.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 22.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 22.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 22.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 22.
Parser(B) >> ... then shift 'expression', go to state 331
Parser(B) >> Reduce 160 [say ::= TK_SAY expression], pop back to state 10.
Parser(B) >> ... then shift 'say', go to state 365
Parser(B) >> Reduce 60 [keyword_instruction ::= say], pop back to state 10.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 10.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_END' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 10.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_END', go to state 129
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_END]
Parser(B) >> Input 'TK_EOC' in state 129
Parser(B) >> Reduce 73 [simple_do ::= TK_DO TK_EOC instruction_list TK_END], pop back to state 15.
Parser(B) >> ... then shift 'simple_do', go to state 102
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 406
Parser(B) >> Shift 'TK_EOC', go to state 187
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 simple_do junk TK_EOC]
Parser(B) >> Input 'TK_IF' in state 187
Parser(B) >> Reduce 70 [group ::= simple_do junk TK_EOC], pop back to state 15.
Parser(B) >> ... then shift 'group', go to state 182
Parser(B) >> Reduce 41 [instruction ::= group], pop back to state 15.
Parser(B) >> ... then shift 'instruction', go to state 175
Parser(B) >> Reduce 110 [then ::= TK_THEN ncl0 instruction], pop back to state 131.
Parser(B) >> ... then shift 'then', go to state 108
Parser(B) >> Reduce 108 [if ::= TK_IF expression ncl0 then], pop back to state 8.
Parser(B) >> ... then shift 'if', go to state 185
Parser(B) >> Reduce 72 [group ::= if], pop back to state 8.
Parser(B) >> ... then shift 'group', go to state 193
Parser(B) >> Reduce 35 [labeled_instruction ::= group], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_IF', go to state 30
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 30
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_NEQ' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 30.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 30.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 30.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 30.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 30.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 30.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 30.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 30.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Shift 'TK_NEQ', go to state 47
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ]
Parser(B) >> Input 'TK_INTEGER' in state 47
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 47.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 47.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 47.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 47.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 47.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 47.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 47.
Parser(B) >> ... then shift 'concatenation', go to state 59
Parser(B) >> Reduce 213 [comparison ::= comparison TK_NEQ concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 30.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 30.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 30.
Parser(B) >> ... then shift 'expression', go to state 127
Parser(B) >> Shift 'TK_EOC', go to state 206
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression TK_EOC]
Parser(B) >> Input 'TK_THEN' in state 206
Parser(B) >> Reduce 253 [ncl0 ::= TK_EOC] without external action, pop back to state 127.
Parser(B) >> ... then shift 'ncl0', go to state 131
Parser(B) >> Shift 'TK_THEN', go to state 109
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN]
Parser(B) >> Input 'TK_DO' in state 109
Parser(B) >> Reduce 254 [ncl0 ::=] without external action.
Parser(B) >> ... then shift 'ncl0', go to state 15
Parser(B) >> Shift 'TK_DO', go to state 113
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO]
Parser(B) >> Input 'TK_EOC' in state 113
Parser(B) >> Shift 'TK_EOC', go to state 7
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 7
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 7.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 33
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_PLUS' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 33.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Shift 'TK_PLUS', go to state 64
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL addition TK_PLUS]
Parser(B) >> Input 'TK_INTEGER' in state 64
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL addition TK_PLUS TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 64.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 64.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 64.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 64.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 64.
Parser(B) >> ... then shift 'multiplication', go to state 240
Parser(B) >> Reduce 194 [addition ::= addition TK_PLUS multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 7.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 7.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_SAY' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 7.
Parser(B) >> ... then shift 'labeled_instruction', go to state 184
Parser(B) >> Reduce 33 [instruction_list ::= labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_SAY', go to state 22
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_SAY]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 22
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_SAY TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EOC' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 22.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 22.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 22.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 22.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 22.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 22.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 22.
Parser(B) >> ... then shift 'expression', go to state 331
Parser(B) >> Reduce 160 [say ::= TK_SAY expression], pop back to state 10.
Parser(B) >> ... then shift 'say', go to state 365
Parser(B) >> Reduce 60 [keyword_instruction ::= say], pop back to state 10.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 10.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_END' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 10.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_END', go to state 129
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_END]
Parser(B) >> Input 'TK_EOC' in state 129
Parser(B) >> Reduce 73 [simple_do ::= TK_DO TK_EOC instruction_list TK_END], pop back to state 15.
Parser(B) >> ... then shift 'simple_do', go to state 102
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 406
Parser(B) >> Shift 'TK_EOC', go to state 187
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 simple_do junk TK_EOC]
Parser(B) >> Input 'TK_IF' in state 187
Parser(B) >> Reduce 70 [group ::= simple_do junk TK_EOC], pop back to state 15.
Parser(B) >> ... then shift 'group', go to state 182
Parser(B) >> Reduce 41 [instruction ::= group], pop back to state 15.
Parser(B) >> ... then shift 'instruction', go to state 175
Parser(B) >> Reduce 110 [then ::= TK_THEN ncl0 instruction], pop back to state 131.
Parser(B) >> ... then shift 'then', go to state 108
Parser(B) >> Reduce 108 [if ::= TK_IF expression ncl0 then], pop back to state 8.
Parser(B) >> ... then shift 'if', go to state 185
Parser(B) >> Reduce 72 [group ::= if], pop back to state 8.
Parser(B) >> ... then shift 'group', go to state 193
Parser(B) >> Reduce 35 [labeled_instruction ::= group], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_IF', go to state 30
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 30
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_NEQ' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 30.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 30.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 30.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 30.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 30.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 30.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 30.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 30.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Shift 'TK_NEQ', go to state 47
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ]
Parser(B) >> Input 'TK_INTEGER' in state 47
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF comparison TK_NEQ TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 47.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 47.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 47.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 47.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 47.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 47.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 47.
Parser(B) >> ... then shift 'concatenation', go to state 59
Parser(B) >> Reduce 213 [comparison ::= comparison TK_NEQ concatenation], pop back to state 30.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 30.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 30.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 30.
Parser(B) >> ... then shift 'expression', go to state 127
Parser(B) >> Shift 'TK_EOC', go to state 206
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression TK_EOC]
Parser(B) >> Input 'TK_THEN' in state 206
Parser(B) >> Reduce 253 [ncl0 ::= TK_EOC] without external action, pop back to state 127.
Parser(B) >> ... then shift 'ncl0', go to state 131
Parser(B) >> Shift 'TK_THEN', go to state 109
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN]
Parser(B) >> Input 'TK_DO' in state 109
Parser(B) >> Reduce 254 [ncl0 ::=] without external action.
Parser(B) >> ... then shift 'ncl0', go to state 15
Parser(B) >> Shift 'TK_DO', go to state 113
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO]
Parser(B) >> Input 'TK_EOC' in state 113
Parser(B) >> Shift 'TK_EOC', go to state 7
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 7
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 7.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 33
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_PLUS' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 33.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Shift 'TK_PLUS', go to state 64
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL addition TK_PLUS]
Parser(B) >> Input 'TK_INTEGER' in state 64
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC var_symbol TK_EQUAL addition TK_PLUS TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 64.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 64.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 64.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 64.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 64.
Parser(B) >> ... then shift 'multiplication', go to state 240
Parser(B) >> Reduce 194 [addition ::= addition TK_PLUS multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 7.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 7.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_SAY' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 7.
Parser(B) >> ... then shift 'labeled_instruction', go to state 184
Parser(B) >> Reduce 33 [instruction_list ::= labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_SAY', go to state 22
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_SAY]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 22
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_SAY TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EOC' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 22.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 22.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 22.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 22.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 22.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 22.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 22.
Parser(B) >> ... then shift 'expression', go to state 331
Parser(B) >> Reduce 160 [say ::= TK_SAY expression], pop back to state 10.
Parser(B) >> ... then shift 'say', go to state 365
Parser(B) >> Reduce 60 [keyword_instruction ::= say], pop back to state 10.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 10.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_END' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 10.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 7.
Parser(B) >> ... then shift 'instruction_list', go to state 10
Parser(B) >> Shift 'TK_END', go to state 129
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 TK_DO TK_EOC instruction_list TK_END]
Parser(B) >> Input 'TK_EOC' in state 129
Parser(B) >> Reduce 73 [simple_do ::= TK_DO TK_EOC instruction_list TK_END], pop back to state 15.
Parser(B) >> ... then shift 'simple_do', go to state 102
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 406
Parser(B) >> Shift 'TK_EOC', go to state 187
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_IF expression ncl0 TK_THEN ncl0 simple_do junk TK_EOC]
Parser(B) >> Input 'TK_RETURN' in state 187
Parser(B) >> Reduce 70 [group ::= simple_do junk TK_EOC], pop back to state 15.
Parser(B) >> ... then shift 'group', go to state 182
Parser(B) >> Reduce 41 [instruction ::= group], pop back to state 15.
Parser(B) >> ... then shift 'instruction', go to state 175
Parser(B) >> Reduce 110 [then ::= TK_THEN ncl0 instruction], pop back to state 131.
Parser(B) >> ... then shift 'then', go to state 108
Parser(B) >> Reduce 108 [if ::= TK_IF expression ncl0 then], pop back to state 8.
Parser(B) >> ... then shift 'if', go to state 185
Parser(B) >> Reduce 72 [group ::= if], pop back to state 8.
Parser(B) >> ... then shift 'group', go to state 193
Parser(B) >> Reduce 35 [labeled_instruction ::= group], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_RETURN', go to state 23
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_RETURN]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 23
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_RETURN TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_NEQ' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 23.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 23.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 23.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 23.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 23.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 23.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 23.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 23.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 23.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Shift 'TK_NEQ', go to state 47
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_RETURN comparison TK_NEQ]
Parser(B) >> Input 'TK_INTEGER' in state 47
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_RETURN comparison TK_NEQ TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 47.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 47.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 47.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 47.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 47.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 47.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 47.
Parser(B) >> ... then shift 'concatenation', go to state 59
Parser(B) >> Reduce 213 [comparison ::= comparison TK_NEQ concatenation], pop back to state 23.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 23.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 23.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 23.
Parser(B) >> ... then shift 'expression', go to state 332
Parser(B) >> Reduce 158 [return ::= TK_RETURN expression], pop back to state 8.
Parser(B) >> ... then shift 'return', go to state 366
Parser(B) >> Reduce 59 [keyword_instruction ::= return], pop back to state 8.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_LABEL' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_LABEL', go to state 173
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_LABEL]
Parser(B) >> Input 'TK_PROCEDURE' in state 173
Parser(B) >> Shift 'TK_PROCEDURE', go to state 319
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_LABEL TK_PROCEDURE]
Parser(B) >> Input 'TK_EQUAL' in state 319
Parser(B) >> Shift 'TK_EQUAL', go to state 132
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_LABEL TK_PROCEDURE TK_EQUAL]
Parser(B) >> Input 'TK_CLASS' in state 132
Parser(B) >> Shift 'TK_CLASS', go to state 318
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_LABEL TK_PROCEDURE TK_EQUAL TK_CLASS]
Parser(B) >> Input 'TK_EOC' in state 318
Parser(B) >> Reduce 120 [class ::= TK_CLASS], pop back to state 132.
Parser(B) >> ... then shift 'class', go to state 379
Parser(B) >> Reduce 116 [procedure ::= TK_LABEL TK_PROCEDURE TK_EQUAL class], pop back to state 8.
Parser(B) >> ... then shift 'procedure', go to state 367
Parser(B) >> Reduce 58 [keyword_instruction ::= procedure], pop back to state 8.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_ARG' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_ARG', go to state 82
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_ARG]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 82
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 297
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_ARG TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 297
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 82.
Parser(B) >> ... then shift 'var_symbol', go to state 401
Parser(B) >> Shift 'TK_EQUAL', go to state 19
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_ARG var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_STRING' in state 19
Parser(B) >> Shift 'TK_STRING', go to state 111
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_ARG var_symbol TK_EQUAL TK_STRING]
Parser(B) >> Input 'TK_COMMA' in state 111
Parser(B) >> Reduce 179 [term ::= TK_STRING], pop back to state 19.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 19.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 19.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 19.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 19.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 19.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 19.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 19.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 19.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 19.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 19.
Parser(B) >> ... then shift 'expression', go to state 312
Parser(B) >> Reduce 127 [argument ::= var_symbol TK_EQUAL expression], pop back to state 82.
Parser(B) >> ... then shift 'argument', go to state 311
Parser(B) >> Reduce 122 [arg_list ::= argument], pop back to state 82.
Parser(B) >> ... then shift 'arg_list', go to state 317
Parser(B) >> Shift 'TK_COMMA', go to state 105
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_ARG arg_list TK_COMMA]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 105
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 297
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_ARG arg_list TK_COMMA TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 297
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 105.
Parser(B) >> ... then shift 'var_symbol', go to state 401
Parser(B) >> Shift 'TK_EQUAL', go to state 19
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_ARG arg_list TK_COMMA var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_CLASS' in state 19
Parser(B) >> Shift 'TK_CLASS', go to state 318
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_ARG arg_list TK_COMMA var_symbol TK_EQUAL TK_CLASS]
Parser(B) >> Input 'TK_COMMA' in state 318
Parser(B) >> Reduce 120 [class ::= TK_CLASS], pop back to state 19.
Parser(B) >> ... then shift 'class', go to state 313
Parser(B) >> Reduce 125 [argument ::= var_symbol TK_EQUAL class], pop back to state 105.
Parser(B) >> ... then shift 'argument', go to state 316
Parser(B) >> Reduce 123 [arg_list ::= arg_list TK_COMMA argument], pop back to state 82.
Parser(B) >> ... then shift 'arg_list', go to state 317
Parser(B) >> Shift 'TK_COMMA', go to state 105
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_ARG arg_list TK_COMMA]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 105
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 297
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_ARG arg_list TK_COMMA TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 297
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 105.
Parser(B) >> ... then shift 'var_symbol', go to state 401
Parser(B) >> Shift 'TK_EQUAL', go to state 19
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_ARG arg_list TK_COMMA var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_CLASS' in state 19
Parser(B) >> Shift 'TK_CLASS', go to state 318
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_ARG arg_list TK_COMMA var_symbol TK_EQUAL TK_CLASS]
Parser(B) >> Input 'TK_EOC' in state 318
Parser(B) >> Reduce 120 [class ::= TK_CLASS], pop back to state 19.
Parser(B) >> ... then shift 'class', go to state 313
Parser(B) >> Reduce 125 [argument ::= var_symbol TK_EQUAL class], pop back to state 105.
Parser(B) >> ... then shift 'argument', go to state 316
Parser(B) >> Reduce 123 [arg_list ::= arg_list TK_COMMA argument], pop back to state 82.
Parser(B) >> ... then shift 'arg_list', go to state 317
Parser(B) >> Reduce 119 [arg ::= TK_ARG arg_list], pop back to state 8.
Parser(B) >> ... then shift 'arg', go to state 372
Parser(B) >> Reduce 53 [keyword_instruction ::= arg], pop back to state 8.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_SAY' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_SAY', go to state 22
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 22
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EOC' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 22.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 22.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 22.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 22.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 22.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 22.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 22.
Parser(B) >> ... then shift 'expression', go to state 331
Parser(B) >> Reduce 160 [say ::= TK_SAY expression], pop back to state 8.
Parser(B) >> ... then shift 'say', go to state 365
Parser(B) >> Reduce 60 [keyword_instruction ::= say], pop back to state 8.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 8.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_STRING' in state 33
Parser(B) >> Shift 'TK_STRING', go to state 111
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL TK_STRING]
Parser(B) >> Input 'TK_EOC' in state 111
Parser(B) >> Reduce 179 [term ::= TK_STRING], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 8.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 8.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 33
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_PLUS' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 33.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Shift 'TK_PLUS', go to state 64
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL addition TK_PLUS]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 64
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL addition TK_PLUS TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EOC' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 64.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 64.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 64.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 64.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 64.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 64.
Parser(B) >> ... then shift 'multiplication', go to state 240
Parser(B) >> Reduce 194 [addition ::= addition TK_PLUS multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 8.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 8.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_INTEGER' in state 33
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 8.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 8.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_INTEGER' in state 33
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 8.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_RETURN' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_RETURN', go to state 23
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_RETURN]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 23
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_RETURN TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EOC' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 23.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 23.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 23.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 23.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 23.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 23.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 23.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 23.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 23.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 23.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 23.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 23.
Parser(B) >> ... then shift 'expression', go to state 332
Parser(B) >> Reduce 158 [return ::= TK_RETURN expression], pop back to state 8.
Parser(B) >> ... then shift 'return', go to state 366
Parser(B) >> Reduce 59 [keyword_instruction ::= return], pop back to state 8.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_LABEL' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_LABEL', go to state 173
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_LABEL]
Parser(B) >> Input 'TK_PROCEDURE' in state 173
Parser(B) >> Shift 'TK_PROCEDURE', go to state 319
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_LABEL TK_PROCEDURE]
Parser(B) >> Input 'TK_EQUAL' in state 319
Parser(B) >> Shift 'TK_EQUAL', go to state 132
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_LABEL TK_PROCEDURE TK_EQUAL]
Parser(B) >> Input 'TK_CLASS' in state 132
Parser(B) >> Shift 'TK_CLASS', go to state 318
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_LABEL TK_PROCEDURE TK_EQUAL TK_CLASS]
Parser(B) >> Input 'TK_EOC' in state 318
Parser(B) >> Reduce 120 [class ::= TK_CLASS], pop back to state 132.
Parser(B) >> ... then shift 'class', go to state 379
Parser(B) >> Reduce 116 [procedure ::= TK_LABEL TK_PROCEDURE TK_EQUAL class], pop back to state 8.
Parser(B) >> ... then shift 'procedure', go to state 367
Parser(B) >> Reduce 58 [keyword_instruction ::= procedure], pop back to state 8.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_ARG' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_ARG', go to state 82
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_ARG]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 82
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 297
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_ARG TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 297
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 82.
Parser(B) >> ... then shift 'var_symbol', go to state 401
Parser(B) >> Shift 'TK_EQUAL', go to state 19
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_ARG var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_CLASS' in state 19
Parser(B) >> Shift 'TK_CLASS', go to state 318
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_ARG var_symbol TK_EQUAL TK_CLASS]
Parser(B) >> Input 'TK_COMMA' in state 318
Parser(B) >> Reduce 120 [class ::= TK_CLASS], pop back to state 19.
Parser(B) >> ... then shift 'class', go to state 313
Parser(B) >> Reduce 125 [argument ::= var_symbol TK_EQUAL class], pop back to state 82.
Parser(B) >> ... then shift 'argument', go to state 311
Parser(B) >> Reduce 122 [arg_list ::= argument], pop back to state 82.
Parser(B) >> ... then shift 'arg_list', go to state 317
Parser(B) >> Shift 'TK_COMMA', go to state 105
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_ARG arg_list TK_COMMA]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 105
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 297
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_ARG arg_list TK_COMMA TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 297
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 105.
Parser(B) >> ... then shift 'var_symbol', go to state 401
Parser(B) >> Shift 'TK_EQUAL', go to state 19
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_ARG arg_list TK_COMMA var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_CLASS' in state 19
Parser(B) >> Shift 'TK_CLASS', go to state 318
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_ARG arg_list TK_COMMA var_symbol TK_EQUAL TK_CLASS]
Parser(B) >> Input 'TK_COMMA' in state 318
Parser(B) >> Reduce 120 [class ::= TK_CLASS], pop back to state 19.
Parser(B) >> ... then shift 'class', go to state 313
Parser(B) >> Reduce 125 [argument ::= var_symbol TK_EQUAL class], pop back to state 105.
Parser(B) >> ... then shift 'argument', go to state 316
Parser(B) >> Reduce 123 [arg_list ::= arg_list TK_COMMA argument], pop back to state 82.
Parser(B) >> ... then shift 'arg_list', go to state 317
Parser(B) >> Shift 'TK_COMMA', go to state 105
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_ARG arg_list TK_COMMA]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 105
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 297
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_ARG arg_list TK_COMMA TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 297
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 105.
Parser(B) >> ... then shift 'var_symbol', go to state 401
Parser(B) >> Shift 'TK_EQUAL', go to state 19
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_ARG arg_list TK_COMMA var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_CLASS' in state 19
Parser(B) >> Shift 'TK_CLASS', go to state 318
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_ARG arg_list TK_COMMA var_symbol TK_EQUAL TK_CLASS]
Parser(B) >> Input 'TK_EOC' in state 318
Parser(B) >> Reduce 120 [class ::= TK_CLASS], pop back to state 19.
Parser(B) >> ... then shift 'class', go to state 313
Parser(B) >> Reduce 125 [argument ::= var_symbol TK_EQUAL class], pop back to state 105.
Parser(B) >> ... then shift 'argument', go to state 316
Parser(B) >> Reduce 123 [arg_list ::= arg_list TK_COMMA argument], pop back to state 82.
Parser(B) >> ... then shift 'arg_list', go to state 317
Parser(B) >> Reduce 119 [arg ::= TK_ARG arg_list], pop back to state 8.
Parser(B) >> ... then shift 'arg', go to state 372
Parser(B) >> Reduce 53 [keyword_instruction ::= arg], pop back to state 8.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_SAY' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_SAY', go to state 22
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 22
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EOC' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 22.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 22.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 22.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 22.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 22.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 22.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 22.
Parser(B) >> ... then shift 'expression', go to state 331
Parser(B) >> Reduce 160 [say ::= TK_SAY expression], pop back to state 8.
Parser(B) >> ... then shift 'say', go to state 365
Parser(B) >> Reduce 60 [keyword_instruction ::= say], pop back to state 8.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 8.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 33
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_PLUS' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 33.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Shift 'TK_PLUS', go to state 64
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL addition TK_PLUS]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 64
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL addition TK_PLUS TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EOC' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 64.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 64.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 64.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 64.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 64.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 64.
Parser(B) >> ... then shift 'multiplication', go to state 240
Parser(B) >> Reduce 194 [addition ::= addition TK_PLUS multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 8.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 8.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_INTEGER' in state 33
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 8.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 8.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_INTEGER' in state 33
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 8.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_RETURN' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_RETURN', go to state 23
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_RETURN]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 23
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_RETURN TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EOC' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 23.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 23.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 23.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 23.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 23.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 23.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 23.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 23.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 23.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 23.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 23.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 23.
Parser(B) >> ... then shift 'expression', go to state 332
Parser(B) >> Reduce 158 [return ::= TK_RETURN expression], pop back to state 8.
Parser(B) >> ... then shift 'return', go to state 366
Parser(B) >> Reduce 59 [keyword_instruction ::= return], pop back to state 8.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_LABEL' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_LABEL', go to state 173
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_LABEL]
Parser(B) >> Input 'TK_PROCEDURE' in state 173
Parser(B) >> Shift 'TK_PROCEDURE', go to state 319
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_LABEL TK_PROCEDURE]
Parser(B) >> Input 'TK_EQUAL' in state 319
Parser(B) >> Shift 'TK_EQUAL', go to state 132
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_LABEL TK_PROCEDURE TK_EQUAL]
Parser(B) >> Input 'TK_CLASS' in state 132
Parser(B) >> Shift 'TK_CLASS', go to state 318
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_LABEL TK_PROCEDURE TK_EQUAL TK_CLASS]
Parser(B) >> Input 'TK_EOC' in state 318
Parser(B) >> Reduce 120 [class ::= TK_CLASS], pop back to state 132.
Parser(B) >> ... then shift 'class', go to state 379
Parser(B) >> Reduce 116 [procedure ::= TK_LABEL TK_PROCEDURE TK_EQUAL class], pop back to state 8.
Parser(B) >> ... then shift 'procedure', go to state 367
Parser(B) >> Reduce 58 [keyword_instruction ::= procedure], pop back to state 8.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_ARG' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_ARG', go to state 82
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_ARG]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 82
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 297
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_ARG TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 297
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 82.
Parser(B) >> ... then shift 'var_symbol', go to state 401
Parser(B) >> Shift 'TK_EQUAL', go to state 19
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_ARG var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_CLASS' in state 19
Parser(B) >> Shift 'TK_CLASS', go to state 318
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_ARG var_symbol TK_EQUAL TK_CLASS]
Parser(B) >> Input 'TK_COMMA' in state 318
Parser(B) >> Reduce 120 [class ::= TK_CLASS], pop back to state 19.
Parser(B) >> ... then shift 'class', go to state 313
Parser(B) >> Reduce 125 [argument ::= var_symbol TK_EQUAL class], pop back to state 82.
Parser(B) >> ... then shift 'argument', go to state 311
Parser(B) >> Reduce 122 [arg_list ::= argument], pop back to state 82.
Parser(B) >> ... then shift 'arg_list', go to state 317
Parser(B) >> Shift 'TK_COMMA', go to state 105
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_ARG arg_list TK_COMMA]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 105
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 297
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_ARG arg_list TK_COMMA TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 297
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 105.
Parser(B) >> ... then shift 'var_symbol', go to state 401
Parser(B) >> Shift 'TK_EQUAL', go to state 19
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_ARG arg_list TK_COMMA var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_CLASS' in state 19
Parser(B) >> Shift 'TK_CLASS', go to state 318
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_ARG arg_list TK_COMMA var_symbol TK_EQUAL TK_CLASS]
Parser(B) >> Input 'TK_COMMA' in state 318
Parser(B) >> Reduce 120 [class ::= TK_CLASS], pop back to state 19.
Parser(B) >> ... then shift 'class', go to state 313
Parser(B) >> Reduce 125 [argument ::= var_symbol TK_EQUAL class], pop back to state 105.
Parser(B) >> ... then shift 'argument', go to state 316
Parser(B) >> Reduce 123 [arg_list ::= arg_list TK_COMMA argument], pop back to state 82.
Parser(B) >> ... then shift 'arg_list', go to state 317
Parser(B) >> Shift 'TK_COMMA', go to state 105
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_ARG arg_list TK_COMMA]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 105
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 297
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_ARG arg_list TK_COMMA TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 297
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 105.
Parser(B) >> ... then shift 'var_symbol', go to state 401
Parser(B) >> Shift 'TK_EQUAL', go to state 19
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_ARG arg_list TK_COMMA var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_INTEGER' in state 19
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_ARG arg_list TK_COMMA var_symbol TK_EQUAL TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 19.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 19.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 19.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 19.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 19.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 19.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 19.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 19.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 19.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 19.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 19.
Parser(B) >> ... then shift 'expression', go to state 312
Parser(B) >> Reduce 127 [argument ::= var_symbol TK_EQUAL expression], pop back to state 105.
Parser(B) >> ... then shift 'argument', go to state 316
Parser(B) >> Reduce 123 [arg_list ::= arg_list TK_COMMA argument], pop back to state 82.
Parser(B) >> ... then shift 'arg_list', go to state 317
Parser(B) >> Reduce 119 [arg ::= TK_ARG arg_list], pop back to state 8.
Parser(B) >> ... then shift 'arg', go to state 372
Parser(B) >> Reduce 53 [keyword_instruction ::= arg], pop back to state 8.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_SAY' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_SAY', go to state 22
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 22
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EOC' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 22.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 22.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 22.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 22.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 22.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 22.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 22.
Parser(B) >> ... then shift 'expression', go to state 331
Parser(B) >> Reduce 160 [say ::= TK_SAY expression], pop back to state 8.
Parser(B) >> ... then shift 'say', go to state 365
Parser(B) >> Reduce 60 [keyword_instruction ::= say], pop back to state 8.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 8.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 33
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_PLUS' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 33.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Shift 'TK_PLUS', go to state 64
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL addition TK_PLUS]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 64
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL addition TK_PLUS TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EOC' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 64.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 64.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 64.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 64.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 64.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 64.
Parser(B) >> ... then shift 'multiplication', go to state 240
Parser(B) >> Reduce 194 [addition ::= addition TK_PLUS multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 8.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 8.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_INTEGER' in state 33
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 8.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 8.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_INTEGER' in state 33
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 8.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_RETURN' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_RETURN', go to state 23
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_RETURN]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 23
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_RETURN TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EOC' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 23.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 23.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 23.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 23.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 23.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 23.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 23.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 23.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 23.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 23.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 23.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 23.
Parser(B) >> ... then shift 'expression', go to state 332
Parser(B) >> Reduce 158 [return ::= TK_RETURN expression], pop back to state 8.
Parser(B) >> ... then shift 'return', go to state 366
Parser(B) >> Reduce 59 [keyword_instruction ::= return], pop back to state 8.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_LABEL' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_LABEL', go to state 173
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_LABEL]
Parser(B) >> Input 'TK_PROCEDURE' in state 173
Parser(B) >> Shift 'TK_PROCEDURE', go to state 319
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_LABEL TK_PROCEDURE]
Parser(B) >> Input 'TK_EQUAL' in state 319
Parser(B) >> Shift 'TK_EQUAL', go to state 132
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_LABEL TK_PROCEDURE TK_EQUAL]
Parser(B) >> Input 'TK_CLASS' in state 132
Parser(B) >> Shift 'TK_CLASS', go to state 318
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_LABEL TK_PROCEDURE TK_EQUAL TK_CLASS]
Parser(B) >> Input 'TK_EOC' in state 318
Parser(B) >> Reduce 120 [class ::= TK_CLASS], pop back to state 132.
Parser(B) >> ... then shift 'class', go to state 379
Parser(B) >> Reduce 116 [procedure ::= TK_LABEL TK_PROCEDURE TK_EQUAL class], pop back to state 8.
Parser(B) >> ... then shift 'procedure', go to state 367
Parser(B) >> Reduce 58 [keyword_instruction ::= procedure], pop back to state 8.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_ARG' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_ARG', go to state 82
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_ARG]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 82
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 297
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_ARG TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 297
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 82.
Parser(B) >> ... then shift 'var_symbol', go to state 401
Parser(B) >> Shift 'TK_EQUAL', go to state 19
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_ARG var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_CLASS' in state 19
Parser(B) >> Shift 'TK_CLASS', go to state 318
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_ARG var_symbol TK_EQUAL TK_CLASS]
Parser(B) >> Input 'TK_COMMA' in state 318
Parser(B) >> Reduce 120 [class ::= TK_CLASS], pop back to state 19.
Parser(B) >> ... then shift 'class', go to state 313
Parser(B) >> Reduce 125 [argument ::= var_symbol TK_EQUAL class], pop back to state 82.
Parser(B) >> ... then shift 'argument', go to state 311
Parser(B) >> Reduce 122 [arg_list ::= argument], pop back to state 82.
Parser(B) >> ... then shift 'arg_list', go to state 317
Parser(B) >> Shift 'TK_COMMA', go to state 105
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_ARG arg_list TK_COMMA]
Parser(B) >> Input 'TK_EXPOSE' in state 105
Parser(B) >> Shift 'TK_EXPOSE', go to state 133
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_ARG arg_list TK_COMMA TK_EXPOSE]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 133
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 297
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_ARG arg_list TK_COMMA TK_EXPOSE TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 297
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 133.
Parser(B) >> ... then shift 'var_symbol', go to state 402
Parser(B) >> Shift 'TK_EQUAL', go to state 20
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_ARG arg_list TK_COMMA TK_EXPOSE var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_CLASS' in state 20
Parser(B) >> Shift 'TK_CLASS', go to state 318
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_ARG arg_list TK_COMMA TK_EXPOSE var_symbol TK_EQUAL TK_CLASS]
Parser(B) >> Input 'TK_COMMA' in state 318
Parser(B) >> Reduce 120 [class ::= TK_CLASS], pop back to state 20.
Parser(B) >> ... then shift 'class', go to state 315
Parser(B) >> Reduce 124 [argument ::= TK_EXPOSE var_symbol TK_EQUAL class], pop back to state 105.
Parser(B) >> ... then shift 'argument', go to state 316
Parser(B) >> Reduce 123 [arg_list ::= arg_list TK_COMMA argument], pop back to state 82.
Parser(B) >> ... then shift 'arg_list', go to state 317
Parser(B) >> Shift 'TK_COMMA', go to state 105
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_ARG arg_list TK_COMMA]
Parser(B) >> Input 'TK_EXPOSE' in state 105
Parser(B) >> Shift 'TK_EXPOSE', go to state 133
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_ARG arg_list TK_COMMA TK_EXPOSE]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 133
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 297
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_ARG arg_list TK_COMMA TK_EXPOSE TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 297
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 133.
Parser(B) >> ... then shift 'var_symbol', go to state 402
Parser(B) >> Shift 'TK_EQUAL', go to state 20
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_ARG arg_list TK_COMMA TK_EXPOSE var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_INTEGER' in state 20
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_ARG arg_list TK_COMMA TK_EXPOSE var_symbol TK_EQUAL TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 20.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 20.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 20.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 20.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 20.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 20.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 20.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 20.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 20.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 20.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 20.
Parser(B) >> ... then shift 'expression', go to state 314
Parser(B) >> Reduce 126 [argument ::= TK_EXPOSE var_symbol TK_EQUAL expression], pop back to state 105.
Parser(B) >> ... then shift 'argument', go to state 316
Parser(B) >> Reduce 123 [arg_list ::= arg_list TK_COMMA argument], pop back to state 82.
Parser(B) >> ... then shift 'arg_list', go to state 317
Parser(B) >> Reduce 119 [arg ::= TK_ARG arg_list], pop back to state 8.
Parser(B) >> ... then shift 'arg', go to state 372
Parser(B) >> Reduce 53 [keyword_instruction ::= arg], pop back to state 8.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_SAY' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_SAY', go to state 22
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 22
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EOC' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 22.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 22.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 22.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 22.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 22.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 22.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 22.
Parser(B) >> ... then shift 'expression', go to state 331
Parser(B) >> Reduce 160 [say ::= TK_SAY expression], pop back to state 8.
Parser(B) >> ... then shift 'say', go to state 365
Parser(B) >> Reduce 60 [keyword_instruction ::= say], pop back to state 8.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 8.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 33
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_PLUS' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 33.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Shift 'TK_PLUS', go to state 64
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL addition TK_PLUS]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 64
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL addition TK_PLUS TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EOC' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 64.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 64.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 64.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 64.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 64.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 64.
Parser(B) >> ... then shift 'multiplication', go to state 240
Parser(B) >> Reduce 194 [addition ::= addition TK_PLUS multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 8.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 8.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_INTEGER' in state 33
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 8.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 8.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_INTEGER' in state 33
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 8.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_RETURN' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_RETURN', go to state 23
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_RETURN]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 23
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_RETURN TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EOC' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 23.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 23.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 23.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 23.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 23.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 23.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 23.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 23.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 23.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 23.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 23.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 23.
Parser(B) >> ... then shift 'expression', go to state 332
Parser(B) >> Reduce 158 [return ::= TK_RETURN expression], pop back to state 8.
Parser(B) >> ... then shift 'return', go to state 366
Parser(B) >> Reduce 59 [keyword_instruction ::= return], pop back to state 8.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_LABEL' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_LABEL', go to state 173
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_LABEL]
Parser(B) >> Input 'TK_PROCEDURE' in state 173
Parser(B) >> Shift 'TK_PROCEDURE', go to state 319
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_LABEL TK_PROCEDURE]
Parser(B) >> Input 'TK_EQUAL' in state 319
Parser(B) >> Shift 'TK_EQUAL', go to state 132
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_LABEL TK_PROCEDURE TK_EQUAL]
Parser(B) >> Input 'TK_CLASS' in state 132
Parser(B) >> Shift 'TK_CLASS', go to state 318
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_LABEL TK_PROCEDURE TK_EQUAL TK_CLASS]
Parser(B) >> Input 'TK_EOC' in state 318
Parser(B) >> Reduce 120 [class ::= TK_CLASS], pop back to state 132.
Parser(B) >> ... then shift 'class', go to state 379
Parser(B) >> Reduce 116 [procedure ::= TK_LABEL TK_PROCEDURE TK_EQUAL class], pop back to state 8.
Parser(B) >> ... then shift 'procedure', go to state 367
Parser(B) >> Reduce 58 [keyword_instruction ::= procedure], pop back to state 8.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_ARG' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_ARG', go to state 82
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_ARG]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 82
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 297
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_ARG TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 297
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 82.
Parser(B) >> ... then shift 'var_symbol', go to state 401
Parser(B) >> Shift 'TK_EQUAL', go to state 19
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_ARG var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_STRING' in state 19
Parser(B) >> Shift 'TK_STRING', go to state 111
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_ARG var_symbol TK_EQUAL TK_STRING]
Parser(B) >> Input 'TK_COMMA' in state 111
Parser(B) >> Reduce 179 [term ::= TK_STRING], pop back to state 19.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 19.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 19.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 19.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 19.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 19.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 19.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 19.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 19.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 19.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 19.
Parser(B) >> ... then shift 'expression', go to state 312
Parser(B) >> Reduce 127 [argument ::= var_symbol TK_EQUAL expression], pop back to state 82.
Parser(B) >> ... then shift 'argument', go to state 311
Parser(B) >> Reduce 122 [arg_list ::= argument], pop back to state 82.
Parser(B) >> ... then shift 'arg_list', go to state 317
Parser(B) >> Shift 'TK_COMMA', go to state 105
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_ARG arg_list TK_COMMA]
Parser(B) >> Input 'TK_EXPOSE' in state 105
Parser(B) >> Shift 'TK_EXPOSE', go to state 133
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_ARG arg_list TK_COMMA TK_EXPOSE]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 133
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 297
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_ARG arg_list TK_COMMA TK_EXPOSE TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 297
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 133.
Parser(B) >> ... then shift 'var_symbol', go to state 402
Parser(B) >> Shift 'TK_EQUAL', go to state 20
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_ARG arg_list TK_COMMA TK_EXPOSE var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_CLASS' in state 20
Parser(B) >> Shift 'TK_CLASS', go to state 318
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_ARG arg_list TK_COMMA TK_EXPOSE var_symbol TK_EQUAL TK_CLASS]
Parser(B) >> Input 'TK_COMMA' in state 318
Parser(B) >> Reduce 120 [class ::= TK_CLASS], pop back to state 20.
Parser(B) >> ... then shift 'class', go to state 315
Parser(B) >> Reduce 124 [argument ::= TK_EXPOSE var_symbol TK_EQUAL class], pop back to state 105.
Parser(B) >> ... then shift 'argument', go to state 316
Parser(B) >> Reduce 123 [arg_list ::= arg_list TK_COMMA argument], pop back to state 82.
Parser(B) >> ... then shift 'arg_list', go to state 317
Parser(B) >> Shift 'TK_COMMA', go to state 105
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_ARG arg_list TK_COMMA]
Parser(B) >> Input 'TK_EXPOSE' in state 105
Parser(B) >> Shift 'TK_EXPOSE', go to state 133
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_ARG arg_list TK_COMMA TK_EXPOSE]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 133
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 297
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_ARG arg_list TK_COMMA TK_EXPOSE TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 297
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 133.
Parser(B) >> ... then shift 'var_symbol', go to state 402
Parser(B) >> Shift 'TK_EQUAL', go to state 20
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_ARG arg_list TK_COMMA TK_EXPOSE var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_CLASS' in state 20
Parser(B) >> Shift 'TK_CLASS', go to state 318
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_ARG arg_list TK_COMMA TK_EXPOSE var_symbol TK_EQUAL TK_CLASS]
Parser(B) >> Input 'TK_EOC' in state 318
Parser(B) >> Reduce 120 [class ::= TK_CLASS], pop back to state 20.
Parser(B) >> ... then shift 'class', go to state 315
Parser(B) >> Reduce 124 [argument ::= TK_EXPOSE var_symbol TK_EQUAL class], pop back to state 105.
Parser(B) >> ... then shift 'argument', go to state 316
Parser(B) >> Reduce 123 [arg_list ::= arg_list TK_COMMA argument], pop back to state 82.
Parser(B) >> ... then shift 'arg_list', go to state 317
Parser(B) >> Reduce 119 [arg ::= TK_ARG arg_list], pop back to state 8.
Parser(B) >> ... then shift 'arg', go to state 372
Parser(B) >> Reduce 53 [keyword_instruction ::= arg], pop back to state 8.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_SAY' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_SAY', go to state 22
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 22
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EOC' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 22.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 22.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 22.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 22.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 22.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 22.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 22.
Parser(B) >> ... then shift 'expression', go to state 331
Parser(B) >> Reduce 160 [say ::= TK_SAY expression], pop back to state 8.
Parser(B) >> ... then shift 'say', go to state 365
Parser(B) >> Reduce 60 [keyword_instruction ::= say], pop back to state 8.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 8.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_STRING' in state 33
Parser(B) >> Shift 'TK_STRING', go to state 111
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL TK_STRING]
Parser(B) >> Input 'TK_EOC' in state 111
Parser(B) >> Reduce 179 [term ::= TK_STRING], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 8.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 8.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 33
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_PLUS' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 33.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Shift 'TK_PLUS', go to state 64
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL addition TK_PLUS]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 64
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL addition TK_PLUS TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EOC' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 64.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 64.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 64.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 64.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 64.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 64.
Parser(B) >> ... then shift 'multiplication', go to state 240
Parser(B) >> Reduce 194 [addition ::= addition TK_PLUS multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 8.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 8.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_INTEGER' in state 33
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 8.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 8.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_INTEGER' in state 33
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 8.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_RETURN' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_RETURN', go to state 23
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_RETURN]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 23
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_RETURN TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EOC' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 23.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 23.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 23.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 23.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 23.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 23.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 23.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 23.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 23.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 23.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 23.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 23.
Parser(B) >> ... then shift 'expression', go to state 332
Parser(B) >> Reduce 158 [return ::= TK_RETURN expression], pop back to state 8.
Parser(B) >> ... then shift 'return', go to state 366
Parser(B) >> Reduce 59 [keyword_instruction ::= return], pop back to state 8.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_LABEL' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_LABEL', go to state 173
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_LABEL]
Parser(B) >> Input 'TK_PROCEDURE' in state 173
Parser(B) >> Shift 'TK_PROCEDURE', go to state 319
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_LABEL TK_PROCEDURE]
Parser(B) >> Input 'TK_EQUAL' in state 319
Parser(B) >> Shift 'TK_EQUAL', go to state 132
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_LABEL TK_PROCEDURE TK_EQUAL]
Parser(B) >> Input 'TK_CLASS' in state 132
Parser(B) >> Shift 'TK_CLASS', go to state 318
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_LABEL TK_PROCEDURE TK_EQUAL TK_CLASS]
Parser(B) >> Input 'TK_EOC' in state 318
Parser(B) >> Reduce 120 [class ::= TK_CLASS], pop back to state 132.
Parser(B) >> ... then shift 'class', go to state 379
Parser(B) >> Reduce 116 [procedure ::= TK_LABEL TK_PROCEDURE TK_EQUAL class], pop back to state 8.
Parser(B) >> ... then shift 'procedure', go to state 367
Parser(B) >> Reduce 58 [keyword_instruction ::= procedure], pop back to state 8.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_ARG' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_ARG', go to state 82
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_ARG]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 82
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 297
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_ARG TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 297
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 82.
Parser(B) >> ... then shift 'var_symbol', go to state 401
Parser(B) >> Shift 'TK_EQUAL', go to state 19
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_ARG var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_STRING' in state 19
Parser(B) >> Shift 'TK_STRING', go to state 111
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_ARG var_symbol TK_EQUAL TK_STRING]
Parser(B) >> Input 'TK_COMMA' in state 111
Parser(B) >> Reduce 179 [term ::= TK_STRING], pop back to state 19.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 19.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 19.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 19.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 19.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 19.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 19.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 19.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 19.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 19.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 19.
Parser(B) >> ... then shift 'expression', go to state 312
Parser(B) >> Reduce 127 [argument ::= var_symbol TK_EQUAL expression], pop back to state 82.
Parser(B) >> ... then shift 'argument', go to state 311
Parser(B) >> Reduce 122 [arg_list ::= argument], pop back to state 82.
Parser(B) >> ... then shift 'arg_list', go to state 317
Parser(B) >> Shift 'TK_COMMA', go to state 105
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_ARG arg_list TK_COMMA]
Parser(B) >> Input 'TK_EXPOSE' in state 105
Parser(B) >> Shift 'TK_EXPOSE', go to state 133
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_ARG arg_list TK_COMMA TK_EXPOSE]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 133
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 297
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_ARG arg_list TK_COMMA TK_EXPOSE TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 297
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 133.
Parser(B) >> ... then shift 'var_symbol', go to state 402
Parser(B) >> Shift 'TK_EQUAL', go to state 20
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_ARG arg_list TK_COMMA TK_EXPOSE var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_CLASS' in state 20
Parser(B) >> Shift 'TK_CLASS', go to state 318
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_ARG arg_list TK_COMMA TK_EXPOSE var_symbol TK_EQUAL TK_CLASS]
Parser(B) >> Input 'TK_COMMA' in state 318
Parser(B) >> Reduce 120 [class ::= TK_CLASS], pop back to state 20.
Parser(B) >> ... then shift 'class', go to state 315
Parser(B) >> Reduce 124 [argument ::= TK_EXPOSE var_symbol TK_EQUAL class], pop back to state 105.
Parser(B) >> ... then shift 'argument', go to state 316
Parser(B) >> Reduce 123 [arg_list ::= arg_list TK_COMMA argument], pop back to state 82.
Parser(B) >> ... then shift 'arg_list', go to state 317
Parser(B) >> Shift 'TK_COMMA', go to state 105
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_ARG arg_list TK_COMMA]
Parser(B) >> Input 'TK_EXPOSE' in state 105
Parser(B) >> Shift 'TK_EXPOSE', go to state 133
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_ARG arg_list TK_COMMA TK_EXPOSE]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 133
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 297
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_ARG arg_list TK_COMMA TK_EXPOSE TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 297
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 133.
Parser(B) >> ... then shift 'var_symbol', go to state 402
Parser(B) >> Shift 'TK_EQUAL', go to state 20
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_ARG arg_list TK_COMMA TK_EXPOSE var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_CLASS' in state 20
Parser(B) >> Shift 'TK_CLASS', go to state 318
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_ARG arg_list TK_COMMA TK_EXPOSE var_symbol TK_EQUAL TK_CLASS]
Parser(B) >> Input 'TK_EOC' in state 318
Parser(B) >> Reduce 120 [class ::= TK_CLASS], pop back to state 20.
Parser(B) >> ... then shift 'class', go to state 315
Parser(B) >> Reduce 124 [argument ::= TK_EXPOSE var_symbol TK_EQUAL class], pop back to state 105.
Parser(B) >> ... then shift 'argument', go to state 316
Parser(B) >> Reduce 123 [arg_list ::= arg_list TK_COMMA argument], pop back to state 82.
Parser(B) >> ... then shift 'arg_list', go to state 317
Parser(B) >> Reduce 119 [arg ::= TK_ARG arg_list], pop back to state 8.
Parser(B) >> ... then shift 'arg', go to state 372
Parser(B) >> Reduce 53 [keyword_instruction ::= arg], pop back to state 8.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_SAY' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_SAY', go to state 22
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 22
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_SAY TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EOC' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 22.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 22.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 22.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 22.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 22.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 22.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 22.
Parser(B) >> ... then shift 'expression', go to state 331
Parser(B) >> Reduce 160 [say ::= TK_SAY expression], pop back to state 8.
Parser(B) >> ... then shift 'say', go to state 365
Parser(B) >> Reduce 60 [keyword_instruction ::= say], pop back to state 8.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 8.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 33
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_PLUS' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 33.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Shift 'TK_PLUS', go to state 64
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL addition TK_PLUS]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 64
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL addition TK_PLUS TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EOC' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 64.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 64.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 64.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 64.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 64.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 64.
Parser(B) >> ... then shift 'multiplication', go to state 240
Parser(B) >> Reduce 194 [addition ::= addition TK_PLUS multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 8.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 8.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_INTEGER' in state 33
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 8.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 8.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_INTEGER' in state 33
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options instruction_list var_symbol TK_EQUAL TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 8.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_RETURN' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_RETURN', go to state 23
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_RETURN]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 23
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_RETURN TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EOC' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 23.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 23.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 23.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 23.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 23.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 23.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 23.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 23.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 23.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 23.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 23.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 23.
Parser(B) >> ... then shift 'expression', go to state 332
Parser(B) >> Reduce 158 [return ::= TK_RETURN expression], pop back to state 8.
Parser(B) >> ... then shift 'return', go to state 366
Parser(B) >> Reduce 59 [keyword_instruction ::= return], pop back to state 8.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 8.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_EOS' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 8.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 1.
Parser(B) >> ... then shift 'instruction_list', go to state 8
Parser(B) >> Shift 'TK_EOS', go to state 388
Parser(B) >> Return. Stack=[rexx_options instruction_list TK_EOS]
Parser(B) >> Input '$' in state 388
Parser(B) >> Reduce 1 [program ::= rexx_options instruction_list TK_EOS], pop back to state 0.
Parser(B) >> ... then shift 'program', pending reduce -2
Parser(B) >> Accept!
Options parser >> Input 'TK_OPTIONS' in state 0
Options parser >> Shift 'TK_OPTIONS', go to state 1
Options parser >> Return. Stack=[TK_OPTIONS]
Options parser >> Input 'TK_LEVELB' in state 1
Options parser >> Shift 'TK_LEVELB', go to state 16
Options parser >> Return. Stack=[TK_OPTIONS TK_LEVELB]
Options parser >> Input 'TK_EOC' in state 16
Options parser >> Reduce 4 [option ::= TK_LEVELB], pop back to state 1.
Options parser >> ... then shift 'option', go to state 4
Options parser >> Reduce 18 [option_list ::= option] without external action, pop back to state 1.
Options parser >> ... then shift 'option_list', go to state 2
Options parser >> Shift 'TK_EOC', go to state 23
Options parser >> Return. Stack=[TK_OPTIONS option_list TK_EOC]
Options parser >> Input 'TK_SYMBOL' in state 23
Options parser >> WILDCARD TK_SYMBOL => ANYTHING
Options parser >> Reduce 2 [rexx_options ::= TK_OPTIONS option_list TK_EOC], pop back to state 0.
Options parser >> ... then shift 'rexx_options', go to state 3
Options parser >> WILDCARD TK_SYMBOL => ANYTHING
Options parser >> Shift 'TK_SYMBOL', go to state 20
Options parser >> Return. Stack=[rexx_options TK_SYMBOL]
Options parser >> Popping TK_SYMBOL
Options parser >> Popping rexx_options
Parser(B) >> Stack grows from 0 to 100 entries.
Parser(B) >> Input 'TK_OPTIONS' in state 0
Parser(B) >> Shift 'TK_OPTIONS', go to state 81
Parser(B) >> Return. Stack=[TK_OPTIONS]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 81
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 301
Parser(B) >> Return. Stack=[TK_OPTIONS TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EOC' in state 301
Parser(B) >> Reduce 18 [option ::= TK_VAR_SYMBOL], pop back to state 81.
Parser(B) >> ... then shift 'option', go to state 300
Parser(B) >> Reduce 16 [option_list ::= option], pop back to state 81.
Parser(B) >> ... then shift 'option_list', go to state 90
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 130
Parser(B) >> Shift 'TK_EOC', go to state 195
Parser(B) >> Return. Stack=[TK_OPTIONS option_list junk TK_EOC]
Parser(B) >> Input 'TK_IMPORT' in state 195
Parser(B) >> Reduce 15 [rexx_options ::= TK_OPTIONS option_list junk TK_EOC], pop back to state 0.
Parser(B) >> ... then shift 'rexx_options', go to state 1
Parser(B) >> Shift 'TK_IMPORT', go to state 91
Parser(B) >> Return. Stack=[rexx_options TK_IMPORT]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 91
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 290
Parser(B) >> Return. Stack=[rexx_options TK_IMPORT TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EOC' in state 290
Parser(B) >> Reduce 20 [literal ::= TK_VAR_SYMBOL], pop back to state 91.
Parser(B) >> ... then shift 'literal', go to state 97
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 389
Parser(B) >> Shift 'TK_EOC', go to state 200
Parser(B) >> Return. Stack=[rexx_options TK_IMPORT literal junk TK_EOC]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 200
Parser(B) >> Reduce 25 [namespace_instruction ::= TK_IMPORT literal junk TK_EOC], pop back to state 1.
Parser(B) >> ... then shift 'namespace_instruction', go to state 197
Parser(B) >> Reduce 21 [namespace_list ::= namespace_instruction], pop back to state 1.
Parser(B) >> ... then shift 'namespace_list', go to state 2
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options namespace_list TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 2.
Parser(B) >> ... then shift 'var_symbol', go to state 251
Parser(B) >> Shift 'TK_EQUAL', go to state 33
Parser(B) >> Return. Stack=[rexx_options namespace_list var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_INTEGER' in state 33
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options namespace_list var_symbol TK_EQUAL TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 33.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 33.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 33.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 33.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 33.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 33.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 33.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 33.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 33.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 33.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 33.
Parser(B) >> ... then shift 'expression', go to state 282
Parser(B) >> Reduce 48 [assignment ::= var_symbol TK_EQUAL expression], pop back to state 2.
Parser(B) >> ... then shift 'assignment', go to state 377
Parser(B) >> Reduce 45 [single_instruction ::= assignment], pop back to state 2.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options namespace_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_CALL' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 2.
Parser(B) >> ... then shift 'labeled_instruction', go to state 184
Parser(B) >> Reduce 33 [instruction_list ::= labeled_instruction], pop back to state 2.
Parser(B) >> ... then shift 'instruction_list', go to state 11
Parser(B) >> Shift 'TK_CALL', go to state 116
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_CALL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 116
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 248
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_CALL TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_STRING' in state 248
Parser(B) >> Reduce 163 [function_name ::= TK_VAR_SYMBOL], pop back to state 116.
Parser(B) >> ... then shift 'function_name', go to state 18
Parser(B) >> Shift 'TK_STRING', go to state 111
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_CALL function_name TK_STRING]
Parser(B) >> Input 'TK_EOC' in state 111
Parser(B) >> Reduce 179 [term ::= TK_STRING], pop back to state 18.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 18.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 18.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 18.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 18.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 18.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 18.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 18.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 18.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 18.
Parser(B) >> ... then shift 'and_expression', go to state 292
Parser(B) >> Reduce 252 [expression_in_list ::= and_expression], pop back to state 18.
Parser(B) >> ... then shift 'expression_in_list', go to state 299
Parser(B) >> Reduce 169 [expression_list ::= expression_in_list], pop back to state 18.
Parser(B) >> ... then shift 'expression_list', go to state 304
Parser(B) >> Reduce 166 [call ::= TK_CALL function_name expression_list], pop back to state 11.
Parser(B) >> ... then shift 'call', go to state 371
Parser(B) >> Reduce 54 [keyword_instruction ::= call], pop back to state 11.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 11.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_SAY' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 11.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 2.
Parser(B) >> ... then shift 'instruction_list', go to state 11
Parser(B) >> Shift 'TK_SAY', go to state 22
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_SAY]
Parser(B) >> Input 'TK_STRING' in state 22
Parser(B) >> Shift 'TK_STRING', go to state 111
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_SAY TK_STRING]
Parser(B) >> Input 'TK_EOC' in state 111
Parser(B) >> Reduce 179 [term ::= TK_STRING], pop back to state 22.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 22.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 22.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 22.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 22.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 22.
Parser(B) >> ... then shift 'expression', go to state 331
Parser(B) >> Reduce 160 [say ::= TK_SAY expression], pop back to state 11.
Parser(B) >> ... then shift 'say', go to state 365
Parser(B) >> Reduce 60 [keyword_instruction ::= say], pop back to state 11.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 11.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_SAY' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 11.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 2.
Parser(B) >> ... then shift 'instruction_list', go to state 11
Parser(B) >> Shift 'TK_SAY', go to state 22
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_SAY]
Parser(B) >> Input 'TK_STRING' in state 22
Parser(B) >> Shift 'TK_STRING', go to state 111
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_SAY TK_STRING]
Parser(B) >> Input 'TK_EOC' in state 111
Parser(B) >> Reduce 179 [term ::= TK_STRING], pop back to state 22.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 22.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 22.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 22.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 22.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 22.
Parser(B) >> ... then shift 'expression', go to state 331
Parser(B) >> Reduce 160 [say ::= TK_SAY expression], pop back to state 11.
Parser(B) >> ... then shift 'say', go to state 365
Parser(B) >> Reduce 60 [keyword_instruction ::= say], pop back to state 11.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 11.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_SAY' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 11.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 2.
Parser(B) >> ... then shift 'instruction_list', go to state 11
Parser(B) >> Shift 'TK_SAY', go to state 22
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_SAY]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 22
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_SAY TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 22.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 22.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 22.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 22.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_SAY concatenation TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EOC' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 61.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 61.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 61.
Parser(B) >> ... then shift 'bracket', go to state 216
Parser(B) >> Reduce 196 [prefix_expression_c ::= bracket], pop back to state 61.
Parser(B) >> ... then shift 'prefix_expression_c', go to state 214
Parser(B) >> Reduce 198 [power_expression_c ::= prefix_expression_c], pop back to state 61.
Parser(B) >> ... then shift 'power_expression_c', go to state 213
Parser(B) >> Reduce 200 [multiplication_c ::= power_expression_c], pop back to state 61.
Parser(B) >> ... then shift 'multiplication_c', go to state 238
Parser(B) >> Reduce 205 [addition_c ::= multiplication_c], pop back to state 61.
Parser(B) >> ... then shift 'addition_c', go to state 244
Parser(B) >> Reduce 210 [concatenation ::= concatenation addition_c], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 22.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 22.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 22.
Parser(B) >> ... then shift 'expression', go to state 331
Parser(B) >> Reduce 160 [say ::= TK_SAY expression], pop back to state 11.
Parser(B) >> ... then shift 'say', go to state 365
Parser(B) >> Reduce 60 [keyword_instruction ::= say], pop back to state 11.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 11.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_SAY' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 11.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 2.
Parser(B) >> ... then shift 'instruction_list', go to state 11
Parser(B) >> Shift 'TK_SAY', go to state 22
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_SAY]
Parser(B) >> Input 'TK_INTEGER' in state 22
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_SAY TK_INTEGER]
Parser(B) >> Input 'TK_PLUS' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 22.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 22.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 22.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Shift 'TK_PLUS', go to state 64
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_SAY addition TK_PLUS]
Parser(B) >> Input 'TK_INTEGER' in state 64
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_SAY addition TK_PLUS TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 64.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 64.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 64.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 64.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 64.
Parser(B) >> ... then shift 'multiplication', go to state 240
Parser(B) >> Reduce 194 [addition ::= addition TK_PLUS multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 22.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 22.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 22.
Parser(B) >> ... then shift 'expression', go to state 331
Parser(B) >> Reduce 160 [say ::= TK_SAY expression], pop back to state 11.
Parser(B) >> ... then shift 'say', go to state 365
Parser(B) >> Reduce 60 [keyword_instruction ::= say], pop back to state 11.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 11.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_SAY' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 11.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 2.
Parser(B) >> ... then shift 'instruction_list', go to state 11
Parser(B) >> Shift 'TK_SAY', go to state 22
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_SAY]
Parser(B) >> Input 'TK_FLOAT' in state 22
Parser(B) >> Shift 'TK_FLOAT', go to state 231
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_SAY TK_FLOAT]
Parser(B) >> Input 'TK_MINUS' in state 231
Parser(B) >> Reduce 177 [term ::= TK_FLOAT], pop back to state 22.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 22.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 22.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Shift 'TK_MINUS', go to state 63
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_SAY addition TK_MINUS]
Parser(B) >> Input 'TK_FLOAT' in state 63
Parser(B) >> Shift 'TK_FLOAT', go to state 231
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_SAY addition TK_MINUS TK_FLOAT]
Parser(B) >> Input 'TK_EOC' in state 231
Parser(B) >> Reduce 177 [term ::= TK_FLOAT], pop back to state 63.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 63.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 63.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 63.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 63.
Parser(B) >> ... then shift 'multiplication', go to state 239
Parser(B) >> Reduce 195 [addition ::= addition TK_MINUS multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 22.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 22.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 22.
Parser(B) >> ... then shift 'expression', go to state 331
Parser(B) >> Reduce 160 [say ::= TK_SAY expression], pop back to state 11.
Parser(B) >> ... then shift 'say', go to state 365
Parser(B) >> Reduce 60 [keyword_instruction ::= say], pop back to state 11.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 11.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_SAY' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 11.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 2.
Parser(B) >> ... then shift 'instruction_list', go to state 11
Parser(B) >> Shift 'TK_SAY', go to state 22
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_SAY]
Parser(B) >> Input 'TK_INTEGER' in state 22
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_SAY TK_INTEGER]
Parser(B) >> Input 'TK_DIV' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 22.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 22.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 22.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Shift 'TK_DIV', go to state 69
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_SAY multiplication TK_DIV]
Parser(B) >> Input 'TK_INTEGER' in state 69
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_SAY multiplication TK_DIV TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 69.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 69.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 69.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 69.
Parser(B) >> ... then shift 'power_expression', go to state 219
Parser(B) >> Reduce 190 [multiplication ::= multiplication TK_DIV power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 22.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 22.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 22.
Parser(B) >> ... then shift 'expression', go to state 331
Parser(B) >> Reduce 160 [say ::= TK_SAY expression], pop back to state 11.
Parser(B) >> ... then shift 'say', go to state 365
Parser(B) >> Reduce 60 [keyword_instruction ::= say], pop back to state 11.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 11.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_SAY' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 11.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 2.
Parser(B) >> ... then shift 'instruction_list', go to state 11
Parser(B) >> Shift 'TK_SAY', go to state 22
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_SAY]
Parser(B) >> Input 'TK_STRING' in state 22
Parser(B) >> Shift 'TK_STRING', go to state 111
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_SAY TK_STRING]
Parser(B) >> Input 'TK_CONCAT' in state 111
Parser(B) >> Reduce 179 [term ::= TK_STRING], pop back to state 22.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 22.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 22.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Shift 'TK_CONCAT', go to state 62
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_SAY concatenation TK_CONCAT]
Parser(B) >> Input 'TK_STRING' in state 62
Parser(B) >> Shift 'TK_STRING', go to state 111
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_SAY concatenation TK_CONCAT TK_STRING]
Parser(B) >> Input 'TK_EOC' in state 111
Parser(B) >> Reduce 179 [term ::= TK_STRING], pop back to state 62.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 62.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 62.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 62.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 62.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 62.
Parser(B) >> ... then shift 'addition', go to state 243
Parser(B) >> Reduce 209 [concatenation ::= concatenation TK_CONCAT addition], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 22.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 22.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 22.
Parser(B) >> ... then shift 'expression', go to state 331
Parser(B) >> Reduce 160 [say ::= TK_SAY expression], pop back to state 11.
Parser(B) >> ... then shift 'say', go to state 365
Parser(B) >> Reduce 60 [keyword_instruction ::= say], pop back to state 11.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 11.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_RETURN' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 11.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 2.
Parser(B) >> ... then shift 'instruction_list', go to state 11
Parser(B) >> Shift 'TK_RETURN', go to state 23
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_RETURN]
Parser(B) >> Input 'TK_EOC' in state 23
Parser(B) >> Reduce 159 [return ::= TK_RETURN], pop back to state 11.
Parser(B) >> ... then shift 'return', go to state 366
Parser(B) >> Reduce 59 [keyword_instruction ::= return], pop back to state 11.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 11.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_LABEL' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 11.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 2.
Parser(B) >> ... then shift 'instruction_list', go to state 11
Parser(B) >> Shift 'TK_LABEL', go to state 173
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_LABEL]
Parser(B) >> Input 'TK_PROCEDURE' in state 173
Parser(B) >> Shift 'TK_PROCEDURE', go to state 319
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_LABEL TK_PROCEDURE]
Parser(B) >> Input 'TK_EQUAL' in state 319
Parser(B) >> Shift 'TK_EQUAL', go to state 132
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_LABEL TK_PROCEDURE TK_EQUAL]
Parser(B) >> Input 'TK_CLASS' in state 132
Parser(B) >> Shift 'TK_CLASS', go to state 318
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_LABEL TK_PROCEDURE TK_EQUAL TK_CLASS]
Parser(B) >> Input 'TK_EOC' in state 318
Parser(B) >> Reduce 120 [class ::= TK_CLASS], pop back to state 132.
Parser(B) >> ... then shift 'class', go to state 379
Parser(B) >> Reduce 116 [procedure ::= TK_LABEL TK_PROCEDURE TK_EQUAL class], pop back to state 11.
Parser(B) >> ... then shift 'procedure', go to state 367
Parser(B) >> Reduce 58 [keyword_instruction ::= procedure], pop back to state 11.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 11.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_ARG' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 11.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 2.
Parser(B) >> ... then shift 'instruction_list', go to state 11
Parser(B) >> Shift 'TK_ARG', go to state 82
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_ARG]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 82
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 297
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_ARG TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EQUAL' in state 297
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 82.
Parser(B) >> ... then shift 'var_symbol', go to state 401
Parser(B) >> Shift 'TK_EQUAL', go to state 19
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_ARG var_symbol TK_EQUAL]
Parser(B) >> Input 'TK_CLASS' in state 19
Parser(B) >> Shift 'TK_CLASS', go to state 318
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_ARG var_symbol TK_EQUAL TK_CLASS]
Parser(B) >> Input 'TK_EOC' in state 318
Parser(B) >> Reduce 120 [class ::= TK_CLASS], pop back to state 19.
Parser(B) >> ... then shift 'class', go to state 313
Parser(B) >> Reduce 125 [argument ::= var_symbol TK_EQUAL class], pop back to state 82.
Parser(B) >> ... then shift 'argument', go to state 311
Parser(B) >> Reduce 122 [arg_list ::= argument], pop back to state 82.
Parser(B) >> ... then shift 'arg_list', go to state 317
Parser(B) >> Reduce 119 [arg ::= TK_ARG arg_list], pop back to state 11.
Parser(B) >> ... then shift 'arg', go to state 372
Parser(B) >> Reduce 53 [keyword_instruction ::= arg], pop back to state 11.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 11.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_SAY' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 11.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 2.
Parser(B) >> ... then shift 'instruction_list', go to state 11
Parser(B) >> Shift 'TK_SAY', go to state 22
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_SAY]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 22
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_SAY TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EOC' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 22.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 22.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 22.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 22.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 22.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 22.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 22.
Parser(B) >> ... then shift 'expression', go to state 331
Parser(B) >> Reduce 160 [say ::= TK_SAY expression], pop back to state 11.
Parser(B) >> ... then shift 'say', go to state 365
Parser(B) >> Reduce 60 [keyword_instruction ::= say], pop back to state 11.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 11.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_RETURN' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 11.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 2.
Parser(B) >> ... then shift 'instruction_list', go to state 11
Parser(B) >> Shift 'TK_RETURN', go to state 23
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_RETURN]
Parser(B) >> Input 'TK_INTEGER' in state 23
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_RETURN TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 23.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 23.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 23.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 23.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 23.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 23.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 23.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 23.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 23.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 23.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 23.
Parser(B) >> ... then shift 'expression', go to state 332
Parser(B) >> Reduce 158 [return ::= TK_RETURN expression], pop back to state 11.
Parser(B) >> ... then shift 'return', go to state 366
Parser(B) >> Reduce 59 [keyword_instruction ::= return], pop back to state 11.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 11.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_EOS' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 11.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 2.
Parser(B) >> ... then shift 'instruction_list', go to state 11
Parser(B) >> Shift 'TK_EOS', go to state 409
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_EOS]
Parser(B) >> Input '$' in state 409
Parser(B) >> Reduce 0 [program ::= rexx_options namespace_list instruction_list TK_EOS], pop back to state 0.
Parser(B) >> ... then shift 'program', pending reduce -2
Parser(B) >> Accept!
Options parser >> Input 'TK_OPTIONS' in state 0
Options parser >> Shift 'TK_OPTIONS', go to state 1
Options parser >> Return. Stack=[TK_OPTIONS]
Options parser >> Input 'TK_LEVELB' in state 1
Options parser >> Shift 'TK_LEVELB', go to state 16
Options parser >> Return. Stack=[TK_OPTIONS TK_LEVELB]
Options parser >> Input 'TK_EOC' in state 16
Options parser >> Reduce 4 [option ::= TK_LEVELB], pop back to state 1.
Options parser >> ... then shift 'option', go to state 4
Options parser >> Reduce 18 [option_list ::= option] without external action, pop back to state 1.
Options parser >> ... then shift 'option_list', go to state 2
Options parser >> Shift 'TK_EOC', go to state 23
Options parser >> Return. Stack=[TK_OPTIONS option_list TK_EOC]
Options parser >> Input 'TK_SYMBOL' in state 23
Options parser >> WILDCARD TK_SYMBOL => ANYTHING
Options parser >> Reduce 2 [rexx_options ::= TK_OPTIONS option_list TK_EOC], pop back to state 0.
Options parser >> ... then shift 'rexx_options', go to state 3
Options parser >> WILDCARD TK_SYMBOL => ANYTHING
Options parser >> Shift 'TK_SYMBOL', go to state 20
Options parser >> Return. Stack=[rexx_options TK_SYMBOL]
Options parser >> Popping TK_SYMBOL
Options parser >> Popping rexx_options
Parser(B) >> Stack grows from 0 to 100 entries.
Parser(B) >> Input 'TK_OPTIONS' in state 0
Parser(B) >> Shift 'TK_OPTIONS', go to state 81
Parser(B) >> Return. Stack=[TK_OPTIONS]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 81
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 301
Parser(B) >> Return. Stack=[TK_OPTIONS TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EOC' in state 301
Parser(B) >> Reduce 18 [option ::= TK_VAR_SYMBOL], pop back to state 81.
Parser(B) >> ... then shift 'option', go to state 300
Parser(B) >> Reduce 16 [option_list ::= option], pop back to state 81.
Parser(B) >> ... then shift 'option_list', go to state 90
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 130
Parser(B) >> Shift 'TK_EOC', go to state 195
Parser(B) >> Return. Stack=[TK_OPTIONS option_list junk TK_EOC]
Parser(B) >> Input 'TK_NAMESPACE' in state 195
Parser(B) >> Reduce 15 [rexx_options ::= TK_OPTIONS option_list junk TK_EOC], pop back to state 0.
Parser(B) >> ... then shift 'rexx_options', go to state 1
Parser(B) >> Shift 'TK_NAMESPACE', go to state 92
Parser(B) >> Return. Stack=[rexx_options TK_NAMESPACE]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 92
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 290
Parser(B) >> Return. Stack=[rexx_options TK_NAMESPACE TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EOC' in state 290
Parser(B) >> Reduce 20 [literal ::= TK_VAR_SYMBOL], pop back to state 92.
Parser(B) >> ... then shift 'literal', go to state 83
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 391
Parser(B) >> Shift 'TK_EOC', go to state 204
Parser(B) >> Return. Stack=[rexx_options TK_NAMESPACE literal junk TK_EOC]
Parser(B) >> Input 'TK_SAY' in state 204
Parser(B) >> Reduce 23 [namespace_instruction ::= TK_NAMESPACE literal junk TK_EOC], pop back to state 1.
Parser(B) >> ... then shift 'namespace_instruction', go to state 197
Parser(B) >> Reduce 21 [namespace_list ::= namespace_instruction], pop back to state 1.
Parser(B) >> ... then shift 'namespace_list', go to state 2
Parser(B) >> Shift 'TK_SAY', go to state 22
Parser(B) >> Return. Stack=[rexx_options namespace_list TK_SAY]
Parser(B) >> Input 'TK_STRING' in state 22
Parser(B) >> Shift 'TK_STRING', go to state 111
Parser(B) >> Return. Stack=[rexx_options namespace_list TK_SAY TK_STRING]
Parser(B) >> Input 'TK_EOC' in state 111
Parser(B) >> Reduce 179 [term ::= TK_STRING], pop back to state 22.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 22.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 22.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 22.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 22.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 22.
Parser(B) >> ... then shift 'expression', go to state 331
Parser(B) >> Reduce 160 [say ::= TK_SAY expression], pop back to state 2.
Parser(B) >> ... then shift 'say', go to state 365
Parser(B) >> Reduce 60 [keyword_instruction ::= say], pop back to state 2.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 2.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options namespace_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_SAY' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 2.
Parser(B) >> ... then shift 'labeled_instruction', go to state 184
Parser(B) >> Reduce 33 [instruction_list ::= labeled_instruction], pop back to state 2.
Parser(B) >> ... then shift 'instruction_list', go to state 11
Parser(B) >> Shift 'TK_SAY', go to state 22
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_SAY]
Parser(B) >> Input 'TK_STRING' in state 22
Parser(B) >> Shift 'TK_STRING', go to state 111
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_SAY TK_STRING]
Parser(B) >> Input 'TK_EOC' in state 111
Parser(B) >> Reduce 179 [term ::= TK_STRING], pop back to state 22.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 22.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 22.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 22.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 22.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 22.
Parser(B) >> ... then shift 'expression', go to state 331
Parser(B) >> Reduce 160 [say ::= TK_SAY expression], pop back to state 11.
Parser(B) >> ... then shift 'say', go to state 365
Parser(B) >> Reduce 60 [keyword_instruction ::= say], pop back to state 11.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 11.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_SAY' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 11.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 2.
Parser(B) >> ... then shift 'instruction_list', go to state 11
Parser(B) >> Shift 'TK_SAY', go to state 22
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_SAY]
Parser(B) >> Input 'TK_STRING' in state 22
Parser(B) >> Shift 'TK_STRING', go to state 111
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_SAY TK_STRING]
Parser(B) >> Input 'TK_EOC' in state 111
Parser(B) >> Reduce 179 [term ::= TK_STRING], pop back to state 22.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 22.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 22.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 22.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 22.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 22.
Parser(B) >> ... then shift 'expression', go to state 331
Parser(B) >> Reduce 160 [say ::= TK_SAY expression], pop back to state 11.
Parser(B) >> ... then shift 'say', go to state 365
Parser(B) >> Reduce 60 [keyword_instruction ::= say], pop back to state 11.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 11.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_SAY' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 11.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 2.
Parser(B) >> ... then shift 'instruction_list', go to state 11
Parser(B) >> Shift 'TK_SAY', go to state 22
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_SAY]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 22
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_SAY TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_VAR_SYMBOL' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 22.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 22.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 22.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 22.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Shift 'TK_VAR_SYMBOL', go to state 112
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_SAY concatenation TK_VAR_SYMBOL]
Parser(B) >> Input 'TK_EOC' in state 112
Parser(B) >> Reduce 12 [var_symbol ::= TK_VAR_SYMBOL], pop back to state 61.
Parser(B) >> ... then shift 'var_symbol', go to state 232
Parser(B) >> Reduce 176 [term ::= var_symbol], pop back to state 61.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 61.
Parser(B) >> ... then shift 'bracket', go to state 216
Parser(B) >> Reduce 196 [prefix_expression_c ::= bracket], pop back to state 61.
Parser(B) >> ... then shift 'prefix_expression_c', go to state 214
Parser(B) >> Reduce 198 [power_expression_c ::= prefix_expression_c], pop back to state 61.
Parser(B) >> ... then shift 'power_expression_c', go to state 213
Parser(B) >> Reduce 200 [multiplication_c ::= power_expression_c], pop back to state 61.
Parser(B) >> ... then shift 'multiplication_c', go to state 238
Parser(B) >> Reduce 205 [addition_c ::= multiplication_c], pop back to state 61.
Parser(B) >> ... then shift 'addition_c', go to state 244
Parser(B) >> Reduce 210 [concatenation ::= concatenation addition_c], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 22.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 22.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 22.
Parser(B) >> ... then shift 'expression', go to state 331
Parser(B) >> Reduce 160 [say ::= TK_SAY expression], pop back to state 11.
Parser(B) >> ... then shift 'say', go to state 365
Parser(B) >> Reduce 60 [keyword_instruction ::= say], pop back to state 11.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 11.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_SAY' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 11.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 2.
Parser(B) >> ... then shift 'instruction_list', go to state 11
Parser(B) >> Shift 'TK_SAY', go to state 22
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_SAY]
Parser(B) >> Input 'TK_INTEGER' in state 22
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_SAY TK_INTEGER]
Parser(B) >> Input 'TK_PLUS' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 22.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 22.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 22.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Shift 'TK_PLUS', go to state 64
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_SAY addition TK_PLUS]
Parser(B) >> Input 'TK_INTEGER' in state 64
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_SAY addition TK_PLUS TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 64.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 64.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 64.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 64.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 64.
Parser(B) >> ... then shift 'multiplication', go to state 240
Parser(B) >> Reduce 194 [addition ::= addition TK_PLUS multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 22.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 22.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 22.
Parser(B) >> ... then shift 'expression', go to state 331
Parser(B) >> Reduce 160 [say ::= TK_SAY expression], pop back to state 11.
Parser(B) >> ... then shift 'say', go to state 365
Parser(B) >> Reduce 60 [keyword_instruction ::= say], pop back to state 11.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 11.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_SAY' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 11.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 2.
Parser(B) >> ... then shift 'instruction_list', go to state 11
Parser(B) >> Shift 'TK_SAY', go to state 22
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_SAY]
Parser(B) >> Input 'TK_FLOAT' in state 22
Parser(B) >> Shift 'TK_FLOAT', go to state 231
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_SAY TK_FLOAT]
Parser(B) >> Input 'TK_MINUS' in state 231
Parser(B) >> Reduce 177 [term ::= TK_FLOAT], pop back to state 22.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 22.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 22.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Shift 'TK_MINUS', go to state 63
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_SAY addition TK_MINUS]
Parser(B) >> Input 'TK_FLOAT' in state 63
Parser(B) >> Shift 'TK_FLOAT', go to state 231
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_SAY addition TK_MINUS TK_FLOAT]
Parser(B) >> Input 'TK_EOC' in state 231
Parser(B) >> Reduce 177 [term ::= TK_FLOAT], pop back to state 63.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 63.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 63.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 63.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 63.
Parser(B) >> ... then shift 'multiplication', go to state 239
Parser(B) >> Reduce 195 [addition ::= addition TK_MINUS multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 22.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 22.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 22.
Parser(B) >> ... then shift 'expression', go to state 331
Parser(B) >> Reduce 160 [say ::= TK_SAY expression], pop back to state 11.
Parser(B) >> ... then shift 'say', go to state 365
Parser(B) >> Reduce 60 [keyword_instruction ::= say], pop back to state 11.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 11.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_SAY' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 11.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 2.
Parser(B) >> ... then shift 'instruction_list', go to state 11
Parser(B) >> Shift 'TK_SAY', go to state 22
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_SAY]
Parser(B) >> Input 'TK_INTEGER' in state 22
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_SAY TK_INTEGER]
Parser(B) >> Input 'TK_DIV' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 22.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 22.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 22.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Shift 'TK_DIV', go to state 69
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_SAY multiplication TK_DIV]
Parser(B) >> Input 'TK_INTEGER' in state 69
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_SAY multiplication TK_DIV TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 69.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 69.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 69.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 69.
Parser(B) >> ... then shift 'power_expression', go to state 219
Parser(B) >> Reduce 190 [multiplication ::= multiplication TK_DIV power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 22.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 22.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 22.
Parser(B) >> ... then shift 'expression', go to state 331
Parser(B) >> Reduce 160 [say ::= TK_SAY expression], pop back to state 11.
Parser(B) >> ... then shift 'say', go to state 365
Parser(B) >> Reduce 60 [keyword_instruction ::= say], pop back to state 11.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 11.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_RETURN' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 11.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 2.
Parser(B) >> ... then shift 'instruction_list', go to state 11
Parser(B) >> Shift 'TK_RETURN', go to state 23
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_RETURN]
Parser(B) >> Input 'TK_INTEGER' in state 23
Parser(B) >> Shift 'TK_INTEGER', go to state 230
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_RETURN TK_INTEGER]
Parser(B) >> Input 'TK_EOC' in state 230
Parser(B) >> Reduce 178 [term ::= TK_INTEGER], pop back to state 23.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 23.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 23.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 23.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 23.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 23.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 23.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 23.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 23.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 23.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 23.
Parser(B) >> ... then shift 'expression', go to state 332
Parser(B) >> Reduce 158 [return ::= TK_RETURN expression], pop back to state 11.
Parser(B) >> ... then shift 'return', go to state 366
Parser(B) >> Reduce 59 [keyword_instruction ::= return], pop back to state 11.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 11.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_LABEL' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 11.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 2.
Parser(B) >> ... then shift 'instruction_list', go to state 11
Parser(B) >> Shift 'TK_LABEL', go to state 173
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_LABEL]
Parser(B) >> Input 'TK_PROCEDURE' in state 173
Parser(B) >> Shift 'TK_PROCEDURE', go to state 319
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_LABEL TK_PROCEDURE]
Parser(B) >> Input 'TK_EOC' in state 319
Parser(B) >> Reduce 118 [procedure ::= TK_LABEL TK_PROCEDURE], pop back to state 11.
Parser(B) >> ... then shift 'procedure', go to state 367
Parser(B) >> Reduce 58 [keyword_instruction ::= procedure], pop back to state 11.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 11.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_SAY' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 11.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 2.
Parser(B) >> ... then shift 'instruction_list', go to state 11
Parser(B) >> Shift 'TK_SAY', go to state 22
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_SAY]
Parser(B) >> Input 'TK_STRING' in state 22
Parser(B) >> Shift 'TK_STRING', go to state 111
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_SAY TK_STRING]
Parser(B) >> Input 'TK_EOC' in state 111
Parser(B) >> Reduce 179 [term ::= TK_STRING], pop back to state 22.
Parser(B) >> ... then shift 'term', go to state 229
Parser(B) >> Reduce 180 [bracket ::= term], pop back to state 22.
Parser(B) >> ... then shift 'bracket', go to state 227
Parser(B) >> Reduce 182 [prefix_expression ::= bracket], pop back to state 22.
Parser(B) >> ... then shift 'prefix_expression', go to state 223
Parser(B) >> Reduce 186 [power_expression ::= prefix_expression], pop back to state 22.
Parser(B) >> ... then shift 'power_expression', go to state 222
Parser(B) >> Reduce 188 [multiplication ::= power_expression], pop back to state 22.
Parser(B) >> ... then shift 'multiplication', go to state 241
Parser(B) >> Reduce 193 [addition ::= multiplication], pop back to state 22.
Parser(B) >> ... then shift 'addition', go to state 245
Parser(B) >> Reduce 208 [concatenation ::= addition], pop back to state 22.
Parser(B) >> ... then shift 'concatenation', go to state 61
Parser(B) >> Reduce 211 [comparison ::= concatenation], pop back to state 22.
Parser(B) >> ... then shift 'comparison', go to state 253
Parser(B) >> Reduce 224 [or_expression ::= comparison], pop back to state 22.
Parser(B) >> ... then shift 'or_expression', go to state 255
Parser(B) >> Reduce 226 [and_expression ::= or_expression], pop back to state 22.
Parser(B) >> ... then shift 'and_expression', go to state 277
Parser(B) >> Reduce 249 [expression ::= and_expression], pop back to state 22.
Parser(B) >> ... then shift 'expression', go to state 331
Parser(B) >> Reduce 160 [say ::= TK_SAY expression], pop back to state 11.
Parser(B) >> ... then shift 'say', go to state 365
Parser(B) >> Reduce 60 [keyword_instruction ::= say], pop back to state 11.
Parser(B) >> ... then shift 'keyword_instruction', go to state 375
Parser(B) >> Reduce 47 [single_instruction ::= keyword_instruction], pop back to state 11.
Parser(B) >> ... then shift 'single_instruction', go to state 103
Parser(B) >> Reduce 8 [junk ::=].
Parser(B) >> ... then shift 'junk', go to state 407
Parser(B) >> Shift 'TK_EOC', go to state 192
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list single_instruction junk TK_EOC]
Parser(B) >> Input 'TK_EOS' in state 192
Parser(B) >> Reduce 36 [labeled_instruction ::= single_instruction junk TK_EOC], pop back to state 11.
Parser(B) >> ... then shift 'labeled_instruction', go to state 194
Parser(B) >> Reduce 34 [instruction_list ::= instruction_list labeled_instruction], pop back to state 2.
Parser(B) >> ... then shift 'instruction_list', go to state 11
Parser(B) >> Shift 'TK_EOS', go to state 409
Parser(B) >> Return. Stack=[rexx_options namespace_list instruction_list TK_EOS]
Parser(B) >> Input '$' in state 409
Parser(B) >> Reduce 0 [program ::= rexx_options namespace_list instruction_list TK_EOS], pop back to state 0.
Parser(B) >> ... then shift 'program', pending reduce -2
Parser(B) >> Accept!
Parser(B) >> Stack grows from 0 to 100 entries.
