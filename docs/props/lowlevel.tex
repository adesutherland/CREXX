\chapter{Low-Level System Information}
The execution environment of a \crexx{} program is a
threaded\footnote{an alternative, non-threaded executable is available
  under the \emph{rxbvm} name} virtual
machine that is designed for optimal performance. This virtual
machine, implemented in the \emph{rxvm} executable, executes
machine instructions produced by the \emph{rxc} \crexx{}
compiler, or written by hand, assembled into an .rxbin binary file by
the \emph{rxas} assembler.

\input{../Logical-REXX-VM.tex}

\section{RXVM machine instructions}

% \section{Machine Interface}
This section describes the processor-specific information for
RXVM processors. The instruction set can be seen as the ISA
(instruction set architecture) for
an RXVM processor, of which the microcode is implemented in the C99 language.

% \subsection{Processor Architecture}
\index{processor architecture}
\index{instruction set}
Programs intended to execute directly on the processor use the
RXVM instruction set and the
instruction encoding and semantics of this architecture.

An application program can assume that all instructions defined by the
architecture and that are neither privileged nor optional, exist and work
as documented.

To be ABI (application binary interface) conforming, the processor must implement the instructions of
the architecture, perform the specified operations, and produce the
expected results.  The ABI neither places performance constraints on
systems nor specifies what instructions must be implemented in
hardware.  A software implementation of the architecture conforms to
the ABI; likewise, the architecture could be implemented in hardware,
e.g. an FPGA.

% this is just a test
%% \directlua{ 
%% function runcommand(cmd) 
%% local fout = assert(io.popen(cmd, 'r')) 
%% local str = assert(fout:read('*a')) 
%% fout:close() 
%% return str 
%% end 

%% local sout=runcommand("rxas -i") 
%% local marg = assert(io.open("command.txt","w")) 
%% marg:write(sout) 
%% marg:flush() 
%% marg:close() 
%% } 
%% \verbatiminput{command.txt} 

\subsection{The Register}
\index{register}
RXVM is a Register based virtual machine, as opposed to a Stack based
VM. The number of registers is only limited by memory and, for
practical purposes, can be considered unlimited. The address size of
the fields in a register is, for the virtual machine implementations,
implied by the address size that the host OS can handle. For hardware
the size is undefined and can follow the hardware address generation
capacity.

\begin{lstlisting}[style=embed,label=crexxregister,caption={The
\crexx{} Register implementation in C}]
struct value {
    /* bit field to store value status - these are explicitly set */
    value_type status;

    /* Value */
    rxinteger int_value;
    double float_value;
    void *decimal_value; /* TODO */
    char *string_value;
    size_t string_length;
    size_t string_buffer_length;
    size_t string_pos;
#ifndef NUTF8
    size_t string_chars;
    size_t string_char_pos;
#endif
    void *object_value;
\end{lstlisting}

\subsubsection{Conversions of register values}
\index{conversions, data type in assembler}
\index{say instruction, rxas}
\index{int_value, register}
The status field determines for instructions that expect a data type,
which field is the field to act upon. Conversions are possible but
never implicit. So for example, when the register contains an int
value in field \code{int_value}, but it needs to be printed with the rxas
\keyword{say} instruction, the
\keyword{itos} takes care of the conversion and the population of the
memory area the \code{*string_value} points to. 

\begin{lstlisting}[style=embed,label=crexxregister,caption={Values of
the Status field}]
typedef union {
    struct {
        unsigned int type_object : 1;
        unsigned int type_string : 1;
        unsigned int type_decimal : 1;
        unsigned int type_float : 1;
        unsigned int type_int : 1;
    };
    unsigned int all_type_flags;
} value_type;
\end{lstlisting}

\subsubsection{Layout of a Register}
  \begin{tikzpicture}
    \matrix [memory layout, inner sep=0pt, nodes={inner sep=1ex},
    description/.style={text width=12em, text badly centered},
    cells={anchor=center}] (m) {
      \node [description] {status};
      \\
      \coordinate (A);\\
      \node [description] {int value};
      \\
      \coordinate (B);\\
      \node [description] {float value};
      \\
      \coordinate (C);\\
      \node [description] {*decimal value};
      \\
      \coordinate (D);\\
      \node [description] {*string value};
      \\
      \coordinate (E);\\
      \node [description] {string length};
      \\
      \coordinate (F);\\
      \node [description] {string buffer length};
      \\
      \coordinate (G);\\
      \node [description] {string pos};
      \\
      \coordinate (H);\\
      \node [description] {*object value};
      \\
    };
    \foreach \Node in {A, B, C, D, E, F, G, H} {
      \draw (\Node -| m.west) -- (\Node -| m.east);
    };
  \end{tikzpicture}

\subsubsection{Operand Types}

The following operand types are possible for assembler
instructions. The operand(s), if needed, always follow the instruction
mnemonic. A small subset of the instructions takes no operands, like
\keyword{RET}, \keyword{INC0}, \keyword{INC1}, \keyword{INC2}.

\begin{table}
  \centering
  \begin{DIFnomarkup}
  \begin{threeparttable}
    \begin{tabularx}{\textwidth}{lXl}
      \toprule
      Operand Type & Role &  \\
      \midrule
      \texttt{REG} & a register & \\
      \texttt{STRING} & a sequence of Unicode characters & \\
      \texttt{CHAR} & one Unicode character \\
      \texttt{FUNC} & a global or local function & \\
      \texttt{ID} & a label & \\
      \texttt{INT} & a number of type integer \dagger & \\
      \texttt{FLOAT} & a number of type float \dagger & \\
      \bottomrule
    \end{tabularx}
    \medskip
    \begin{tablenotes}
    \item [\dagger] maximum value implied by the host hardware.
    \end{tablenotes}
  \end{threeparttable}
  \end{DIFnomarkup}
  \caption{RXAS Assembler Instruction Operands}
  \label{tab:rxasoperands}
\end{table}


\subsection{RXVM Instruction Set}

\subsubsection{Fixed Point Arithmetic}

\subsubsection{Floating Point Arithmetic}

\subsubsection{Logical Operations}

\subsubsection{Branching}

\subsubsection{Input/Output Operations}

\subsection{RXAS Directives}

The \emph{rxas} assembler language has a number of statements that are
directives to the assembler as opposed to machine instructions.

\begin{table}
  \centering
  \begin{DIFnomarkup}
  \begin{threeparttable}
    \begin{tabularx}{\textwidth}{lXl}
      \toprule
      Directive & Role &  \\
      \midrule
      \texttt{*} & comment until end of line & \\
      \texttt{/* */} & delimited comment & \\
      \texttt{.globals=\emph{n}} & specifies number of globals & \\
      \texttt{.expose=\emph{package.symbol}} & expose (make globally known) & \\
      \texttt{.locals=\emph{n}} &  specifies number of locals & \\
      \bottomrule
    \end{tabularx}
    \medskip
    % \begin{tablenotes}
    % \item [\dagger] maximum value implied by the host hardware.
    % \end{tablenotes}
  \end{threeparttable}
  \end{DIFnomarkup}
  \caption{RXAS Assembler Directives}
  \label{tab:rxasdirectives}
\end{table}
