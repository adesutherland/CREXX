0x0018 addf       {REG,REG,REG}        Convert and Add to Float (op1=op2+op3) (Deprecated)
0x0019 addf       {REG,REG,FLOAT}      Convert and Add to Float (op1=op2+op3) (Deprecated)
0x0003 addi       {REG,REG,REG}        Convert and Add to Integer (op1=op2+op3) (Deprecated)
0x0004 addi       {REG,REG,INT}        Convert and Add to Integer (op1=op2+op3) (Deprecated)
0x0090 amap       {REG,REG}            Map op1 to arg register index in op2
0x0091 amap       {REG,INT}            Map op1 to arg register index  op2
0x0088 and        {REG,REG,REG}        Logical (int) and op1=(op2 && op3)
0x0047 append     {REG,REG}            String Append (op1=op1||op2)
0x0044 appendchar {REG,REG}            Append Concat Char op2 (as int) on op1
0x00d5 bcf        {ID,REG}             if op2=0 goto op1(if false) else dec op2
0x00d6 bcf        {ID,REG,REG}         if op2=0 goto op1(if false) else dec op2 and inc op3
0x00d1 bct        {ID,REG}             dec op2; if op2>0; goto op1(if true)
0x00d2 bct        {ID,REG,REG}         dec op2; inc op3, if op2>0; goto op1(if true)
0x00d3 bctnm      {ID,REG}             dec op2; if op2>=0; goto op1(if true)
0x00d4 bctnm      {ID,REG,REG}         dec op2; inc op3, if op2>=0; goto op1(if true)
0x00e1 beq        {ID,REG,REG}         if op2==op3 then goto op1
0x00e2 beq        {ID,REG,INT}         if op2==op3 then goto op1
0x00d9 bge        {ID,REG,REG}         if op2>=op3 then goto op1
0x00da bge        {ID,REG,INT}         if op2>=op3 then goto op1
0x00d7 bgt        {ID,REG,REG}         if op2>op3 then goto op1
0x00d8 bgt        {ID,REG,INT}         if op2>op3 then goto op1
0x00dd ble        {ID,REG,REG}         if op2<=op3 then goto op1
0x00de ble        {ID,REG,INT}         if op2<=op3 then goto op1
0x00db blt        {ID,REG,REG}         if op2<op3 then goto op1
0x00dc blt        {ID,REG,INT}         if op2<op3 then goto op1
0x00df bne        {ID,REG,REG}         if op2!=op3 then goto op1
0x00e0 bne        {ID,REG,INT}         if op2!=op3 then goto op1
0x00a4 br         {ID}                 Branch to op1
0x00a6 brf        {ID,REG}             Branch to op1 if op2 false
0x00a5 brt        {ID,REG}             Branch to op1 if op2 true
0x00a7 brtf       {ID,ID,REG}          Branch to op1 if op3 true, otherwise branch to op2
0x00ee brtpandt   {ID,REG,INT}         if op2.typeflag && op3 true then goto op1
0x00ed brtpt      {ID,REG}             if op2.typeflag true then goto op1
0x009c call       {REG,FUNC}           Call procedure (op1=op2())
0x009d call       {REG,FUNC,REG}       Call procedure (op1=op2(op3...) )
0x009b call       {FUNC}               Call procedure (op1())
0x00ce cnop       no operand           no operation
0x0041 concat     {REG,REG,REG}        String Concat (op1=op2||op3)
0x0042 concat     {REG,REG,STRING}     String Concat (op1=op2||op3)
0x0043 concat     {REG,STRING,REG}     String Concat (op1=op2||op3)
0x0045 concchar   {REG,REG,REG}        Concat Char op1 from op2 position op3
0x00aa copy       {REG,REG}            Copy op2 to op1
0x002b dec        {REG}                Decrement Int (op1--)
0x002d dec0       no operand           Decrement R0-- Int
0x002f dec1       no operand           Decrement R0-- Int
0x0031 dec2       no operand           Decrement R0-- Int
0x0027 divf       {REG,REG,REG}        Convert and Divide to Float (op1=op2/op3) (Deprecated)
0x0028 divf       {REG,REG,FLOAT}      Convert and Divide to Float (op1=op2/op3) (Deprecated)
0x0029 divf       {REG,FLOAT,REG}      Convert and Divide to Float (op1=op2/op3) (Deprecated)
0x0011 divi       {REG,REG,REG}        Convert and Divide to Integer (op1=op2/op3) (Deprecated)
0x0012 divi       {REG,REG,INT}        Convert and Divide to Integer (op1=op2/op3) (Deprecated)
0x00c9 dropchar   {REG,REG,REG}        set op1 from op2 after dropping all chars from op3
0x00bb exit       no operand           Exit
0x00bc exit       {REG}                Exit op1
0x00bd exit       {INT}                Exit op1
0x0016 fadd       {REG,REG,REG}        Float Add (op1=op2+op3)
0x0017 fadd       {REG,REG,FLOAT}      Float Add (op1=op2+op3)
0x00ac fcopy      {REG,REG}            Copy Float op2 to op1
0x0024 fdiv       {REG,REG,REG}        Float Divide (op1=op2/op3)
0x0025 fdiv       {REG,REG,FLOAT}      Float Divide (op1=op2/op3)
0x0026 fdiv       {REG,FLOAT,REG}      Float Divide (op1=op2/op3)
0x0066 feq        {REG,REG,REG}        Float Equals op1=(op2==op3)
0x0067 feq        {REG,REG,FLOAT}      Float Equals op1=(op2==op3)
0x00c5 fformat    {REG,REG,REG}        Set string value from float value using a format string
0x006a fgt        {REG,REG,REG}        Float Greater than op1=(op2>op3)
0x006b fgt        {REG,REG,FLOAT}      Float Greater than op1=(op2>op3)
0x006c fgt        {REG,FLOAT,REG}      Float Greater than op1=(op2>op3)
0x006d fgte       {REG,REG,REG}        Float Greater than equals op1=(op2>=op3)
0x006e fgte       {REG,REG,FLOAT}      Float Greater than equals op1=(op2>=op3)
0x006f fgte       {REG,FLOAT,REG}      Float Greater than equals op1=(op2>=op3)
0x0070 flt        {REG,REG,REG}        Float Less than op1=(op2<op3)
0x0071 flt        {REG,REG,FLOAT}      Float Less than op1=(op2<op3)
0x0072 flt        {REG,FLOAT,REG}      Float Less than op1=(op2<op3)
0x0073 flte       {REG,REG,REG}        Float Less than equals op1=(op2<=op3)
0x0074 flte       {REG,REG,FLOAT}      Float Less than equals op1=(op2<=op3)
0x0075 flte       {REG,FLOAT,REG}      Float Less than equals op1=(op2<=op3)
0x0020 fmult      {REG,REG,REG}        Float Multiply (op1=op2*op3)
0x0021 fmult      {REG,REG,FLOAT}      Float Multiply (op1=op2*op3)
0x00e3 fndblnk    {REG,REG,REG}        op1 = find next blank in op2[op3] and behind
0x00e4 fndnblnk   {REG,REG,REG}        op1 = find next next non blank in op2[op3] and behind
0x0068 fne        {REG,REG,REG}        Float Not equals op1=(op2!=op3)
0x0069 fne        {REG,REG,FLOAT}      Float Not equals op1=(op2!=op3)
0x00e6 fsex       {REG}                float op1 = -op1 (sign change)
0x001a fsub       {REG,REG,REG}        Float Subtract (op1=op2-op3)
0x001b fsub       {REG,REG,FLOAT}      Float Subtract (op1=op2-op3)
0x001c fsub       {REG,FLOAT,REG}      Float Subtract (op1=op2-op3)
0x00c2 ftob       {REG}                Set register boolean (int 1 or 0) value from its float value
0x00c1 ftoi       {REG}                Set register int value from its float value
0x00bf ftos       {REG}                Set register string value from its float value
0x00cd getbyte    {REG,REG,REG}        get byte  (op1=op2(op3)
0x0054 getstrpos  {REG,REG}            Get String (op2) charpos into op1
0x00e7 gettp      {REG,REG}            gets the register type flag (op1 = op2.typeflag)
0x0094 gmap       {REG,REG}            Map op1 to global var name in op2
0x0095 gmap       {REG,STRING}         Map op1 to global var name op2
0x0051 hexchar    {REG,REG,REG}        op1 (as hex) = op2[op3]
0x0001 iadd       {REG,REG,REG}        Integer Add (op1=op2+op3)
0x0002 iadd       {REG,REG,INT}        Integer Add (op1=op2+op3)
0x0032 iand       {REG,REG,REG}        bit wise and of 2 integers (op1=op2&op3)
0x0033 iand       {REG,REG,INT}        bit wise and of 2 integers (op1=op2&op3)
0x00ab icopy      {REG,REG}            Copy Integer op2 to op1
0x000e idiv       {REG,REG,REG}        Integer Divide (op1=op2/op3)
0x000f idiv       {REG,REG,INT}        Integer Divide (op1=op2/op3)
0x0010 idiv       {REG,INT,REG}        Integer Divide (op1=op2/op3)
0x0056 ieq        {REG,REG,REG}        Int Equals op1=(op2==op3)
0x0057 ieq        {REG,REG,INT}        Int Equals op1=(op2==op3)
0x005a igt        {REG,REG,REG}        Int Greater than op1=(op2>op3)
0x005b igt        {REG,REG,INT}        Int Greater than op1=(op2>op3)
0x005c igt        {REG,INT,REG}        Int Greater than op1=(op2>op3)
0x005d igte       {REG,REG,REG}        Int Greater than equals op1=(op2>=op3)
0x005e igte       {REG,REG,INT}        Int Greater than equals op1=(op2>=op3)
0x005f igte       {REG,INT,REG}        Int Greater than equals op1=(op2>=op3)
0x0060 ilt        {REG,REG,REG}        Int Less than op1=(op2<op3)
0x0061 ilt        {REG,REG,INT}        Int Less than op1=(op2<op3)
0x0062 ilt        {REG,INT,REG}        Int Less than op1=(op2<op3)
0x0063 ilte       {REG,REG,REG}        Int Less than equals op1=(op2<=op3)
0x0064 ilte       {REG,REG,INT}        Int Less than equals op1=(op2<=op3)
0x0065 ilte       {REG,INT,REG}        Int Less than equals op1=(op2<=op3)
0x0013 imod       {REG,REG,REG}        Integer Modulo (op1=op2%op3)
0x0014 imod       {REG,REG,INT}        Integer Modulo (op1=op2%op3)
0x0015 imod       {REG,INT,REG}        Integer Modulo (op1=op2&op3)
0x000a imult      {REG,REG,REG}        Integer Multiply (op1=op2*op3)
0x000b imult      {REG,REG,INT}        Integer Multiply (op1=op2*op3)
0x002a inc        {REG}                Increment Int (op1++)
0x002c inc0       no operand           Increment R0++ Int
0x002e inc1       no operand           Increment R0++ Int
0x0030 inc2       no operand           Increment R0++ Int
0x0058 ine        {REG,REG,REG}        Int Not equals op1=(op2!=op3)
0x0059 ine        {REG,REG,INT}        Int Not equals op1=(op2!=op3)
0x003c inot       {REG,REG}            inverts all bits of an integer (op1=~op2)
0x003d inot       {REG,INT}            inverts all bits of an integer (op1=~op2)
0x0034 ior        {REG,REG,REG}        bit wise or of 2 integers (op1=op2|op3)
0x0035 ior        {REG,REG,INT}        bit wise or of 2 integers (op1=op2|op3)
0x00cf ipow       {REG,REG,REG}        op1=op2**op3
0x00d0 ipow       {REG,REG,INT}        op1=op2**op3
0x00e5 isex       {REG}                dec op1 = -op1 (sign change)
0x0038 ishl       {REG,REG,REG}        bit wise shift logical left of integer (op1=op2<<op3)
0x0039 ishl       {REG,REG,INT}        bit wise shift logical left of integer (op1=op2<<op3)
0x003a ishr       {REG,REG,REG}        bit wise shift logical right of integer (op1=op2>>op3)
0x003b ishr       {REG,REG,INT}        bit wise shift logical right of integer (op1=op2>>op3)
0x0005 isub       {REG,REG,REG}        Integer Subtract (op1=op2-op3)
0x0006 isub       {REG,REG,INT}        Integer Subtract (op1=op2-op3)
0x0007 isub       {REG,INT,REG}        Integer Subtract (op1=op2-op3)
0x00c0 itof       {REG}                Set register float value from its int value
0x00be itos       {REG}                Set register string value from its int value
0x0036 ixor       {REG,REG,REG}        bit wise exclusive OR of 2 integers (op1=op2^op3)
0x0037 ixor       {REG,REG,INT}        bit wise exclusive OR of 2 integers (op1=op2^op3)
0x00ae link       {REG,REG}            Link op2 to op1
0x00b1 load       {REG,INT}            Load op1 with op2
0x00b2 load       {REG,FLOAT}          Load op1 with op2
0x00b4 load       {REG,CHAR}           Load op1 with op2
0x00b3 load       {REG,STRING}         Load op1 with op2
0x00e9 loadsettp  {REG,INT,INT}        load register and sets the register type flag load op1=op2 (op1.typeflag = op3)
0x00ea loadsettp  {REG,FLOAT,INT}      load register and sets the register type flag load op1=op2 (op1.typeflag = op3)
0x00eb loadsettp  {REG,STRING,INT}     load register and sets the register type flag load op1=op2 (op1.typeflag = op3)
0x008e map        {REG,REG}            Map op1 to var name in op2
0x008f map        {REG,STRING}         Map op1 to var name op2
0x00a8 move       {REG,REG}            Move op2 to op1 (Deprecated use swap)
0x008c mtime      {REG}                Put time in microseconds into op1
0x0022 multf      {REG,REG,REG}        Convert and Multiply to Float (op1=op2*op3) (Deprecated)
0x0023 multf      {REG,REG,FLOAT}      Convert and Multiply to Float (op1=op2*op3) (Deprecated)
0x000c multi      {REG,REG,REG}        Convert and Multiply to Integer (op1=op2*op3) (Deprecated)
0x000d multi      {REG,REG,INT}        Convert and Multiply to Integer (op1=op2*op3) (Deprecated)
0x008a not        {REG,REG}            Logical (int) not op1=!op2
0x0096 nsmap      {REG,REG,REG}        Map op1 to namespace in op2 var name in op3
0x0097 nsmap      {REG,REG,STRING}     Map op1 to namespace in op2 var name op3
0x0099 nsmap      {REG,STRING,REG}     Map op1 to namespace op2 var name in op3
0x0098 nsmap      {REG,STRING,STRING}  Map op1 to namespace op2 var name op3
0x00b0 null       {REG}                Null op1
0x0089 or         {REG,REG,REG}        Logical (int) or op1=(op2 || op3)
0x00cc padstr     {REG,REG,REG}        set op1=op2[repeated op3 times]
0x0092 pmap       {REG,REG}            Map op1 to parent var name in op2
0x0093 pmap       {REG,STRING}         Map op1 to parent var name op2
0x0052 poschar    {REG,REG,REG}        op1 = position of op3 in op2
0x009e ret        no operand           Return VOID
0x009f ret        {REG}                Return op1
0x00a0 ret        {INT}                Return op1
0x00a1 ret        {FLOAT}              Return op1
0x00a2 ret        {CHAR}               Return op1
0x00a3 ret        {STRING}             Return op1
0x0078 rseq       {REG,REG,REG}        non strict String Equals op1=(op2=op3)
0x0079 rseq       {REG,REG,STRING}     non strict String Equals op1=(op2=op3)
0x0046 sappend    {REG,REG}            String Append with space (op1=op1||op2)
0x00b5 say        {REG}                Say op1 (as string)
0x00b7 say        {INT}                Say op1
0x00b8 say        {FLOAT}              Say op1
0x00ba say        {CHAR}               Say op1
0x00b9 say        {STRING}             Say op1
0x003e sconcat    {REG,REG,REG}        String Concat with space (op1=op2||op3)
0x003f sconcat    {REG,REG,STRING}     String Concat with space (op1=op2||op3)
0x0040 sconcat    {REG,STRING,REG}     String Concat with space (op1=op2||op3)
0x00ad scopy      {REG,REG}            Copy String op2 to op1
0x0076 seq        {REG,REG,REG}        String Equals op1=(op2==op3)
0x0077 seq        {REG,REG,STRING}     String Equals op1=(op2==op3)
0x00ec setortp    {REG,INT}            or the register type flag (op1.typeflag = op1.typeflag || op2)
0x0053 setstrpos  {REG,REG}            Set String (op1) charpos set to op2
0x00e8 settp      {REG,INT}            sets the register type flag (op1.typeflag = op2)
0x007c sgt        {REG,REG,REG}        String Greater than op1=(op2>op3)
0x007d sgt        {REG,REG,STRING}     String Greater than op1=(op2>op3)
0x007e sgt        {REG,STRING,REG}     String Greater than op1=(op2>op3)
0x007f sgte       {REG,REG,REG}        String Greater than equals op1=(op2>=op3)
0x0080 sgte       {REG,REG,STRING}     String Greater than equals op1=(op2>=op3)
0x0081 sgte       {REG,STRING,REG}     String Greater than equals op1=(op2>=op3)
0x0082 slt        {REG,REG,REG}        String Less than op1=(op2<op3)
0x0083 slt        {REG,REG,STRING}     String Less than op1=(op2<op3)
0x0084 slt        {REG,STRING,REG}     String Less than op1=(op2<op3)
0x0085 slte       {REG,REG,REG}        String Less than equals op1=(op2<=op3)
0x0086 slte       {REG,REG,STRING}     String Less than equals op1=(op2<=op3)
0x0087 slte       {REG,STRING,REG}     String Less than equals op1=(op2<=op3)
0x007a sne        {REG,REG,REG}        String Not equals op1=(op2!=op3)
0x007b sne        {REG,REG,STRING}     String Not equals op1=(op2!=op3)
0x00b6 ssay       {REG}                String Say op1 (Deprecated use 'say reg')
0x00c3 stof       {REG}                Set register float value from its string value
0x00c4 stoi       {REG}                Set register int value from its string value
0x0050 strchar    {REG,REG}            op1 (as int) = op2[charpos]
0x004f strchar    {REG,REG,REG}        op1 (as int) = op2[op3]
0x004e strlen     {REG,REG}            String Length op1 = length(op2)
0x00c6 strlower   {REG,REG}            Set string to lower case value
0x00c7 strupper   {REG,REG}            Set string to upper case value
0x001d subf       {REG,REG,REG}        Convert and Subtract to Float (op1=op2-op3) (Deprecated)
0x001e subf       {REG,REG,FLOAT}      Convert and Subtract to Float (op1=op2-op3) (Deprecated)
0x001f subf       {REG,FLOAT,REG}      Convert and Subtract to Float (op1=op2-op3) (Deprecated)
0x0008 subi       {REG,REG,REG}        Convert and Subtract to Integer (op1=op2-op3) (Deprecated)
0x0009 subi       {REG,REG,INT}        Convert and Subtract to Integer (op1=op2-op3) (Deprecated)
0x00cb substcut   {REG,REG}            set op1=substr(op1,,op2) cuts off op1 after position op3
0x0055 substr     {REG,REG,REG}        op1 = op2[charpos]...op2[charpos+op3-1]
0x00ca substring  {REG,REG,REG}        set op1=substr(op2,op3) remaining string
0x00a9 swap       {REG,REG}            Swap op1 and op2
0x008b time       {REG}                Put time into op1
0x00c8 transchar  {REG,REG,REG}        replace op1 if it is in op3-list by char in op2-list
0x0048 triml      {REG,REG}            Trim String (op1) from Left by (op2) Chars
0x004b triml      {REG,REG,REG}        Trim String (op2) from Left by (op3) Chars into op1
0x0049 trimr      {REG,REG}            Trim String (op1) from Right by (op2) Chars
0x004c trimr      {REG,REG,REG}        Trim String (op2) from Right by (op3) Chars into op1
0x004a trunc      {REG,REG}            Trunc String (op1) to (op2) Chars
0x004d trunc      {REG,REG,REG}        Trunc String (op2) to (op3) Chars into op1
0x00af unlink     {REG}                Unlink op1
0x009a unmap      {REG}                Unmap op1
0x008d xtime      {REG,STRING}         put special time properties into op1
