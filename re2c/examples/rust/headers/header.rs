/* Generated by re2c */
// re2rust $INPUT -o $OUTPUT --header lexer/state.rs

mod lexer;
use lexer::state::State; // the module is generated by re2c



fn lex(st: &mut State) -> usize {
    let t: usize;
    
{
	#[allow(unused_assignments)]
	let mut yych : u8 = 0;
	let mut yystate : usize = 0;
	'yyl: loop {
		match yystate {
			0 => {
				yych = unsafe {*st.str.get_unchecked(st.cur)};
				match yych {
					0x61 => {
						st.cur += 1;
						yystate = 0;
						continue 'yyl;
					}
					0x62 => {
						st.yyt1 = st.cur;
						st.cur += 1;
						yystate = 2;
						continue 'yyl;
					}
					_ => {
						st.yyt1 = st.cur;
						yystate = 1;
						continue 'yyl;
					}
				}
			}
			1 => {
				t = st.yyt1;
				{ return t; }
			}
			2 => {
				yych = unsafe {*st.str.get_unchecked(st.cur)};
				match yych {
					0x62 => {
						st.cur += 1;
						yystate = 2;
						continue 'yyl;
					}
					_ => {
						yystate = 1;
						continue 'yyl;
					}
				}
			}
			_ => {
				panic!("internal lexer error")
			}
		}
	}
}

}

fn main() {
    let mut st = State {
        str: b"ab\0",
        cur: 0,
        yyt1: 0,
    };
    assert_eq!(lex(&mut st), 1);
}
/* Generated by re2c */

pub struct State<'a> {
    pub str: &'a [u8],
    pub cur: usize,
    pub yyt1: usize,
}
rust/headers/header.re:26:21: warning: rule matches empty string [-Wmatch-empty-string]
