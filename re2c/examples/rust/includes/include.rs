/* Generated by re2c */
// re2rust $INPUT -o $OUTPUT

#[derive(Debug, PartialEq)]
enum Num { Int, Float, NaN }




fn lex(str: &[u8]) -> Num {
    let mut cur = 0;
    let mut mar = 0;
    
{
	#[allow(unused_assignments)]
	let mut yych : u8 = 0;
	let mut yyaccept : usize = 0;
	let mut yystate : usize = 0;
	'yyl: loop {
		match yystate {
			0 => {
				yych = unsafe {*str.get_unchecked(cur)};
				cur += 1;
				match yych {
					0x2E => {
						yystate = 3;
						continue 'yyl;
					}
					0x30 => {
						yystate = 4;
						continue 'yyl;
					}
					0x31 ..= 0x39 => {
						yystate = 5;
						continue 'yyl;
					}
					_ => {
						yystate = 1;
						continue 'yyl;
					}
				}
			}
			1 => {
				yystate = 2;
				continue 'yyl;
			}
			2 => { return Num::NaN; }
			3 => {
				yych = unsafe {*str.get_unchecked(cur)};
				match yych {
					0x30 ..= 0x39 => {
						cur += 1;
						yystate = 7;
						continue 'yyl;
					}
					_ => {
						yystate = 2;
						continue 'yyl;
					}
				}
			}
			4 => {
				yyaccept = 0;
				mar = cur;
				yych = unsafe {*str.get_unchecked(cur)};
				match yych {
					0x2E => {
						cur += 1;
						yystate = 7;
						continue 'yyl;
					}
					0x30 ..= 0x39 => {
						cur += 1;
						yystate = 9;
						continue 'yyl;
					}
					0x45 |
					0x65 => {
						cur += 1;
						yystate = 11;
						continue 'yyl;
					}
					_ => {
						yystate = 2;
						continue 'yyl;
					}
				}
			}
			5 => {
				yyaccept = 1;
				mar = cur;
				yych = unsafe {*str.get_unchecked(cur)};
				match yych {
					0x2E => {
						cur += 1;
						yystate = 7;
						continue 'yyl;
					}
					0x30 ..= 0x39 => {
						cur += 1;
						yystate = 5;
						continue 'yyl;
					}
					0x45 |
					0x65 => {
						cur += 1;
						yystate = 11;
						continue 'yyl;
					}
					_ => {
						yystate = 6;
						continue 'yyl;
					}
				}
			}
			6 => { return Num::Int; }
			7 => {
				yyaccept = 2;
				mar = cur;
				yych = unsafe {*str.get_unchecked(cur)};
				match yych {
					0x30 ..= 0x39 => {
						cur += 1;
						yystate = 7;
						continue 'yyl;
					}
					0x45 |
					0x65 => {
						cur += 1;
						yystate = 11;
						continue 'yyl;
					}
					_ => {
						yystate = 8;
						continue 'yyl;
					}
				}
			}
			8 => { return Num::Float; }
			9 => {
				yych = unsafe {*str.get_unchecked(cur)};
				match yych {
					0x2E => {
						cur += 1;
						yystate = 7;
						continue 'yyl;
					}
					0x30 ..= 0x39 => {
						cur += 1;
						yystate = 9;
						continue 'yyl;
					}
					0x45 |
					0x65 => {
						cur += 1;
						yystate = 11;
						continue 'yyl;
					}
					_ => {
						yystate = 10;
						continue 'yyl;
					}
				}
			}
			10 => {
				cur = mar;
				match yyaccept {
					0 => {
						yystate = 2;
						continue 'yyl;
					}
					1 => {
						yystate = 6;
						continue 'yyl;
					}
					_ => {
						yystate = 8;
						continue 'yyl;
					}
				}
			}
			11 => {
				yych = unsafe {*str.get_unchecked(cur)};
				match yych {
					0x2B |
					0x2D => {
						cur += 1;
						yystate = 12;
						continue 'yyl;
					}
					0x30 ..= 0x39 => {
						cur += 1;
						yystate = 13;
						continue 'yyl;
					}
					_ => {
						yystate = 10;
						continue 'yyl;
					}
				}
			}
			12 => {
				yych = unsafe {*str.get_unchecked(cur)};
				match yych {
					0x30 ..= 0x39 => {
						cur += 1;
						yystate = 13;
						continue 'yyl;
					}
					_ => {
						yystate = 10;
						continue 'yyl;
					}
				}
			}
			13 => {
				yych = unsafe {*str.get_unchecked(cur)};
				match yych {
					0x30 ..= 0x39 => {
						cur += 1;
						yystate = 13;
						continue 'yyl;
					}
					_ => {
						yystate = 8;
						continue 'yyl;
					}
				}
			}
			_ => {
				panic!("internal lexer error")
			}
		}
	}
}

}

fn main() {
    assert_eq!(lex(b"123\0"), Num::Int);
    assert_eq!(lex(b"123.4567\0"), Num::Float);
}
