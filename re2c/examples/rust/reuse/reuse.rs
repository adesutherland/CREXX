/* Generated by re2c */
// re2rust $INPUT -o $OUTPUT --input-encoding utf8

// This example supports multiple input encodings: UTF-8 and UTF-32.
// Both lexers are generated from the same rules block, and the use
// blocks add only encoding-specific configurations.


fn lex_utf8(str: &[u8]) -> Option<usize> {
    let (mut cur, mut mar) = (0, 0);
    
{
	#[allow(unused_assignments)]
	let mut yych : u8 = 0;
	let mut yystate : usize = 0;
	'yyl: loop {
		match yystate {
			0 => {
				yych = unsafe {*str.get_unchecked(cur)};
				cur += 1;
				match yych {
					0xE2 => {
						yystate = 3;
						continue 'yyl;
					}
					_ => {
						yystate = 1;
						continue 'yyl;
					}
				}
			}
			1 => {
				yystate = 2;
				continue 'yyl;
			}
			2 => { return None; }
			3 => {
				mar = cur;
				yych = unsafe {*str.get_unchecked(cur)};
				match yych {
					0x88 => {
						cur += 1;
						yystate = 4;
						continue 'yyl;
					}
					_ => {
						yystate = 2;
						continue 'yyl;
					}
				}
			}
			4 => {
				yych = unsafe {*str.get_unchecked(cur)};
				match yych {
					0x80 => {
						cur += 1;
						yystate = 6;
						continue 'yyl;
					}
					_ => {
						yystate = 5;
						continue 'yyl;
					}
				}
			}
			5 => {
				cur = mar;
				yystate = 2;
				continue 'yyl;
			}
			6 => {
				yych = unsafe {*str.get_unchecked(cur)};
				match yych {
					0x78 => {
						cur += 1;
						yystate = 7;
						continue 'yyl;
					}
					_ => {
						yystate = 5;
						continue 'yyl;
					}
				}
			}
			7 => {
				yych = unsafe {*str.get_unchecked(cur)};
				match yych {
					0x20 => {
						cur += 1;
						yystate = 8;
						continue 'yyl;
					}
					_ => {
						yystate = 5;
						continue 'yyl;
					}
				}
			}
			8 => {
				yych = unsafe {*str.get_unchecked(cur)};
				match yych {
					0xE2 => {
						cur += 1;
						yystate = 9;
						continue 'yyl;
					}
					_ => {
						yystate = 5;
						continue 'yyl;
					}
				}
			}
			9 => {
				yych = unsafe {*str.get_unchecked(cur)};
				match yych {
					0x88 => {
						cur += 1;
						yystate = 10;
						continue 'yyl;
					}
					_ => {
						yystate = 5;
						continue 'yyl;
					}
				}
			}
			10 => {
				yych = unsafe {*str.get_unchecked(cur)};
				match yych {
					0x83 => {
						cur += 1;
						yystate = 11;
						continue 'yyl;
					}
					_ => {
						yystate = 5;
						continue 'yyl;
					}
				}
			}
			11 => {
				yych = unsafe {*str.get_unchecked(cur)};
				match yych {
					0x79 => {
						cur += 1;
						yystate = 12;
						continue 'yyl;
					}
					_ => {
						yystate = 5;
						continue 'yyl;
					}
				}
			}
			12 => { return Some(cur); }
			_ => {
				panic!("internal lexer error")
			}
		}
	}
}

}

fn lex_utf32(str: &[u32]) -> Option<usize> {
    let (mut cur, mut mar) = (0, 0);
    
{
	#[allow(unused_assignments)]
	let mut yych : u32 = 0;
	let mut yystate : usize = 0;
	'yyl: loop {
		match yystate {
			0 => {
				yych = unsafe {*str.get_unchecked(cur)};
				cur += 1;
				if yych == 0x00002200 {
					yystate = 2;
					continue 'yyl;
				}
				yystate = 1;
				continue 'yyl;
			}
			1 => { return None; }
			2 => {
				mar = cur;
				yych = unsafe {*str.get_unchecked(cur)};
				if yych != 0x00000078 {
					yystate = 1;
					continue 'yyl;
				}
				cur += 1;
				yych = unsafe {*str.get_unchecked(cur)};
				if yych == 0x00000020 {
					cur += 1;
					yystate = 4;
					continue 'yyl;
				}
				yystate = 3;
				continue 'yyl;
			}
			3 => {
				cur = mar;
				yystate = 1;
				continue 'yyl;
			}
			4 => {
				yych = unsafe {*str.get_unchecked(cur)};
				if yych != 0x00002203 {
					yystate = 3;
					continue 'yyl;
				}
				cur += 1;
				yych = unsafe {*str.get_unchecked(cur)};
				if yych != 0x00000079 {
					yystate = 3;
					continue 'yyl;
				}
				cur += 1;
				{ return Some(cur); }
			}
			_ => {
				panic!("internal lexer error")
			}
		}
	}
}

}

fn main() {
    let s8 = vec![0xe2, 0x88, 0x80, 0x78, 0x20, 0xe2, 0x88, 0x83, 0x79];
    assert_eq!(lex_utf8(&s8), Some(s8.len()));

    let s32 = vec![0x2200, 0x78, 0x20, 0x2203, 0x79];
    assert_eq!(lex_utf32(&s32), Some(s32.len()));
}
