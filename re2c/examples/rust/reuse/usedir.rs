/* Generated by re2c */
// re2rust $INPUT -o $OUTPUT

// This example shows how to combine reusable re2c blocks: two blocks
// ('colors' and 'fish') are merged into one. The 'salmon' rule occurs
// in both blocks; the 'fish' block takes priority because it is used
// earlier. Default rule * occurs in all three blocks; the local (not
// inherited) definition takes priority.

#[derive(Debug, PartialEq)]
enum Ans { Color, Fish, Dunno }





fn lex(str: &[u8]) -> Ans {
    let (mut cur, mut mar) = (0, 0);
    
{
	#[allow(unused_assignments)]
	let mut yych : u8 = 0;
	let mut yystate : usize = 0;
	'yyl: loop {
		match yystate {
			0 => {
				yych = unsafe {*str.get_unchecked(cur)};
				cur += 1;
				match yych {
					0x65 => {
						yystate = 3;
						continue 'yyl;
					}
					0x68 => {
						yystate = 4;
						continue 'yyl;
					}
					0x6D => {
						yystate = 5;
						continue 'yyl;
					}
					0x72 => {
						yystate = 6;
						continue 'yyl;
					}
					0x73 => {
						yystate = 7;
						continue 'yyl;
					}
					_ => {
						yystate = 1;
						continue 'yyl;
					}
				}
			}
			1 => {
				yystate = 2;
				continue 'yyl;
			}
			2 => { return Ans::Dunno; }
			3 => {
				mar = cur;
				yych = unsafe {*str.get_unchecked(cur)};
				match yych {
					0x65 => {
						cur += 1;
						yystate = 8;
						continue 'yyl;
					}
					_ => {
						yystate = 2;
						continue 'yyl;
					}
				}
			}
			4 => {
				mar = cur;
				yych = unsafe {*str.get_unchecked(cur)};
				match yych {
					0x61 => {
						cur += 1;
						yystate = 10;
						continue 'yyl;
					}
					_ => {
						yystate = 2;
						continue 'yyl;
					}
				}
			}
			5 => {
				mar = cur;
				yych = unsafe {*str.get_unchecked(cur)};
				match yych {
					0x61 => {
						cur += 1;
						yystate = 11;
						continue 'yyl;
					}
					_ => {
						yystate = 2;
						continue 'yyl;
					}
				}
			}
			6 => {
				mar = cur;
				yych = unsafe {*str.get_unchecked(cur)};
				match yych {
					0x65 => {
						cur += 1;
						yystate = 12;
						continue 'yyl;
					}
					_ => {
						yystate = 2;
						continue 'yyl;
					}
				}
			}
			7 => {
				mar = cur;
				yych = unsafe {*str.get_unchecked(cur)};
				match yych {
					0x61 => {
						cur += 1;
						yystate = 13;
						continue 'yyl;
					}
					_ => {
						yystate = 2;
						continue 'yyl;
					}
				}
			}
			8 => {
				yych = unsafe {*str.get_unchecked(cur)};
				match yych {
					0x6C => {
						cur += 1;
						yystate = 14;
						continue 'yyl;
					}
					_ => {
						yystate = 9;
						continue 'yyl;
					}
				}
			}
			9 => {
				cur = mar;
				yystate = 2;
				continue 'yyl;
			}
			10 => {
				yych = unsafe {*str.get_unchecked(cur)};
				match yych {
					0x64 => {
						cur += 1;
						yystate = 15;
						continue 'yyl;
					}
					_ => {
						yystate = 9;
						continue 'yyl;
					}
				}
			}
			11 => {
				yych = unsafe {*str.get_unchecked(cur)};
				match yych {
					0x67 => {
						cur += 1;
						yystate = 16;
						continue 'yyl;
					}
					_ => {
						yystate = 9;
						continue 'yyl;
					}
				}
			}
			12 => {
				yych = unsafe {*str.get_unchecked(cur)};
				match yych {
					0x64 => {
						cur += 1;
						yystate = 17;
						continue 'yyl;
					}
					_ => {
						yystate = 9;
						continue 'yyl;
					}
				}
			}
			13 => {
				yych = unsafe {*str.get_unchecked(cur)};
				match yych {
					0x6C => {
						cur += 1;
						yystate = 18;
						continue 'yyl;
					}
					_ => {
						yystate = 9;
						continue 'yyl;
					}
				}
			}
			14 => { return Ans::Fish; }
			15 => {
				yych = unsafe {*str.get_unchecked(cur)};
				match yych {
					0x64 => {
						cur += 1;
						yystate = 19;
						continue 'yyl;
					}
					_ => {
						yystate = 9;
						continue 'yyl;
					}
				}
			}
			16 => {
				yych = unsafe {*str.get_unchecked(cur)};
				match yych {
					0x65 => {
						cur += 1;
						yystate = 20;
						continue 'yyl;
					}
					_ => {
						yystate = 9;
						continue 'yyl;
					}
				}
			}
			17 => { return Ans::Color; }
			18 => {
				yych = unsafe {*str.get_unchecked(cur)};
				match yych {
					0x6D => {
						cur += 1;
						yystate = 21;
						continue 'yyl;
					}
					_ => {
						yystate = 9;
						continue 'yyl;
					}
				}
			}
			19 => {
				yych = unsafe {*str.get_unchecked(cur)};
				match yych {
					0x6F => {
						cur += 1;
						yystate = 22;
						continue 'yyl;
					}
					_ => {
						yystate = 9;
						continue 'yyl;
					}
				}
			}
			20 => {
				yych = unsafe {*str.get_unchecked(cur)};
				match yych {
					0x6E => {
						cur += 1;
						yystate = 23;
						continue 'yyl;
					}
					_ => {
						yystate = 9;
						continue 'yyl;
					}
				}
			}
			21 => {
				yych = unsafe {*str.get_unchecked(cur)};
				match yych {
					0x6F => {
						cur += 1;
						yystate = 24;
						continue 'yyl;
					}
					_ => {
						yystate = 9;
						continue 'yyl;
					}
				}
			}
			22 => {
				yych = unsafe {*str.get_unchecked(cur)};
				match yych {
					0x63 => {
						cur += 1;
						yystate = 25;
						continue 'yyl;
					}
					_ => {
						yystate = 9;
						continue 'yyl;
					}
				}
			}
			23 => {
				yych = unsafe {*str.get_unchecked(cur)};
				match yych {
					0x74 => {
						cur += 1;
						yystate = 26;
						continue 'yyl;
					}
					_ => {
						yystate = 9;
						continue 'yyl;
					}
				}
			}
			24 => {
				yych = unsafe {*str.get_unchecked(cur)};
				match yych {
					0x6E => {
						cur += 1;
						yystate = 14;
						continue 'yyl;
					}
					_ => {
						yystate = 9;
						continue 'yyl;
					}
				}
			}
			25 => {
				yych = unsafe {*str.get_unchecked(cur)};
				match yych {
					0x6B => {
						cur += 1;
						yystate = 14;
						continue 'yyl;
					}
					_ => {
						yystate = 9;
						continue 'yyl;
					}
				}
			}
			26 => {
				yych = unsafe {*str.get_unchecked(cur)};
				match yych {
					0x61 => {
						cur += 1;
						yystate = 17;
						continue 'yyl;
					}
					_ => {
						yystate = 9;
						continue 'yyl;
					}
				}
			}
			_ => {
				panic!("internal lexer error")
			}
		}
	}
}

}

fn main() {
    assert_eq!(lex(b"salmon"), Ans::Fish);
    assert_eq!(lex(b"what?"), Ans::Dunno);
}
