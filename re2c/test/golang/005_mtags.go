// Code generated by re2c, DO NOT EDIT.
//go:generate re2go $INPUT -o $OUTPUT -ir
package main

import "fmt"
import "reflect"

type mtagElem struct {
	tag, pred int
}

type mtagTrie = []mtagElem

func createPool(capacity int) mtagTrie {
	return make([]mtagElem, 0, capacity)
}

func mtag(mt *mtagTrie, tag int, val int) int {
	*mt = append(*mt, mtagElem{val, tag})
	return len(*mt) - 1
}

const mtagRoot int = -1



func LexSlices(str string) (a []int, b []int, c int) {
	var cursor, marker int

	var yyt3 int

	var yyt1 []int
	var yyt2 []int
	var yyt4 []int
	var yyt5 []int
	var yyt6 []int

	
{
	var yych byte
	yych = str[cursor]
	switch (yych) {
	case 0x00:
		yyt3 = -1
		yyt2 = append(yyt2, -1)
		yyt1 = append(yyt1, -1)
		goto yy2
	case 'a':
		yyt1 = append(yyt1, cursor)
		yyt5 = append(yyt5, cursor)
		yyt4 = append(yyt4, cursor)
		goto yy6
	case 'b':
		yyt2 = append(yyt2, cursor)
		goto yy7
	case 'c':
		yyt3 = cursor
		goto yy8
	default:
		goto yy4
	}
yy2:
	cursor += 1
	a = yyt1
	b = yyt2
	c = yyt3
	{ return }
yy4:
	cursor += 1
yy5:
	{return nil, nil, -2 }
yy6:
	cursor += 1
	marker = cursor
	yych = str[cursor]
	switch (yych) {
	case 0x00:
		yyt3 = -1
		yyt2 = append(yyt2, -1)
		goto yy9
	case 'a':
		goto yy11
	case 'b':
		yyt2 = append(yyt2, cursor)
		yyt6 = append(yyt6, cursor)
		goto yy14
	case 'c':
		yyt3 = cursor
		yyt2 = append(yyt2, -1)
		goto yy15
	default:
		goto yy5
	}
yy7:
	cursor += 1
	marker = cursor
	yych = str[cursor]
	switch (yych) {
	case 0x00:
		yyt3 = -1
		yyt5 = append(yyt5, -1)
		goto yy9
	case 'b':
		goto yy16
	default:
		goto yy5
	}
yy8:
	cursor += 1
	marker = cursor
	yych = str[cursor]
	switch (yych) {
	case 0x00:
		yyt2 = append(yyt2, -1)
		yyt5 = append(yyt5, -1)
		goto yy9
	case 'c':
		goto yy18
	default:
		goto yy5
	}
yy9:
	cursor += 1
	a = yyt5
	b = yyt2
	c = yyt3
	{ return }
yy11:
	cursor += 1
	yych = str[cursor]
	switch (yych) {
	case 0x00:
		yyt3 = -1
		yyt2 = append(yyt2, -1)
		goto yy9
	case 'a':
		goto yy11
	case 'b':
		yyt6 = append(yyt6, cursor)
		goto yy20
	default:
		goto yy13
	}
yy13:
	cursor = marker
	goto yy5
yy14:
	cursor += 1
	yych = str[cursor]
	switch (yych) {
	case 'c':
		yyt3 = cursor
		goto yy21
	default:
		goto yy13
	}
yy15:
	cursor += 1
	yych = str[cursor]
	switch (yych) {
	case 0x00:
		goto yy2
	case 'a':
		yyt1 = append(yyt1, cursor)
		goto yy22
	default:
		goto yy13
	}
yy16:
	cursor += 1
	yych = str[cursor]
	switch (yych) {
	case 0x00:
		yyt3 = -1
		yyt5 = append(yyt5, -1)
		goto yy9
	case 'b':
		goto yy16
	default:
		goto yy13
	}
yy18:
	cursor += 1
	yych = str[cursor]
	switch (yych) {
	case 0x00:
		yyt2 = append(yyt2, -1)
		yyt5 = append(yyt5, -1)
		goto yy9
	case 'c':
		goto yy18
	default:
		goto yy13
	}
yy20:
	cursor += 1
	yych = str[cursor]
	switch (yych) {
	case 'c':
		yyt3 = cursor
		goto yy23
	default:
		goto yy13
	}
yy21:
	cursor += 1
	yych = str[cursor]
	switch (yych) {
	case 'a':
		yyt1 = append(yyt1, cursor)
		goto yy22
	default:
		goto yy24
	}
yy22:
	cursor += 1
	yych = str[cursor]
	switch (yych) {
	case 'b':
		yyt2 = append(yyt2, cursor)
		goto yy27
	case 'c':
		yyt3 = cursor
		yyt2 = append(yyt2, -1)
		goto yy15
	default:
		goto yy13
	}
yy23:
	cursor += 1
	yych = str[cursor]
yy24:
	switch (yych) {
	case 0x00:
		goto yy25
	case 'c':
		goto yy23
	default:
		goto yy13
	}
yy25:
	cursor += 1
	a = yyt4
	b = yyt6
	c = yyt3
	{ return }
yy27:
	cursor += 1
	yych = str[cursor]
	switch (yych) {
	case 'c':
		yyt3 = cursor
		goto yy15
	default:
		goto yy13
	}
}

}

func LexTrie(str string) (mt mtagTrie, a int, b int, c int) {
	var cursor, marker int
	mt = createPool(256)

	var yyt3 int

	yyt1 := mtagRoot
	yyt2 := mtagRoot
	yyt4 := mtagRoot
	yyt5 := mtagRoot
	yyt6 := mtagRoot

	
{
	var yych byte
	yych = str[cursor]
	switch (yych) {
	case 0x00:
		yyt3 = -1
		yyt2 = mtag(&mt, yyt2, -1)
		yyt1 = mtag(&mt, yyt1, -1)
		goto yy30
	case 'a':
		yyt1 = mtag(&mt, yyt1, cursor)
		yyt5 = mtag(&mt, yyt5, cursor)
		yyt4 = mtag(&mt, yyt4, cursor)
		goto yy34
	case 'b':
		yyt2 = mtag(&mt, yyt2, cursor)
		goto yy35
	case 'c':
		yyt3 = cursor
		goto yy36
	default:
		goto yy32
	}
yy30:
	cursor += 1
	a = yyt1
	b = yyt2
	c = yyt3
	{ return }
yy32:
	cursor += 1
yy33:
	{ return mt, -2, -2, -2 }
yy34:
	cursor += 1
	marker = cursor
	yych = str[cursor]
	switch (yych) {
	case 0x00:
		yyt3 = -1
		yyt2 = mtag(&mt, yyt2, -1)
		goto yy37
	case 'a':
		goto yy39
	case 'b':
		yyt2 = mtag(&mt, yyt2, cursor)
		yyt6 = mtag(&mt, yyt6, cursor)
		goto yy42
	case 'c':
		yyt3 = cursor
		yyt2 = mtag(&mt, yyt2, -1)
		goto yy43
	default:
		goto yy33
	}
yy35:
	cursor += 1
	marker = cursor
	yych = str[cursor]
	switch (yych) {
	case 0x00:
		yyt3 = -1
		yyt5 = mtag(&mt, yyt5, -1)
		goto yy37
	case 'b':
		goto yy44
	default:
		goto yy33
	}
yy36:
	cursor += 1
	marker = cursor
	yych = str[cursor]
	switch (yych) {
	case 0x00:
		yyt2 = mtag(&mt, yyt2, -1)
		yyt5 = mtag(&mt, yyt5, -1)
		goto yy37
	case 'c':
		goto yy46
	default:
		goto yy33
	}
yy37:
	cursor += 1
	a = yyt5
	b = yyt2
	c = yyt3
	{ return }
yy39:
	cursor += 1
	yych = str[cursor]
	switch (yych) {
	case 0x00:
		yyt3 = -1
		yyt2 = mtag(&mt, yyt2, -1)
		goto yy37
	case 'a':
		goto yy39
	case 'b':
		yyt6 = mtag(&mt, yyt6, cursor)
		goto yy48
	default:
		goto yy41
	}
yy41:
	cursor = marker
	goto yy33
yy42:
	cursor += 1
	yych = str[cursor]
	switch (yych) {
	case 'c':
		yyt3 = cursor
		goto yy49
	default:
		goto yy41
	}
yy43:
	cursor += 1
	yych = str[cursor]
	switch (yych) {
	case 0x00:
		goto yy30
	case 'a':
		yyt1 = mtag(&mt, yyt1, cursor)
		goto yy50
	default:
		goto yy41
	}
yy44:
	cursor += 1
	yych = str[cursor]
	switch (yych) {
	case 0x00:
		yyt3 = -1
		yyt5 = mtag(&mt, yyt5, -1)
		goto yy37
	case 'b':
		goto yy44
	default:
		goto yy41
	}
yy46:
	cursor += 1
	yych = str[cursor]
	switch (yych) {
	case 0x00:
		yyt2 = mtag(&mt, yyt2, -1)
		yyt5 = mtag(&mt, yyt5, -1)
		goto yy37
	case 'c':
		goto yy46
	default:
		goto yy41
	}
yy48:
	cursor += 1
	yych = str[cursor]
	switch (yych) {
	case 'c':
		yyt3 = cursor
		goto yy51
	default:
		goto yy41
	}
yy49:
	cursor += 1
	yych = str[cursor]
	switch (yych) {
	case 'a':
		yyt1 = mtag(&mt, yyt1, cursor)
		goto yy50
	default:
		goto yy52
	}
yy50:
	cursor += 1
	yych = str[cursor]
	switch (yych) {
	case 'b':
		yyt2 = mtag(&mt, yyt2, cursor)
		goto yy55
	case 'c':
		yyt3 = cursor
		yyt2 = mtag(&mt, yyt2, -1)
		goto yy43
	default:
		goto yy41
	}
yy51:
	cursor += 1
	yych = str[cursor]
yy52:
	switch (yych) {
	case 0x00:
		goto yy53
	case 'c':
		goto yy51
	default:
		goto yy41
	}
yy53:
	cursor += 1
	a = yyt4
	b = yyt6
	c = yyt3
	{ return }
yy55:
	cursor += 1
	yych = str[cursor]
	switch (yych) {
	case 'c':
		yyt3 = cursor
		goto yy43
	default:
		goto yy41
	}
}

}

func cmp(str string, a, aref []int, b, bref []int, c, cref int) {
	if !(reflect.DeepEqual(a, aref) && reflect.DeepEqual(b, bref) && c == cref) {
		panic(fmt.Sprintf("failed %s: expected a=%v, b=%v, c=%v, got a=%v, b=%v, c=%v",
			str, aref, bref, cref, a, b, c))
	}
}

func testSlices(str string, aref []int, bref []int, cref int) {
	a, b, c := LexSlices(str)
	cmp(str, a, aref, b, bref, c, cref)
}

func testTrie(str string, aref []int, bref []int, cref int) {
	mt, a, b, c := LexTrie(str)
	cmp(str, unwind(mt, a), aref, unwind(mt, b), bref, c, cref)
}

func unwind(mt mtagTrie, tag int) []int {
	if tag == mtagRoot {
		return []int{}
	} else if tag > mtagRoot && tag < len(mt) {
		e := mt[tag]
		return append(unwind(mt, e.pred), e.tag)
	} else {
		return nil
	}
}

func test(str string, aref []int, bref []int, cref int) {
	testSlices(str, aref, bref, cref)
	testTrie(str, aref, bref, cref)
}

func main() {
	test("aabcc\000", []int{0}, []int{2}, 3)
	test("aaa\000", []int{0}, []int{-1}, -1)
	test("acabc\000", []int{0, 2}, []int{-1, 3}, 4)
	test("abcac\000", []int{0, 3}, []int{1, -1}, 4)
	test("ab\000", nil, nil, -2)
}
